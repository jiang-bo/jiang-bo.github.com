<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>非纯种程序猿</title>
 <link href="http://jiang-bo.github.com/" rel="self"/>
 <link href="http://jiang-bo.github.com"/>
 <updated>2013-03-18T11:21:47+08:00</updated>
 <id>http://jiang-bo.github.com</id>
 <author>
   <name>姜博</name>
   <email>jiang.bo.hit@gmail.com</email>
 </author>

 
 <entry>
   <title>HDFS RAID导致NameNode out网络流量异常飙升</title>
   <link href="http://jiang-bo.github.com/blog/2013/03/09/nn-network-out"/>
   <updated>2013-03-09T10:45:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2013/03/09/nn-network-out</id>
   <content type="html">&lt;p&gt;简记一次之前遇到的NN网络流量异常飙升的问题（NN网络流量飙升有很多中情况，如下只是一个特例）&lt;/p&gt;

&lt;h2&gt;问题现象&lt;/h2&gt;

&lt;p&gt;Ganglia监控发现，NN的out流量异常飙升，上升到60M~80M，关闭RaidNode之后流量下降到正常水平20M左右&lt;/p&gt;

&lt;h2&gt;问题分析&lt;/h2&gt;

&lt;p&gt;NN和RaidNode之间的数据传输主要是raid目录的文件信息查询（参见之前的&lt;a href=&quot;http://jiangbo.me/blog/2012/12/21/hdfs-raid/&quot;&gt;HDFS RAID介绍&lt;/a&gt;），主要通过DirectoryTraversal遍历目标文件中每个文件信息，返回目标目录中所有符合raid条见的文件。事实上这个遍历过程需要向NN递归调用FileSystem.listStatus()，请求目录下所有文件的信息，返回是一个FileStatus列表。
FileStatus结构主要如下：&lt;/p&gt;

&lt;p&gt;一个FileStauts除去Path之外序列化网络长度大概为140Byte，而Path的长度主要和其所对应的文件实际文件路径长度有关，云梯中一般为150Byte+的长度，也就意味这一个FileStatus的网络传输数据大概为240B，一般一个目录下有几十~几百左右的文件，一次FileSystem.listStatus调用传输的数据量大概是10k~100K，统计listStatus的RPC调用，ops大概是240，也就是该调用的每秒网络传输大概是2.4M~24M左右。貌似（注意，目前只是貌似）和NN异常流量有关。&lt;/p&gt;

&lt;h2&gt;第一阶段修复&lt;/h2&gt;

&lt;p&gt;社区中针对FileStatus中包含Path导致网络传输过大的问题，已经有一个patch进行解决，该patch主要通过一个不包含Path信息的HDFSFileStatus替换原有的FileStatus，减少Path信息的传输，参见：
&lt;a href=&quot;https://issues.apache.org/jira/browse/HDFS-946Q&quot;&gt;https://issues.apache.org/jira/browse/HDFS-946Q&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;验证&lt;/h2&gt;

&lt;p&gt;修复后进行验证，发现，流量却是有小幅下降，并没有起到本质的变化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/filestatus_fix.png&quot; alt=&quot;filestatus_fix&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;重新排查&lt;/h2&gt;

&lt;p&gt;重新观察流量情况，发现NN有显著的out流量增长，但是对应RaidNode上并没有显著的In流量增长，并且发现关闭RaidNode后，NN的out流量并不会立即下降，而当kill掉所有Raid Job后，NN流量显著下降。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/find_job.png&quot; alt=&quot;find_job&quot; /&gt;&lt;/p&gt;

&lt;p&gt;14：00停掉RaidNode，但Raid job继续运行的情况下，发现namenode的网络流量并没有变化，仍然居高不下。而当杀掉正在运行的3个Raid job以后，namenode流量立刻有一个大幅度的下降。由此可以推测流量上涨和Raid Job有关。&lt;/p&gt;

&lt;p&gt;进一步观察异常时期Raid Job的作业发现，流量上涨时，正在raid的文件中有大量blocksize=1M的文件。怀网络流量暴涨与blockSize较小的文件进行raid有关。仔细分析代码有如下几点值得注意：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;文件大小一般都是几百M，这意味着一个文件blockSize大概在几百个左右。而Raid job在进行raid时或通过srcFs.getFileBlockLocations(stat, 0, stat.getLen());获取整个文件所有的block数据校验是否符合进行。以文件有200个block计算，该调用1次返回接近30k左右。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Encoder在对源文件进行raid 编码时会同时打开10个InputStream(详见Encoder.stripeInputs())，打开过程先open，然后seek到响应偏移量，HDFS的open操作会预先读取一定大小的数据对应block的信息，该大小默认是10xdefaultBlockSize，其中defaultBlockSize在RaidNode中是256M，这意味这一次open将预先读取2560M数据，这对于blockSize=1M的小文件，这将返回2560个block的信息（实际返回是2560和文件block总数中较小的）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;RaidNode中PurgeMontior线程会每隔10s对raid的文件进行检查清理，并通过PlacementMonitor来校验是否有parity block和src block放置重复问题，PlacementMonitor同样会查询文件的所有block信息。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;以上三个地方在文件的block数较大时均会从NN获取较高的数据，为此，我做了一个测试：
1. 构建200个文件大小为200M，blockSize为1M的文件，对这个文件目录进行raid
2. 关掉RaidNode
3. 构建200个文件大小为200M，blockSize为32M的文件，对这些文件目录进行raid
4. 重复1.&lt;/p&gt;

&lt;p&gt;得到NN的网络流量结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/test_confg.png&quot; alt=&quot;test_confg&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;流量第一次增长是在200个blockSize=1M的文件进行raid&lt;/li&gt;
&lt;li&gt;raid job完成后，流量基本保持在一个新的高位。&lt;/li&gt;
&lt;li&gt;随后关掉raidNode，流量降至为0.&lt;/li&gt;
&lt;li&gt;重启raidnode之后，流量恢复至之前水平，并出现一个短暂的高峰。&lt;/li&gt;
&lt;li&gt;随后进行blockSize=32M的文件raid，流量未见明显增长。&lt;/li&gt;
&lt;li&gt;最后进行新的200个blockSize=1M的文件raid，流量上升到一个高峰后，在job运行完，流量有所回落，但比job运行前的流量略高。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;基本可以验证大量block数过大的文件的raid将导致NN流量上涨。&lt;/p&gt;

&lt;h2&gt;再次修复&lt;/h2&gt;

&lt;p&gt;上述问题中第2点是网络消耗最大，且最容易修复，只需要在Encoder之前设置RaidJob的dfs.read.prefetch.size为10x源文件blockSize，而不是默认的使用defaultBlockSize即可避免预读过大的问题。&lt;/p&gt;

&lt;h2&gt;重新验证&lt;/h2&gt;

&lt;p&gt;修改后进行了测试，通过对20个大小为200M，blockSize=1M的文件进行raid，在raid job运行时，NN的网络情况对比如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/fix_config.png&quot; alt=&quot;fix_config&quot; /&gt;&lt;/p&gt;

&lt;p&gt;14:05的峰值为修改前版本的raid job运行时NN out流量峰值，12M/s左右
14:41的峰值为修改后的版本，峰值为3.5M/s左右.
至此，问题基本解决&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>我的2012&2013</title>
   <link href="http://jiang-bo.github.com/blog/2013/01/28/my2012"/>
   <updated>2013-01-28T15:23:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2013/01/28/my2012</id>
   <content type="html">&lt;p&gt;拖了一个月的年终总结，今天趁有空偷懒来搞下&lt;/p&gt;

&lt;h2&gt;流水账&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1~2月：&lt;/strong&gt;担保通项目，中期时被上峰夭折了，也使我第一个大项目的技术经理以失败告终&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3月：&lt;/strong&gt;开始带新人，从一个实习生开始，感觉做的不是很到位，不够有耐心，个人喜欢那种聪明有自己想法的一点就透的人，导致新人成长也不是很顺利，惭愧&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4~7月：&lt;/strong&gt;可以说是2012最为忙碌的3个月，一堆理不清的事情，简单讲包括如下几个事情：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;新增了两个新人需要带，前后错了一个月的时间差，从新人身上看到很多自己当年的影子&lt;/li&gt;
&lt;li&gt;webx3升级拆分项目，预研，前期准备，组织开发，发布上线，第一个主动发起的有一定规模的技术项目，在两个苦逼的开发加一个苦逼的测试支持下完成了&lt;/li&gt;
&lt;li&gt;买家保障项目，与升级项目叠加在一起的一个业务项目，可以说是2012年信用线最主要的一个项目，在N次需求方案改版下，N次延期的情况下，在7月底上线了。这个项目是我第一次作为一个大项目（220多个人日）的PM+技术经理+开发，三合一，结果证实，我是一个失败的PM&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;8月：&lt;/strong&gt;买家保障上线之后，一系列的运营小需求不断上线，同时也开始重新审视享有的技术架构，规划信用体系的整体方案，写了一个报告，在一个自认为不是很适宜的时机（年中review前）发了出去，然后跑去厦门休整了一下，鼓浪屿风景不错，就是人太多！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9月：&lt;/strong&gt;一个偶然的机会，得知有机会转岗到北京HDFS团队，抱着试一试的心态，报了名，经过几轮面试，一不小心就转成功了。当得知可以转岗时，转与不转的这个选择，让我犹豫了很久，最终还是转了，期望能接触些新的东西。由此开启了我从一线业务开发转向平台支撑岗位的的转变历程&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10月：&lt;/strong&gt;十一假期带着女人见了下父母，见识下帝都的豪迈。假期之后正式到北京HDFS开发岗位报到，一切从零开始，北京人员少，组织松散，大部分要靠自己，按照新人学习的提纲，开始一点一点的看HDFS的源码，每天8：30到公司，晚上10：00离开，用了不到2周的时间，将HDFS的源码扫了一边，写了十几篇笔记，然后开始干活&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;11月：&lt;/strong&gt; 继续学习HDFS，边学边做，搞了几个性能优化的patch，一些小功能的改进优化&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;12月：&lt;/strong&gt; 继续边学边做，PS，玛雅人忒不靠谱，12月22日天一亮，我TMD还活着……&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;简单来说，2012年经历了一个充实的悲催的迷茫的前半年之后，tansfer到一个全新的枯燥的充满挑战的平台开发岗位，同时，在外面漂了6年多之后，终于回到了北京。相信这次选择对我后面的工作和生活都有这重要的影响，尽管目前来看还不知道这个选择是好是坏。&lt;/p&gt;

&lt;h2&gt;展望&lt;/h2&gt;

&lt;blockquote&gt;&lt;ol&gt;
&lt;li&gt;自己做个网站&lt;/li&gt;
&lt;li&gt;再一次长途旅行（环青海湖或这挺进新疆，诚征驴友）&lt;/li&gt;
&lt;li&gt;还有一个很重要的事，一时想不起来了，暂定“顺利度过2012吧！”&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;一年前定的三个目标，第一条已经彻底放弃了，年初买的那本rails的书，基本没怎么翻过；第二条也没实现，青海湖，新疆都没去，不过我的旅行版图上新增了几个已达的地标，厦门，苏州，天目湖，西塘，算是做了50%吧；第三条，到最后我也没想起我要干嘛，不过2012还是顺利通过了，主要是玛雅人太不靠谱&lt;/p&gt;

&lt;p&gt;发现每年定的目标最终能做到的越来越少，所以决定13年减少个目标，只有两个：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;求变，很不满意自己现在的生活工作状态，必须改变，即使改错也要尝试&lt;/li&gt;
&lt;li&gt;一次环中国旅行，今年25岁了，要在25岁前完成这个梦想——让我的足迹踏遍大半个中国。&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>HADOOP动态加载配置</title>
   <link href="http://jiang-bo.github.com/blog/2013/01/16/hadoop-reconfigurable"/>
   <updated>2013-01-16T15:01:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2013/01/16/hadoop-reconfigurable</id>
   <content type="html">&lt;h2&gt;简介&lt;/h2&gt;

&lt;p&gt;Hadoop集群运行过程中有时会需要对配置进行修改，而通常需要重启才能生效，如该HDFS Namenode的一个配置，需要重启NN才能生效。而对于规模较大的系统，重启的成本较高。&lt;a href=&quot;https://issues.apache.org/jira/browse/HADOOP-7001&quot;&gt;HADOOP-7001&lt;/a&gt;引入了一个reconfigurable机制。简述如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/reconfig_class.png&quot; alt=&quot;Reconfig_class&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HADOOP-7001提供了一个Reconfigure接口用于定义可动态配置的的行为。并提供了一个ReconfigurableBase抽象的基类实现。该基类有两个抽象方法，所有想要实现动态配置的节点，都需要实现这两个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//某个可以动态配置的属性变化时需要进行的处理
protected abstract void reconfigurePropertyImpl(String property, String newVal) 
    throws ReconfigurationException;

//定义该节点上所有可以进行动态配置的属性集合
public abstract Collection&amp;lt;String&amp;gt; getReconfigurableProperties();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了便于完成配置项变更，HADOOP-7001还提供了一个ReconfigurationServlet工具便于从web端变更配置。使用时只需要将该servelt加入到相应节点的httpserver中，并在context中加入conf.servlet.reconfigurable.$P的参数，值为对应的Reconfigurable实现（一般为节点自身实现），其中$P表示的是ReconfigurationServlet在httpServer中对应的path。&lt;/p&gt;

&lt;h2&gt;NameNode中的使用&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HDFS-1477&quot;&gt;HDFS-1477&lt;/a&gt;中提供了NameNode Reconfigurable的实现。概要分析如下：&lt;/p&gt;

&lt;h3&gt;1. 扩展ReconfigurableBase&lt;/h3&gt;

&lt;p&gt;首先需要扩展Reconfigurable来使NameNode支持动态配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class NameNode extends ReconfigurableBase implements ClientProtocol, 
    DatanodeProtocol,NamenodeProtocol, FSConstants {

      //。。。。
      //此处省略N多无关代码
      //        

      //实现当发生配置变更时Namenode的具体处理行为
      @Override
      public void reconfigurePropertyImpl(String property, String newVal) 
        throws ReconfigurationException {
        // just pass everything to the namesystem
        if (namesystem.isPropertyReconfigurable(property)) {
         namesystem.reconfigureProperty(property, newVal);
        } else if (&quot;fs.trash.interval&quot;.equals(property)) {
          try {
            if (newVal == null) {
              // set to default
              trash.setDeleteInterval(60L * Trash.MSECS_PER_MINUTE);
            } else {
              trash.setDeleteInterval((long)(
                  Float.valueOf(newVal) * Trash.MSECS_PER_MINUTE));
            }
            LOG.info(&quot;RECONFIGURE* changed trash deletion interval to &quot; +
                newVal);
          } catch (NumberFormatException e) {
            throw new ReconfigurationException(property, newVal,
                getConf().get(property));
          }
        } else {
          throw new ReconfigurationException(property, newVal,
                                             getConf().get(property));
        }
      }

      //设置NameNode上允许动态配置的属性值
      @Override
      public List&amp;lt;String&amp;gt; getReconfigurableProperties() {
        // only allow reconfiguration of namesystem's reconfigurable properties
        List&amp;lt;String&amp;gt; properties = namesystem.getReconfigurableProperties();
        properties.add(&quot;fs.trash.interval&quot;);
        return properties;
      }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2. 在httpserver中配置ReconfigurationServlet&lt;/h3&gt;

&lt;p&gt;为了便于配置，需要在httpserver中添加ReconfigurationServlet，具体代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void startHttpServer(Configuration conf) throws IOException {

    //省略无关代码

    //设置context属性
    httpServer.setAttribute(ReconfigurationServlet.
                            CONF_SERVLET_RECONFIGURABLE_PREFIX +
                            CONF_SERVLET_PATH, NameNode.this);
    //添加servelt， path为nnconfchange
    httpServer.addServlet(&quot;nnconfchange&quot;, CONF_SERVLET_PATH,
                          ReconfigurationServlet.class);
    this.httpServer.start();

    // The web-server port can be ephemeral... ensure we have the correct info
    infoPort = this.httpServer.getPort();
    this.httpAddress = new InetSocketAddress(infoHost, infoPort);
    conf.set(&quot;dfs.http.address&quot;, infoHost + &quot;:&quot; + infoPort);
    LOG.info(&quot;Web-server up at: &quot; + infoHost + &quot;:&quot; + infoPort);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3.具体使用&lt;/h3&gt;

&lt;p&gt;登录到NN，修改配置文件，通过web访问 http://hdfsnn:port/nnconfchange来查看配置项，点击apply可以是新的配置项生效，如果配置项变更出错会返回500.  &lt;br/&gt;
&lt;img src=&quot;/images/hdfs/reconfig_apply.png&quot; alt=&quot;Reconfig_apply&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>HDFS RAID</title>
   <link href="http://jiang-bo.github.com/blog/2012/12/21/hdfs-raid"/>
   <updated>2012-12-21T11:19:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/12/21/hdfs-raid</id>
   <content type="html">&lt;h2&gt;一、背景&lt;/h2&gt;

&lt;p&gt;HDFS是构建在普通机器上的分布式文件系统，而这类系统需要解决的一个首要问题就是容错，允许部分节点失效。而为了解决数据的可靠性，HDFS采用了副本策略。默认会为所有的block存放三个副本（具体参见HDFS设计文档）。
副本机制能够有效解决部分节点失效导致数据丢失的问题，但对于大规模的HDFS集群，副本机制会带来大量的存储资源消耗。例如为了存储1PB的数据，默认需要保留3个副本，这意味着实际存储所有副本需要至少3PB的空间。存储空间浪费达到200%。减小浪费的方式主要是减少副本数，而当副本数降低到小于3时，数据丢失的风险会非常高。而HDFS RAID的出现主要是解决降低副本数之后，通过RAID机制中的Erasured Code来确保数据的可用性。&lt;/p&gt;

&lt;script async class=&quot;speakerdeck-embed&quot; data-id=&quot;3f1abed02d630130814722000a9d03e5&quot; data-ratio=&quot;1.2994923857868&quot; src=&quot;//speakerdeck.com/assets/embed.js&quot;&gt;&lt;/script&gt;


&lt;h2&gt;二、整体结构&lt;/h2&gt;

&lt;p&gt;HDFS RAID的实现（Facebook的实现）主要是在现有的HDFS之上增加了一个包装contrib。之所以不再HDFS上直接修改，原设计者的解释是“HDFS的核心代码已经够复杂了，不想让它更复杂”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/Raid-Overview.png&quot; alt=&quot;Overview&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;2.1 使用的角度看HDFS RAID（Client端）&lt;/h3&gt;

&lt;p&gt;HDFS RAID的使用场景主要有两个：raid数据管理和raid数据读取。&lt;/p&gt;

&lt;h4&gt;2.1.1 Raid数据的管理&lt;/h4&gt;

&lt;p&gt;对于DRFS的管理，包括DFS中那些文件需要进行raid化，查询raid文件的状态等，主要通过HDFS-RAID提供的RaidShell工具来完成。本质上RaidShell作为一个client工具，通过RPC与集群中的RaidNode通信，完成各种管理操作。&lt;/p&gt;

&lt;h4&gt;2.1.2 Raid数据读写&lt;/h4&gt;

&lt;p&gt;使用HDFS RAID的client端需要配置fs.hdfs.impl为DistributedRaidFileSytem，DRFS包装了DFS的读（只是读）请求，当block读取时发生block丢失（抛出MissingBlockException)或损坏(CorruptionException)时，DRFS会捕获这两个异常，并向RaidNode发送RPC对失效的数据进行恢复。&lt;/p&gt;

&lt;h3&gt;2.2  RaidNode结构(Server端）&lt;/h3&gt;

&lt;p&gt;RaidNode是HDFS-RAID中除NameNode和JobTracker之外的第三个master node，主要是接收client端的RPC请求和调度各守护线程完成数据的raid化和数据修复，parity文件删除等操作。&lt;/p&gt;

&lt;h4&gt;2.2.1 两种实现&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;LocalRaidNode:&lt;/strong&gt; 在RaidNode本地进行parity计算，parity文件的生成是一个计算密集型任务，而本地计算能力有限，因此该方式的扩展性有限。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DistributedRaidNode:&lt;/strong&gt; 通过提交mapreduce job来进行parity计算&lt;/p&gt;

&lt;h4&gt;2.2.2 主要线程&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;TriggerMonitor:&lt;/strong&gt; 周期性检查raid-policy配置，根据最新的配置来进行对相应的数据raid化。raid化的调度周期主要收两个配置的影响，raid.config.reload.interval （重新加载raid-policy配置的周期，默认10s）和raid.policy.rescan.interval（重新扫描需要raid化的src的间隔，默认1小时）。简单讲，当新增了一个policy时，默认10s内该policy会被加载执行。而在一个已经raid化的目录中新增了一个文件时，该文件将在1个小时内被raid话。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BlockIntegrityMonitor:&lt;/strong&gt; 负责通过DFS的fsck来对DRFS中已经raid化的数据进行检查，检查内容主要包括corrupt（损坏）和decomssion（丢失）的文件。一旦检测到这类文件的存在，BlocIntegrityMonitor会通过其维护的CorruptMonitor和DecomissionMonitor的两个线程来进行数据的修复。BlockIntegrityMonitor对应local和dist两种模式有两个实现，分别为LocalBlockIntegrityMonitor和DistBlockIntegrityMonitor。（可通过raid.blockfix.classname配置项设置，默认为dist）。区别主要在获取的corruptionMonitor和DecomissionMonitor的实现不同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LocalBlockIntegrityMonitor:&lt;/strong&gt; 提供了CorruptMonitor实现会循环通过fsck检查corrupt文件，通过BlockReconstructor.CorruptBlockReconstructor重建这些文件。但该实现不提供Decomissioning文件的监控处理。local模式下corrput文件的重建是在RaidNode上进行的，对大量数据的重建，会对RaidNode有较大的压力。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DistBlockIntegrityMonitor:&lt;/strong&gt; Dist模式提供的CorruptionMonitor和DecomissionMonitor是通过DFSck获取corrupt和decomissed的文件列表，计算优先级后，通过向集群提交job来完成重建，Job的输入是一个包含所有文件path的sequence file，Mapper实现是通过Reconstructor来重建每个文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BlockFixer(CorruptionMonitor):&lt;/strong&gt; BlockIntegrityMonitor构建的用于修复corrupt文件的worker线程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BlockCopier(DecomissionMonitor):&lt;/strong&gt; BlockIntegrityMonitor构建用于修复decomission文件的worker线程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PlacementMonitor:&lt;/strong&gt; PlacementMonitor主要是通过blockMover完成为DRFS中的根据placement策略提供在Datanode之间move block的工具线程。BlockMover通过一个ClusterInfo线程周期性（默认1min）获取集群中live节点的最新topo结构。对于parity block过于集中的节点，需要将其分散开。分散的过程主要是：为每个的block构建一个BlockMoveAction线程，该线程在所有datanode中除当前block所在的节点外随机选取一个datanode，并选取一个proxysource datanode，proxysource datanode是用于将block复制到datanode的源节点，选取规则是优先选取当前block副本所在dn中与目标datanode所属同一rack的节点，如果没有，则从副本列表中随机选取一个作为源节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PurgeThread:&lt;/strong&gt; PurgeThread封装了PurgeMonitor，它会定期扫描Parity文件中是否有孤儿Parity文件(即拥有该Parity文件的source文件已经不存在了)，如果有则需要将其删除，如果没有，会对Parity文件和对应的source文件进行placement检查。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HarThread:&lt;/strong&gt; 为了减少RAID后Parity文件对Namenode的负担，HarThread封装了HarMonitor，它定期对超期的Parity文件进行归档处理(HAR)，超期时间由raid.parity.har.threshold.days指定，默认是3天。&lt;/p&gt;

&lt;h2&gt;三、 raid和unraid流程详解&lt;/h2&gt;

&lt;h3&gt;3.1 数据raid化&lt;/h3&gt;

&lt;p&gt;文件数据的raid化有两种场景，一种是通过raidShell之行 raidFile命令触发&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hadoop raidshell -raidFile /path/to/file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一种是TiggerMonitor线程周期行扫描policy，根据新的配置信息进行相应的raid化。&lt;/p&gt;

&lt;h4&gt;3.1.1 raidShell执行raidFile&lt;/h4&gt;

&lt;p&gt;当前client端执行raidfile请求时，大致的处理流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/Raid-RaidFile.png&quot; alt=&quot;raidFile&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先检查请求的delay时间，还未到delay时间则不执行&lt;/li&gt;
&lt;li&gt;参数处理，包括path路径校验，codec设置等&lt;/li&gt;
&lt;li&gt;查询path路径状态，如果是文件或者当前模式是local模式，则执行doLocalRaid，通过RaidNode.doRaid()对path下所有文件进行raid。&lt;/li&gt;
&lt;li&gt;如果是目录且当前配置的raid模式是dist，则通过raidNode.submitRaid() rpc请求向RaidNode提交raid请求。&lt;/li&gt;
&lt;li&gt;RaidNode接收到client提交的请求后，根据提交的额参数构造一个raid-policy，并添加到configMangaer中。等待RaidNode上TiggerMonitor守护线程下次运行是处理该policy。&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;3.1.2 triggerMonitor线程处理流程&lt;/h4&gt;

&lt;p&gt;triggerMonitor作为RaidNode上的守护线程，周期性从configManager中获取policy列表，对每个policy进行如下处理：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;查询该policy的状态，如果未执行过，则立即处理，获取path中文件列表。如果该policy已经处理过，过滤其path中尚未处理的file。&lt;/li&gt;
&lt;li&gt;如果是local模式，对列表中的file执行RaidNode.doRaid()&lt;/li&gt;
&lt;li&gt;如果是dist模式，通过DistRaid构建一个raid job，该job的输入文件是所有待raid文件path构成的sequence file。mapper主要是调用RaidNode.doRaid()对输入中的file path进行raid。&lt;/li&gt;
&lt;/ol&gt;


&lt;h5&gt;RaidNode.doRaid()流程&lt;/h5&gt;

&lt;p&gt;上述表明，hdfs raid中对文件的raid最终都是由RaidNode.doRaid()来完成，不通场景下的区别主要是raid过程的执行地点不同：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;raidshell执行的local模式或者单个文件，raid过程是在client上完成&lt;/li&gt;
&lt;li&gt;local模式下tiggermonitor触发的raid， raid过程是在RaidNode上完成&lt;/li&gt;
&lt;li&gt;raidshell执行的dist模式且是目录时进行的raid，或者dist模式下triggermonitor触发的raid，是通过job的方式提交到集群上由每个task节点完成。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;RaidNode.doRaid()的主要流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/Raid-RaidNodeDoRaid.png&quot; alt=&quot;RaidNodeDoRaid&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;获取文件的block信息，如果block数小于3，则不进行raid。&lt;/li&gt;
&lt;li&gt;对于为打到delay时间的也不进行raid&lt;/li&gt;
&lt;li&gt;如果已经到达delay时间且block数&gt;2 时进行生成parity文件&lt;/li&gt;
&lt;li&gt;生成parity文件过程如图右半部所示：首先获取src文件path，生成parity文件的path，parity文件path的生成规则是 $parity_dir+src_path（codec中配置的是parity_dir是/raid， src文件path是data/file1.log， 那么该文件的parity文件path就是/raid/data/file1.log）&lt;/li&gt;
&lt;li&gt;检查相应的parity文件是否已经存在，如果存在，检查parity文件的mtime（更新时间）是否与源文件mtime一致，如果是，则认为该源文件已经raid且是最新。不需要再进行raid。&lt;/li&gt;
&lt;li&gt;如果parity文件不存在或不是最新，则重新通过Encoder来生成parity文件&lt;/li&gt;
&lt;li&gt;设置parity文件的mtime为源文件的mtime。&lt;/li&gt;
&lt;li&gt;检查parity文件的最终状态，主要是mtime是否与源文件一致。通过则raid完成&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;3.1.3 Encoder.encode过程&lt;/h4&gt;

&lt;p&gt;raid过程中最终的编码生成parity的工作有Encoder完成。编码过程主要如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/Raid-EncodeFile.png&quot; alt=&quot;EncodeFile&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;由于编码过程会比较长，所以先生成™p文件。™p文件的目录可以通过™p_parity_dir配置，默认是™p/$parity_dir&lt;/li&gt;
&lt;li&gt;构建™p文件path，™p文件的path为™p目录下parity文件path加上一个随机long值构成，$™p_parity_dir/$parity_file+randomlong。&lt;/li&gt;
&lt;li&gt;通过Erasued Code来进行编码到™p文件&lt;/li&gt;
&lt;li&gt;删除原有的parity文件&lt;/li&gt;
&lt;li&gt;将™p文件重命名为parity文件。&lt;/li&gt;
&lt;li&gt;删除™p文件。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;对于Erasured Code的生成过程大至流程如下：
从源文件中block列表中选取一些（数量有stripe_length指定，默认是10）block，构成一个strip（条？）。通过ParallelStreamReader工具构建一个并行读取10个block的的数据，每个block每次读取1个buff的数据(buffer大小有raid.encoder.bufsize指定，默认是1m)，一次读取构成一个二维byte数组byte[stripe_length][buff_size],这个二维数组做为Erasure Code的输入数据，进行编码生成erasued code。输出也是一个byte二维数组byte[parity_length][buffer_size]。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;XOR算法中&lt;/strong&gt;:parity_length为1， 即根据10位输入byte生成1位的奇偶校验码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RS算法中&lt;/strong&gt;: parity_length默认为4， 及根据10为输入生成4为的RS code，这四位分别写入4个™p文件中，在一个buffer全部编码完成后，将4个parity文件进行合并。生成一个™p文件。&lt;/p&gt;

&lt;h3&gt;3.2 损坏数据的恢复&lt;/h3&gt;

&lt;p&gt;raid数据的修复同样也有多个触发场景：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;client端使用DRFS读取数据发生数据丢失或损坏延长&lt;/li&gt;
&lt;li&gt;RaidNode上BlockIntegrityMonitor周期获取block数据发现数据异常时&lt;/li&gt;
&lt;li&gt;通过raidshell执行 fixblock时&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;3.2.1 block读取时修复损坏数据流程&lt;/h4&gt;

&lt;p&gt;在client通过DRFS读取raid话的数据是，DRFS首先通过其内部封装的DFS去读block数据，当DFS读取时跑出CorruptionException或DecomissionException时，会被DRFS捕获，并对出错的block在client进行修复。主要流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在client配置了DRFS并使用DFS作为内置fs时，当通过FS.open获取文件InputStream时，返回一个ExtFSDataInputStream实例。&lt;/li&gt;
&lt;li&gt;通过该inputStream读取数据时，首先通过内置DFS读取响应的block，正常情况下，返回需要的数据。&lt;/li&gt;
&lt;li&gt;当内置的DFS读取block时跑出CorruptionException或DecomissionException时，会被ExtFSDataInputStream捕获。通过调用RaidNode.unRaidCorrputionBlock()来获取一个恢复的block，并从该block读取数据。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;RaidNode.unRaidCorruptionBlock()过程首先获取该block的parity文件信息，然后构建一个恢复文件的path路径(该路径位于hdfs.raid.local.recovery.location配置的目录下，默认是/tmp/raidrecovery，文件名为原文件名+&quot;.&quot;+随机long+&quot;.recoveryd&quot;)，并通过Decoder.fixErasedBlock()来根据parity文件生成恢复文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;对于恢复文件所在的文件系统是可以通过fs.raid.recoveryfs.uselocal来配置的，默认是false，即使用DFS，恢复文件将在储与分布式系统中，当配置成true是，使用LocalFileSystem，将恢复文件存储在client端本地。&lt;/p&gt;

&lt;h4&gt;3.2.2 BlockIntegrityMonitor线程修复&lt;/h4&gt;

&lt;p&gt;RaidNode上的BlockIntegrityMonitor线程会通过DFSck工具检查系统中corrupt或decomission的数据，通过BlockCopier和BlockFixer线程周期行对出错的数据进行修复。local模式下，修复过程在RaidNode上之行，Dist模式下修复过程通过提交Job的方式提交给集群完成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Local模式&lt;/strong&gt;
LocalBlockIntegrity线程的核心是周期调用doFix方法修复corrupt文件，主要流程如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过DFSck获取currput文件信息（HTTP访问）&lt;/li&gt;
&lt;li&gt;过滤掉不能恢复的corrupt文件（没有parity文件的）&lt;/li&gt;
&lt;li&gt;将corrput的文件排序，排序规则如下

&lt;ul&gt;
&lt;li&gt;parity文件优先，source文件在后&lt;/li&gt;
&lt;li&gt;parity文件中codec.priority高的在先（codec.priority通过JSON中coder_priority配置）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对排序号的corrupt文件列表依次通过BlockRecontsturer来恢复。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;Dist模式&lt;/strong&gt;
DistBlockIntegrity中的有两个worker线程blockCopier和blockFixer，分别对应修复decomssion和corrput的文件。实际上两个线程的处理流程基本一致，大体如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;检查当前正在运行的修复job数，如果当前job已经大于job上限，则等待之前的job运行完（该上线可以通过raid.blockfix.maxpendingjobs来配置，默认是100L）&lt;/li&gt;
&lt;li&gt;通过DFSck获取损坏的文件信息，blockfixer线程获取corrupt文件信息，blockCopier获取decomission文件信息&lt;/li&gt;
&lt;li&gt;&lt;p&gt;计算获得的损坏文件的优先级：&lt;/p&gt;

&lt;p&gt; corrput文件的优先级如下(R为文件副本数，C为该文件corrput的block数)：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;默认为LOW&lt;/li&gt;
&lt;li&gt;R&gt;1 &amp;amp;&amp;amp; C&gt;0时： HIGH&lt;/li&gt;
&lt;li&gt;R==1 &amp;amp;&amp;amp; C&gt;1时： HIGH&lt;/li&gt;
&lt;li&gt;parityfile corrput &amp;amp;&amp;amp; C&gt;0时： HIGH&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; decomission优先级计算规则如下（D为decomission的block数):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;默认为LOW&lt;/li&gt;
&lt;li&gt;D&gt;4时： HIGH&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将计算好优先级的文件列表按优先级排序，作为参数构建修复Job。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Job的输入是所有需要修复的文件path的sequence file。会根据raid.blockfix.filespertask配置的值进行sync，即在job的split阶段会按照该值设置的进行split，默认是20&lt;/li&gt;
&lt;li&gt;Job的Mapper主要是通过Reconstruter在task机上完成响应文件的恢复。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;对于修复Job还有一个参数限制，及每次job最多进行的task数，该值为固定值50，这意味着一个Job一次最多能修复的文件数是100个（raid.blockfix.filespertask*50）&lt;/p&gt;

&lt;h4&gt;3.2.3 RaidShell之行fixblock&lt;/h4&gt;

&lt;p&gt;通过raidshell执行 fixblock时, raidShell会通过BlockReconstructor来完成文件的修复。&lt;/p&gt;

&lt;h4&gt;3.2.4 BlockReconstructor文件修复过程&lt;/h4&gt;

&lt;p&gt;BlockIntegrityMonitor和RaidShell对文件的修复最终都通过BlockReconstructor来完成。
BlockReconstructor修复文件过程主要分为三类：Har parity文件，parity文件和源数据文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Har parity文件&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;获取har文件的基本信息及index&lt;/li&gt;
&lt;li&gt;获取har文件中的lost block，对每个block进行如下处理：&lt;/li&gt;
&lt;li&gt;在本地文件系统创建该block的临时文件，&lt;/li&gt;
&lt;li&gt;对该block涉及的所有parity文件，获取对应的source文件，通过Encoder重新encode，在本地生成parity数。&lt;/li&gt;
&lt;li&gt;将本地生成的block数据发送到一个datanode上，datanode的选取规则是从集群中除原block所属节点外随机选取一个。发送过程同时生成block的meta文件。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;parity文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;parity文件的修复处理相对简单：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在本次创建lost block的临时文件&lt;/li&gt;
&lt;li&gt;获取parity文件的源文件，通过Encoder重新encode，在本地生成parity文件的block&lt;/li&gt;
&lt;li&gt;选取一个dn（选取规则和har parity文件修复一致），将block数据发送到该dn上，并同时生成meta文件&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;源数据文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;源文件的恢复与parity文件的修复相反，是一个decode过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对于file中丢失的每个block执行修复操作&lt;/li&gt;
&lt;li&gt;在本地创建block的临时文件&lt;/li&gt;
&lt;li&gt;通过Decoder恢复block数据&lt;/li&gt;
&lt;li&gt;选取一个target dn，将block数据发送给target dn，并同时生成meta文件。&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;3.2.5 Decoder的修复过程&lt;/h4&gt;

&lt;p&gt;Decoder的修复过程即一个parity文件的decode过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/Raid-decode.png&quot; alt=&quot;Decode&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;根据文件中出错的位置，计算出错的block，该block所在的stripe，以及在stripe中的位置，计算parity文件相应block的位置。&lt;/li&gt;
&lt;li&gt;通过ParallelStreamReader读取源block数据和parity数据，读取方式与编码时类似&lt;/li&gt;
&lt;li&gt;通过Erasured Code将源block和parity数据的进行解码，生成丢失的block数据。&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;四、参考资料&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://hadoopblog.blogspot.com/2009/08/hdfs-and-erasure-codes-hdfs-raid.html&quot;&gt;HDFS and Erasure Codes (HDFS-RAID)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wiki.apache.org/hadoop/HDFS-RAID&quot;&gt;HDFS-RAID wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Erasure_code&quot;&gt;Erasure Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/hadoop-20/tree/production/src/contrib/raid&quot;&gt;Facebook hadoop-20&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>HDFS-2246:使用BlockReaderLocal优化本地block读取</title>
   <link href="http://jiang-bo.github.com/blog/2012/12/10/hdfs-blockreaderlocal"/>
   <updated>2012-12-10T16:09:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/12/10/hdfs-blockreaderlocal</id>
   <content type="html">&lt;h2&gt;一、背景&lt;/h2&gt;

&lt;p&gt;HDFS中对Block的读取使用DataXceiver通过Socket发送Packet数据进行，client端通过一个BlockReader来接收Socket中的Block数据。详见&lt;a href=&quot;&quot;&gt;HDFS数据读取流程&lt;/a&gt;。大致流程如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;client端调用FileSystem.open()获取一个DFSInputStream&lt;/li&gt;
&lt;li&gt;client端调用DFSInputStream.read(byte[] buffer, int off, int len)读取数据&lt;/li&gt;
&lt;li&gt;client端通过DFSInputStream.blockSeekTo()向NameNode发起请求，定位到需要读取的block所在的Datanode，构建一个BlockReader用于读去对应DataNode上的block数据，返回该DataNodeInfo&lt;/li&gt;
&lt;li&gt;BlockReader主要负责同DataNode间建立一个Socket链接用于读取数据，BlockReader首先向DataNode发送请求头（包括操作类型，blockId，block时间戳，起始偏移量，读取数据的长度，client名）&lt;/li&gt;
&lt;li&gt;DataNode接收到DataXceiverServer接收到client端请求后，构建一个DataXceiver处理该请求。&lt;/li&gt;
&lt;li&gt;DataXceiver首先解析请求头，获取请求操作类型，当发现是READ_BLOCK操作后，调用相应的readBlock()方法处理&lt;/li&gt;
&lt;li&gt;readBlock方法解析请求中需要的blockId，构建一个BlockSender用于读取磁盘上的block文件数据并发送给client&lt;/li&gt;
&lt;li&gt;BlockSender读取磁盘上的block文件，将数据按照chunk通过socket发送给client的blockReader，同时，BlockSender在发送chunk后需要从meta文件中读取该chunk的checksum数据，同样发送给client，用于该chunk的checksum校验。&lt;/li&gt;
&lt;li&gt;client端通过BlockReader.readChunks()接收BlockSender发送的chunk数据，并进行checksum校验，校验成功后向DataNode发送checksumOk。&lt;/li&gt;
&lt;li&gt;循环6-10，直至当前block的数据全部被读取完成。&lt;/li&gt;
&lt;li&gt;循环执行3-11, 直至需要读取的文件数据都被读取完。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;这个过程是在集群环境想，client读取datanode上数据的一个正常流程，但事实上当client和datanode位于同一个物理节点上时（如Hadoop集群中，task运行在datanode上），这个过程显的有些多余，client可以直接通过本地文件系统api读取文件，而不需要走繁杂的socket流程。&lt;/p&gt;

&lt;h2&gt;二、设计实现&lt;/h2&gt;

&lt;p&gt;HDFS-2246中提供了一个BlockReaderLocal的实现，当client发现从NameNode返回的Block所属的datanode和client位于同一节点上时，构建一个BlockReaderLocal用于读取本地文件。
上述3-10的流程将简化为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;client端向NameNode发起请求获取block所属的datanode信息后，判断该datanode是否和client位于同一节点，是且开启了本地读取功能，则构建一个BlockReaderLocal读取本地文件，否则构建一个BlockReader按照原流程进行。&lt;/li&gt;
&lt;li&gt;BlockReaderLocal通过DataNode.getBlockLocaPathInfo()从DataNode获取block的本地文件路径信息。&lt;/li&gt;
&lt;li&gt;BlockReaderLocal构建InputStream读取block文件和meta文件信息&lt;/li&gt;
&lt;li&gt;对于需要checksum的场景（默认），通过blockReaderLocal.readChunks()按chunk读取本地文件，同时读取meta文件中该chunk的checksum数据，进行校验&lt;/li&gt;
&lt;li&gt;对于跳过checksum的场景，直接通过InputStream.read()读取block数据。&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;扩展DataNode协议接口&lt;/h3&gt;

&lt;p&gt;client端需要能够从DataNode获取block文件的本地文件路径信息。因此扩展ClientDataNodeProtocol，增加一个&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BlockLocalPathInfo getBlockLocalPathInfo(Block block) throws IOException;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接口用于获取block的本地路径信息&lt;/p&gt;

&lt;h3&gt;本地文件读取&lt;/h3&gt;

&lt;p&gt;BlockReaderLocal共过BufferedInputStream直接读取本地文件，注意此处HDFS-2246的patch中使用的是FileInputStream，实际测试过程中发现，FileInputStream对本地文件的读取性能较差， 替换为使用BufferedInputStream&lt;/p&gt;

&lt;h3&gt;checksum较验&lt;/h3&gt;

&lt;p&gt;为了完成checksum校验，BlockReaderLocal同时需要读取block的meta文件，每当block文件读取一个chunk时需要从meta文件读取一个checksum数据，进行checksum校验，通过校验后进行下一个chunk的读取和校验。由于BlockReaderLocal读取的是本地文件，避免的网络传输对数据的影响，因此可以配置跳过checksum检查，以提高读取性能。默认是需要做checksum的。&lt;/p&gt;

&lt;h3&gt;本机判断&lt;/h3&gt;

&lt;p&gt;当前patch中的实现主要用IP来判断是否block所在的datanode与client是否位于同一节点上。&lt;/p&gt;

&lt;h2&gt;测试&lt;/h2&gt;

&lt;p&gt;通过TestDFSIO工具测试一个单节点的集群，2个文件，每个文件1000M
./bin/hadoop jar hadoop-0.19.1-dc-test.jar TestDFSIO -read -nrFiles 2 -fileSize 1000
测试结果对比:
socket读取：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
12/12/07 13:52:57 INFO mapred.FileInputFormat: ----- TestDFSIO ----- : read
12/12/07 13:52:57 INFO mapred.FileInputFormat:            Date &amp;amp; time: Fri Dec 07 13:52:57 CST 2012
12/12/07 13:52:57 INFO mapred.FileInputFormat:        Number of files: 2
12/12/07 13:52:57 INFO mapred.FileInputFormat: Total MBytes processed: 2000
12/12/07 13:52:57 INFO mapred.FileInputFormat:      Throughput mb/sec: 283.5270768358378
12/12/07 13:52:57 INFO mapred.FileInputFormat: Average IO rate mb/sec: 283.5281982421875
12/12/07 13:52:57 INFO mapred.FileInputFormat:  IO rate std deviation: 0.5685961122141402
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本地读取&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
12/12/07 13:48:59 INFO mapred.FileInputFormat: ----- TestDFSIO ----- : read
12/12/07 13:48:59 INFO mapred.FileInputFormat:            Date &amp;amp; time: Fri Dec 07 13:48:59 CST 2012
12/12/07 13:48:59 INFO mapred.FileInputFormat:        Number of files: 2
12/12/07 13:48:59 INFO mapred.FileInputFormat: Total MBytes processed: 2000
12/12/07 13:48:59 INFO mapred.FileInputFormat:      Throughput mb/sec: 369.61744594344856
12/12/07 13:48:59 INFO mapred.FileInputFormat: Average IO rate mb/sec: 369.6180725097656
12/12/07 13:48:59 INFO mapred.FileInputFormat:  IO rate std deviation: 0.4800772
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外通过Patch中提供的TestShortCircuitLocalRead工具，测试结果如下：&lt;/p&gt;

&lt;p&gt;本地读取并进行checksum校验&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;true no 1 32000000
---
Iteration 20 took 115453
Iteration 20 took 115803
Iteration 20 took 115748
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;socket读取并进行checksum校验（默认）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;no no 1 32000000
---
Iteration 20 took 128820
Iteration 20 took 135305
Iteration 20 took 129145
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>使用FUSE-DFS mount HDFS</title>
   <link href="http://jiang-bo.github.com/blog/2012/10/23/mount-hdfs-with-fuse-dfs"/>
   <updated>2012-10-23T10:24:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/10/23/mount-hdfs-with-fuse-dfs</id>
   <content type="html">&lt;h2&gt;介绍&lt;/h2&gt;

&lt;p&gt;Hadooop源码中自带了contrib/fuse-dfs模块，用于实现通过libhdfs和fuse将HDFS mount到*inux的本地。&lt;/p&gt;

&lt;h2&gt;编译&lt;/h2&gt;

&lt;h3&gt;环境&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Linux: 2.6.18-164.el5 x86_64&lt;/li&gt;
&lt;li&gt;JDK: 1.6.0_23 64bit&lt;/li&gt;
&lt;li&gt;Hadoop: 0.19.1 下面假设源码目录为$HADOOP_SRC_HOME&lt;/li&gt;
&lt;li&gt;Ant: 1.8.4&lt;/li&gt;
&lt;li&gt;GCC: 4.1.2(系统默认)&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;编译libhdfs&lt;/h3&gt;

&lt;h4&gt;修改configure执行权限&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$chmod +x $HADOOP_SRC_HOME/src/c++/pipes/configure
$chmod +x $HADOOP_SRC_HOME/src/c++/utils/configure
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;修改Makefile，调整编译模式&lt;/h4&gt;

&lt;p&gt;64位机中，需要修改libhdfs的Makefile，将GCC编译的输出模式由32(-m32)位改为64(-m64)位&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CC = gcc
LD = gcc
CFLAGS =  -g -Wall -O2 -fPIC
LDFLAGS = -L$(JAVA_HOME)/jre/lib/$(OS_ARCH)/server -ljvm -shared -m64(这里) -Wl,-x
PLATFORM = $(shell echo $$OS_NAME | tr [A-Z] [a-z])
CPPFLAGS = -m64(还有这里) -I$(JAVA_HOME)/include -I$(JAVA_HOME)/include/$(PLATFORM)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;编译&lt;/h4&gt;

&lt;p&gt;在$HADOOP_HOME目录下执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ant compile -Dcompile.c++=true -Dlibhdfs=true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译结果将生成libhdfs库，位于$HADOOP_SRC_HOME/build/libhdfs目录下&lt;/p&gt;

&lt;h3&gt;编译fuse-dfs&lt;/h3&gt;

&lt;h4&gt;安装fuse库&lt;/h4&gt;

&lt;p&gt;fuse-dfs依赖fuse库，可通过&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lsmod|grep fuse
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;检查是否已经安装，如没有，可通过：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum -y install fuse fuse-devel fuse-libs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装相关依赖库。&lt;/p&gt;

&lt;h4&gt;设置编译库路径&lt;/h4&gt;

&lt;p&gt;设置编译库路径，将libhdfs的库加入到编译路径中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export LD_LIBRARY_PATH=/usr/lib:/usr/local/lib:$HADOOP_SRC_HOME/build/c++/Linux-amd64-64/lib:$JAVA_HOME/jre/lib/amd64/server
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;编译&lt;/h4&gt;

&lt;p&gt;编译contrib/fuse-dfs模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ant compile-contrib -Dlibhdfs=1 -Dfusedfs=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译完成将会生成$HADOOP_HOME/build/contrib/fuse-dfs/目录，内有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fuse-dfs]$ ls
fuse_dfs  fuse_dfs_wrapper.sh  test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中fuse_dfs是可执行程序，fuse_dfs_wrapper.sh是包含一些环境变量设置的脚本，不过其中大部分需要修改:(&lt;/p&gt;

&lt;h4&gt;修改fuse_dfs_warpper.sh&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#Hadoop安装目录
export HADOOP_HOME=/home/bo.jiangb/yunti-trunk/build/hadoop-0.19.1-dc
#将fuse_dfs加入到PATH
export PATH=$HADOOP_HOME/contrib/fuse_dfs:$PATH
#将hadoop的jar加入到CLASSPATH
for f in ls $HADOOP_HOME/lib/*.jar $HADOOP_HOME/*.jar ; do
export  CLASSPATH=$CLASSPATH:$f
done
#设置机器模式
export OS_ARCH=amd64
#设置JAVA_HOME
export  JAVA_HOME=/home/admin/tools/jdk1.6
#将libhdfs加入到链接库路径中
export LD_LIBRARY_PATH=$JAVA_HOME/jre/lib/$OS_ARCH/server:/home/bo.jiangb/yunti-trunk/build/libhdfs:/usr/local/lib
./fuse_dfs $@
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;使用&lt;/h2&gt;

&lt;h3&gt;mount&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;新建一个空目录&lt;/p&gt;

&lt;p&gt; $mkdir /tmp/dfs&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;挂载dfs
$./fuse_dfs_wrapper.sh dfs://master_node(namenode地址):port /tmp/dfs -d
-d表示debug模式，如果正常，可以将-d参数去掉。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;unmount&lt;/h3&gt;

&lt;p&gt;卸载可通过：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fusermount -u /tmp/dfs
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>HDFS源码学习（15）——DataXceiverServer</title>
   <link href="http://jiang-bo.github.com/blog/2012/10/18/hdfs-dataxceiver"/>
   <updated>2012-10-18T22:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/10/18/hdfs-dataxceiver</id>
   <content type="html">&lt;p&gt;HDFS中有两种类型的通信机制，一种是进行消息传递的Hadoop IPC机制，一种是用于处理数据传输的DataXceiver机制。前者包括client&amp;lt;-&gt;namenode之间的通信，以及datanode&amp;lt;-&gt;namenode间通信，后者包括client&amp;lt;-&gt;datanode, datanode&amp;lt;-&gt;datanode间的数据传输。&lt;/p&gt;

&lt;h2&gt;DataXceiverServer&lt;/h2&gt;

&lt;p&gt;DataNode在启动时会通过DataXceiverServer开启一个Socket端口，负责block数据的读写。DataXceiverServer本身作为一个守护线程，监听dfs.datanode.address配置的数据读写服务端口。当有请求来时，新建一个DataXceiver线程处理请求。&lt;/p&gt;

&lt;h2&gt;DataXceiver&lt;/h2&gt;

&lt;p&gt;DataXceiver线程用于处理一个读/写数据流请求，其run方法入下主要是根据请求中不同的请求类型，调用响应的处理方法。&lt;/p&gt;

&lt;p&gt;请求操作类型定义在DataTransferProtocol中，主要有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;OP_WRITE_BLOCK： 写入Block数据，对应writeBlock()方法&lt;/li&gt;
&lt;li&gt;OP_READ_BLOCK： 读取Block数据，对应readBlock()方法&lt;/li&gt;
&lt;li&gt;OP_READ_METADATA： 读取Block元数据，对应readMetadata()方法&lt;/li&gt;
&lt;li&gt;OP_REPLACE_BLOCK： 替换Block，将block发送到目标datanode上，用于IO负载均衡；对应replaceBlock()方法。&lt;/li&gt;
&lt;li&gt;OP_COPY_BLOCK：复制Block，将block发送到proxy source上，用于IO负载均衡；对应copyBlock()方法。&lt;/li&gt;
&lt;li&gt;OP_BLOCK_CHECKSUM：获取Block的checksum；对应getBlockChecksum()方法。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;请处理返回的状态也定义在该类中：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;OP_STATUS_SUCCESS： 成功&lt;/li&gt;
&lt;li&gt;OP_STATUS_ERROR： 请求出错&lt;/li&gt;
&lt;li&gt;OP_STATUS_ERROR_CHECKSUM： checksum校验出错&lt;/li&gt;
&lt;li&gt;OP_STATUS_ERROR_INVALID： 读取无效block&lt;/li&gt;
&lt;li&gt;OP_STATUS_ERROR_EXISTS：block不存在&lt;/li&gt;
&lt;li&gt;OP_STATUS_CHECKSUM_OK： checksum校验正常&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;1.读取block——readBlock()&lt;/h3&gt;

&lt;p&gt;OP_READ_BLOCK的请求数据格式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/ReadBlock.png&quot; alt=&quot;READ_BLOCK&quot; /&gt;&lt;/p&gt;

&lt;p&gt;返回数据格式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/ReadResponse.png&quot; alt=&quot;READ_Response&quot; /&gt;&lt;/p&gt;

&lt;p&gt;readBlock()主要从disk读取block数据，构建一个DataOutputStream数据流，并新建一个BlockSender将这个数据流发送出去（datanode或者client）。&lt;/p&gt;

&lt;p&gt;BlockSender.sendBlock()发送的Block的流程大体如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;读取block的meta信息，获得checksum并发送&lt;/li&gt;
&lt;li&gt;发送数据读取的偏移量&lt;/li&gt;
&lt;li&gt;将block数据切分为packet，发送给client&lt;/li&gt;
&lt;li&gt;所有packet发送完之后，关闭checksum文件和block文件&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;2.写入block——writeBlock()&lt;/h3&gt;

&lt;p&gt;OP_WRITE_BLOCK的请求数据格式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/WriteRequest.png&quot; alt=&quot;WRITE_BLOCK&quot; /&gt;&lt;/p&gt;

&lt;p&gt;writeBlock()解析请求信息，构建一个BlockReceiver处理数据接收和写入，在client（或上一datanode节点）-当前datanode节点-下一datanode节点之间建立一个如下连接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/WriteBlock.png&quot; alt=&quot;WRITE_BLOCK&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;BlockReceiver从上按packet一节点读取数据，写入到本地disk&lt;/li&gt;
&lt;li&gt;如有下一备份节点，将该packet转发给下一节点&lt;/li&gt;
&lt;li&gt;将该packet加入到ackqueue队列中等待ack消息&lt;/li&gt;
&lt;li&gt;当下一节点完成该packet写入后会返回该packet对应的ack信息&lt;/li&gt;
&lt;li&gt;PakcetResponder接收到ack信息后，将ackqueue中该packet删除，并向前置节点发送ack信息&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>HDFS源码学习（14）——Client代码结构</title>
   <link href="http://jiang-bo.github.com/blog/2012/10/18/hdfs-client-code"/>
   <updated>2012-10-18T21:59:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/10/18/hdfs-client-code</id>
   <content type="html">&lt;p&gt;Client核心代码有DistributedFileSystem和DFSClient。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/Client.png&quot; alt=&quot;Client&quot; /&gt;&lt;/p&gt;

&lt;p&gt;DistributedFileSystem扩展子FileSystem，在为客户端提供一个文件系统接口实现。其内部使用DFSClient完成各类文件操作。&lt;/p&gt;

&lt;p&gt;DFSClient使用ClientProtocol与NameNode通信，完成文件元信息操作。并通过Socket连接完成与DataNode间的block读写操作。&lt;/p&gt;

&lt;p&gt;DFSClient代码结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/DFSClient.png&quot; alt=&quot;DFSClient&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;LeaseChecker主要用于lease检查和续约。&lt;/li&gt;
&lt;li&gt;DFSOutputStream用于提供带buffer的字节流写入功能。client在写入数据时先将数据缓存在本地。并将数据切分成多个packet（默认每个packet为64K）。每个packet又被拆分成多个chunk（默认512Byte），每个chunk都有一个checksum。client写满一个packet后会将该packet加入到一个dataqueue中。由DataStreamer线程负责将每个packet发送给datanode pipeline。发送完一个pakcet，streamer会将其从dataqueue移至ackqueue中。ResponseProcessor负责接收datanode发回的ack信息，每成功接收一个packet的ack信息，ResponseProcessor会将ackqueue中该packet删除。&lt;/li&gt;
&lt;li&gt;DFSInputStream用于提供字节流的读取，其内部封装了与NN和DN的交互&lt;/li&gt;
&lt;li&gt;DataStreamer: 负责向datanode pipeline发送packet。其本身是一个Daemon线程，从namenode获取blockId和block存放位置，将packet发送给pipeline中的datanode，每个packet都有一个seqId，每个packet发送完时都会收到datanode的ack信息。当收到所有packet的ack信息后（表示该block已发送完），streamer关闭该block。&lt;/li&gt;
&lt;li&gt;ResponseProcessor:用于接收datanode返回ack信息，并将响应ackqueue中的packet删除&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;创建文件&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;client向NameNode发起创建文件请求&lt;/li&gt;
&lt;li&gt;NameNode.create（）处理创建文件请求，检查是否有重名，当前是否处于Safe-mode，是否有权限创建文件， 校验通过后创建一个INode记录。&lt;/li&gt;
&lt;li&gt;NameNode将创建文件的事件记录到EditLog中&lt;/li&gt;
&lt;li&gt;INode被创建后，NameNode发放给Client一个lease，Client可以使用这个lease通过ClientProtocol访问，进行只读操作。（写操作需要等文件close）&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;写入流程&lt;/h2&gt;

&lt;p&gt;client写入流程如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/ClientWrite.png&quot; alt=&quot;ClientWrite&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Client向NameNode发起创建文件的RPC请求&lt;/li&gt;
&lt;li&gt;NameNode检查文件是否已经存在，是否有权创建等，成功则创建一个文件记录，并发放给Client一个lease&lt;/li&gt;
&lt;li&gt;Client获得lease之后开始进行数据写入，写入的数据首先被缓存本地，并被拆分为多个packet，放置到dataqueue队列中&lt;/li&gt;
&lt;li&gt;DataStreamer线程负责检查dataqueue队列，发现有数据时且没有可用block时，向NameNode发送addBlock()请求，申请一个分配一个block空间。NameNode返回给DataStreamer一个blockId和用于存放block的datanode list&lt;/li&gt;
&lt;li&gt;DataStreamer将每个packet数据发送给datanode pipeline，并将该packet移至ackqueue&lt;/li&gt;
&lt;li&gt;datanode pipeline中第一个datanode收到packet之后存储到本地block中并穿行备份至后续datanode中&lt;/li&gt;
&lt;li&gt;pipeline中datanode存储好packet之后会逆序返回ack信息，并最终返回给client.&lt;/li&gt;
&lt;li&gt;Client端ResponseProcessor捕获到每个packet的ack信息时会将响应ackqueue中的packet删除&lt;/li&gt;
&lt;li&gt;当所有数据都写入完成后，client会向NameNode发起一个complete RPC请求，告知文件最新的时间戳和已经发送给datanode的block长度。NameNode检查所有block的副本信息，只有所有block的副本数均满足最低要求时，complete会返回成功。&lt;/li&gt;
&lt;li&gt;最后，NameNode将收回client持有的lease。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;NameNode处理addBlock()请求的流程大致如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;校验client是否有该文件的lease&lt;/li&gt;
&lt;li&gt;清理上一次写入记录，包括：a.提交上一次写入，b.更新lease有效期；c.将完成的写入记录到EditLog中&lt;/li&gt;
&lt;li&gt;清理完毕之后，使用BlockManager分配指定副本数个block及其对应的datanode信息，返回给client&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;DataNode处理block写入的流程大致如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将block复制到本地磁盘&lt;/li&gt;
&lt;li&gt;发送block received消息给NameNode告知写入了一个新的block&lt;/li&gt;
&lt;li&gt;将block数据发送给datanode pipeline中下一个datanode，进行备份&lt;/li&gt;
&lt;li&gt;返回一个ack消息给前一个调用者&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;后续的datanode收到上一个datanode的备份block请求是做类似的操作。&lt;/p&gt;

&lt;h2&gt;读取流程&lt;/h2&gt;

&lt;p&gt;读取流程相对简单写，如下所示 ：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/ClientRead.png&quot; alt=&quot;ClientWrite&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;client向NameNode发起RPC请求，获取文件的blockLocation信息&lt;/li&gt;
&lt;li&gt;NameNode返回一定长度（10*defaultBlockSize）block的datanode位置信息&lt;/li&gt;
&lt;li&gt;Client根据返回的blockLocation信息选取距自己最近（同一节点&amp;lt;通一机架&amp;lt;同一机房）的datanode读取数据，读完一个block会对该block进行checksum校验。如果校验正确则关闭与该datanode连接，去读下一个block；如果校验失败，则通知NameNode该block在当前datanode上的副本损坏了，并继续从datanode列表中获取一个datanode，重新读取该block。&lt;/li&gt;
&lt;li&gt;当本次获取的blockLocation中的block全部读完，且该文件还有block时，重复1，2，3过程，直至所有blcok全部读完。&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;关闭文件（complete）&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;当Client完成文件写入之后，会调用complete()通知NameNode文件写入完成了，该请求会提交文件写入的最后一个block信息并且告知NameNode写入的block总数以及最新时间戳。&lt;/li&gt;
&lt;li&gt;NameNode收到请求后会检查是否所有的block的事物都已经提交了，并且每个block的副本数都达到了最小值。如果是则返回true，否则返回false。&lt;/li&gt;
&lt;li&gt;Client收到返回值后如果失败则重试几次。&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>HDFS源码学习（13）——DataNode启动过程</title>
   <link href="http://jiang-bo.github.com/blog/2012/10/18/hdfs-datanode-startup"/>
   <updated>2012-10-18T21:57:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/10/18/hdfs-datanode-startup</id>
   <content type="html">&lt;h2&gt;main()&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;  public static void main(String args[]) {
    try {
      StringUtils.startupShutdownMessage(DataNode.class, args, LOG);
      DataNode datanode = createDataNode(args, null);
      if (datanode != null)
        datanode.join();
    } catch (Throwable e) {
      LOG.error(StringUtils.stringifyException(e));
      System.exit(-1);
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;createDataNode()&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;  public static DataNode createDataNode(String args[],
                                 Configuration conf) throws IOException {
    // 初始化datanode
    DataNode dn = instantiateDataNode(args, conf);
    // 启动datanode后台线程
    runDatanodeDaemon(dn);
    return dn;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.instantiateDataNode（）&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;  public static DataNode instantiateDataNode(String args[],
                                      Configuration conf) throws IOException {
    // 处理配置
    if (conf == null)
      conf = new Configuration();
    if (!parseArguments(args, conf)) {
      printUsage();
      return null;
    }
    if (conf.get(&quot;dfs.network.script&quot;) != null) {
      LOG.error(&quot;This configuration for rack identification is not supported&quot; +
          &quot; anymore. RackID resolution is handled by the NameNode.&quot;);
      System.exit(-1);
    }
    // 获取data目录配置
    String[] dataDirs = conf.getStrings(&quot;dfs.data.dir&quot;);
    dnThreadName = &quot;DataNode: [&quot; +
                        StringUtils.arrayToString(dataDirs) + &quot;]&quot;;
    //创建datanode实例
    return makeInstance(dataDirs, conf);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;1.1. makeInfstance()&lt;/h4&gt;

&lt;p&gt;该方法主要用于检查给定的data目录中至少有一个可以创建，并实例化DataNode&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public static DataNode makeInstance(String[] dataDirs, Configuration conf)
    throws IOException {
    ArrayList&amp;lt;File&amp;gt; dirs = new ArrayList&amp;lt;File&amp;gt;();
    for (int i = 0; i &amp;lt; dataDirs.length; i++) {
      File data = new File(dataDirs[i]);
      try {
        DiskChecker.checkDir(data);
        dirs.add(data);
      } catch(DiskErrorException e) {
        LOG.warn(&quot;Invalid directory in dfs.data.dir: &quot; + e.getMessage());
      }
    }
    if (dirs.size() &amp;gt; 0) 
      return new DataNode(conf, dirs);
    LOG.error(&quot;All directories in dfs.data.dir are invalid.&quot;);
    return null;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;1.2 new DataNode()&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  DataNode(Configuration conf, 
           AbstractList&amp;lt;File&amp;gt; dataDirs) throws IOException {
    // 设置配置信息
    super(conf);
    datanodeObject = this;
    supportAppends = conf.getBoolean(&quot;dfs.support.append&quot;, false);
    this.conf = conf;
    try {
      // 启动DataNode
      startDataNode(conf, dataDirs);
    } catch (IOException ie) {
      shutdown();
      throw ie;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;1.2.1 startDataNode()&lt;/h5&gt;

&lt;p&gt;代码较长，仅列出主要步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;设置配置信息&lt;/li&gt;
&lt;li&gt;向NameNode发起RPC请求，获取版本和StorageID信息&lt;/li&gt;
&lt;li&gt;获取启动配置&lt;/li&gt;
&lt;li&gt;初始化存储信息，构建FSDataSet&lt;/li&gt;
&lt;li&gt;获取可用的端口号&lt;/li&gt;
&lt;li&gt;调整注册信息中的机器名，加上端口号&lt;/li&gt;
&lt;li&gt;初始化DataXceiverServer&lt;/li&gt;
&lt;li&gt;设置blockReport和heartbeat各自的时间间隔&lt;/li&gt;
&lt;li&gt;初始化blockScanner&lt;/li&gt;
&lt;li&gt;初始胡并启动servlet info server，提供内容查询的http服务&lt;/li&gt;
&lt;li&gt;初始化ipc server，该ipc server主要用于完成DataNode间的block recover。&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;runDatanodeDaemon()&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;  public static void runDatanodeDaemon(DataNode dn) throws IOException {
    if (dn != null) {
      //register datanode
      dn.register();
      dn.dataNodeThread = new Thread(dn, dnThreadName);
      dn.dataNodeThread.setDaemon(true); // needed for JUnit testing
      dn.dataNodeThread.start();
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2.1 向NameNode注册 —— dn.register();&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  private void register() throws IOException {
    if (dnRegistration.getStorageID().equals(&quot;&quot;)) {
      setNewStorageID(dnRegistration);
    }
    while(shouldRun) {
      try {
        // reset name to machineName. Mainly for web interface.
        dnRegistration.name = machineName + &quot;:&quot; + dnRegistration.getPort();
        // 通过NameProtocal向NameNode注册
        dnRegistration = namenode.register(dnRegistration);
        break;
      } catch(SocketTimeoutException e) {  // namenode is busy
        LOG.info(&quot;Problem connecting to server: &quot; + getNameNodeAddr());
        try {
          Thread.sleep(1000);
        } catch (InterruptedException ie) {}
      }
    }
    assert (&quot;&quot;.equals(storage.getStorageID()) 
            &amp;amp;&amp;amp; !&quot;&quot;.equals(dnRegistration.getStorageID()))
            || storage.getStorageID().equals(dnRegistration.getStorageID()) :
            &quot;New storageID can be assigned only if data-node is not formatted&quot;;
    if (storage.getStorageID().equals(&quot;&quot;)) {
      storage.setStorageID(dnRegistration.getStorageID());
      storage.writeAll();
      LOG.info(&quot;New storage id &quot; + dnRegistration.getStorageID()
          + &quot; is assigned to data-node &quot; + dnRegistration.getName());
    }
    if(! storage.getStorageID().equals(dnRegistration.getStorageID())) {
      throw new IOException(&quot;Inconsistent storage IDs. Name-node returned &quot;
          + dnRegistration.getStorageID() 
          + &quot;. Expecting &quot; + storage.getStorageID());
    }

    if (supportAppends) {
      Block[] bbwReport = data.getBlocksBeingWrittenReport();
      long[] blocksBeingWritten = BlockListAsLongs.convertToArrayLongs(bbwReport);
      //如果支持append，则报告正在写入的block信息
      namenode.blocksBeingWrittenReport(dnRegistration, blocksBeingWritten);
    }
    // 调整下一次的BR时间，使其在下次heartbeat时进行
    scheduleBlockReport(initialBlockReportDelay);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2.2 启动datanode线程 —— dn.dataNodeThread.start();&lt;/h4&gt;

&lt;p&gt;datanode线程本身非常简单，不停调用offerSevice提供服务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public void run() {
    LOG.info(dnRegistration + &quot;In DataNode.run, data = &quot; + data);

    // start dataXceiveServer
    dataXceiverServer.start();
    new Thread(new CrashVolumeChecker()).start();//added by wukong

    while (shouldRun) {
      try {
        startDistributedUpgradeIfNeeded();
        offerService();
      } catch (Exception ex) {
        LOG.error(&quot;Exception: &quot; + StringUtils.stringifyException(ex));
        if (shouldRun) {
          try {
            Thread.sleep(5000);
          } catch (InterruptedException ie) {
          }
        }
      }
    }

    LOG.info(dnRegistration + &quot;:Finishing DataNode in: &quot;+data);
    shutdown();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;2.2.1 offerService()&lt;/h5&gt;

&lt;p&gt;offerService的核心是周期性进行heartbeat和blockReport，主要流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/offerService.png&quot; alt=&quot;offerService&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public void offerService() throws Exception {

    LOG.info(&quot;using BLOCKREPORT_INTERVAL of &quot; + blockReportInterval + &quot;msec&quot; + 
       &quot; Initial delay: &quot; + initialBlockReportDelay + &quot;msec&quot;);
    LOG.info(&quot;using DELETEREPORT_INTERVAL of &quot; + deletedReportInterval + &quot;msec&quot;);
    LOG.info(&quot;using HEARTBEAT_INTERVAL of &quot; + heartBeatInterval + &quot;msec&quot;);
    LOG.info(&quot;using HEARTBEAT_EXPIRE_INTERVAL of &quot; + heartbeatExpireInterval + &quot;msec&quot;);

    //
    // Now loop for a long time....
    //

    while (shouldRun) {
      try {
        long startTime = now();

        //
        // Every so often, send heartbeat or block-report
        //

        if (startTime - lastHeartbeat &amp;gt; heartBeatInterval /* 3 secs*/) {
          //
          // All heartbeat messages include following info:
          // -- Datanode name
          // -- data transfer port
          // -- Total capacity
          // -- Bytes remaining
          //
          lastHeartbeat = startTime;
          DatanodeCommand[] cmds = namenode.sendHeartbeat(dnRegistration,
                                                       data.getCapacity(),
                                                       data.getDfsUsed(),
                                                       data.getRemaining(),
                                                       xmitsInProgress.get(),
                                                       getXceiverCount());
          myMetrics.heartbeats.inc(now() - startTime);
          //LOG.info(&quot;Just sent heartbeat, with name &quot; + localName);
          if (!processCommand(cmds))
            continue;
        }

        reportReceivedBlocks();

        DatanodeCommand cmd = blockReport();
        processCommand(cmd);

        // start block scanner
        if (blockScanner != null &amp;amp;&amp;amp; blockScannerThread == null &amp;amp;&amp;amp;
            upgradeManager.isUpgradeCompleted()) {
          LOG.info(&quot;Starting Periodic block scanner.&quot;);
          blockScannerThread = new Daemon(blockScanner);
          blockScannerThread.start();
        }

        //
        // There is no work to do;  sleep until hearbeat timer elapses, 
        // or work arrives, and then iterate again.
        //
        long waitTime = heartBeatInterval - (System.currentTimeMillis() - lastHeartbeat);
        synchronized(receivedAndDeletedBlockList) {
          if (waitTime &amp;gt; 0 &amp;amp;&amp;amp; receivedAndDeletedBlockList.size() == 0) {
            try {
              receivedAndDeletedBlockList.wait(waitTime);
            } catch (InterruptedException ie) {
            }
            delayBeforeBlockReceived();
          }
        } // synchronized

      } catch(RemoteException re) {
        String reClass = re.getClassName();
        if (UnregisteredDatanodeException.class.getName().equals(reClass) ||
            DisallowedDatanodeException.class.getName().equals(reClass) ||
            IncorrectVersionException.class.getName().equals(reClass)) {
          LOG.warn(&quot;DataNode is shutting down: &quot; + 
                   StringUtils.stringifyException(re));
          shutdown();
          return;
        }
        LOG.warn(StringUtils.stringifyException(re));
      } catch (IOException e) {
        LOG.warn(StringUtils.stringifyException(e));
      }
    } // while (shouldRun)
  } // offerService
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>HDFS源码学习（12）——DataNode主要数据结构</title>
   <link href="http://jiang-bo.github.com/blog/2012/10/18/hdfs-datanode-structure"/>
   <updated>2012-10-18T21:56:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/10/18/hdfs-datanode-structure</id>
   <content type="html">&lt;p&gt;HDFS中DataNode主要负责维护block-&gt;stream bytes的映射关系，即实际block数据的存储。
一个datanode的磁盘上存储目录下实际的文件部署结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data/
├── blocksBeingWritten
├── current
│   ├── VERSION
│   ├── blk_-1148021215131449924
│   ├── blk_-1148021215131449924_1001.meta
│   ├── blk_-8598609183581346893
│   ├── blk_-8598609183581346893_1002.meta
│   ├── blk_6693595845022390257
│   ├── blk_6693595845022390257_1003.meta
│   └── dncp_block_verification.log.curr
├── detach
├── storage
└── tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;data目录的路径是hdfs-site.xml中配置的dfs.data.dir的路径，表示每个datanode上数据存储的目录&lt;/p&gt;

&lt;p&gt;1) blocksBeingWritten：当前正在写入的block，写完之后会将block移至current目录&lt;/p&gt;

&lt;p&gt;2) current：当前已经写入的block文件目录&lt;/p&gt;

&lt;p&gt;2.1) VERSION为存储的VERSION文件，包括namespaceId，存储Id，存储版本，存储类型，创建时间戳等信息&lt;/p&gt;

&lt;p&gt;2.2）blk-*:文件为实际的block数据文件&lt;/p&gt;

&lt;p&gt;2.3）blk-*_xxx.meta: block的元信息文件&lt;/p&gt;

&lt;p&gt;2.4）dncp_*.log.curr: 当前copy文件&lt;/p&gt;

&lt;p&gt;3) detach：copy-on-write使用的目录&lt;/p&gt;

&lt;p&gt;4) tmp： 临时目录，DataNode启动时会检查 tmp的数据并删除。&lt;/p&gt;

&lt;h2&gt;Storage相关&lt;/h2&gt;

&lt;p&gt;Storage用于描述存储的类型，状态，目录等信息。
其主要结构如下：
&lt;img src=&quot;/images/hdfs/Storage.png&quot; alt=&quot;Storage&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;StorageInfo&lt;/h3&gt;

&lt;p&gt;StorageInfo表示一个存储的通用信息，包括：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;layoutVersion： 存储文件中的版本号&lt;/li&gt;
&lt;li&gt;namespaceId： 存储所属的命名空间ID&lt;/li&gt;
&lt;li&gt;ctime： 该存储创建的时间戳&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;Storage&lt;/h3&gt;

&lt;p&gt;存储信息的抽象类，管理一个server（NameNode或DataNode）上的存储目录。&lt;/p&gt;

&lt;p&gt;Storage有两个关键属性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;storageType: 表示该存储所属的节点类型（NameNode或是DataNode）&lt;/li&gt;
&lt;li&gt;storageDirs: 该存储上存储目录的列表(ArrayList&lt;StorageDirectory&gt;),StorageDirectory表示一个存储目录。&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;StorageDirectory&lt;/h4&gt;

&lt;p&gt;表示一个存储目录，有三个属性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;root：根目录&lt;/li&gt;
&lt;li&gt;lock：当前目录的文件锁&lt;/li&gt;
&lt;li&gt;dirType：目录类型&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;StorageSate&lt;/h4&gt;

&lt;p&gt;表示存储的状态：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;NON_EXISTENT: 目录不存在&lt;/li&gt;
&lt;li&gt;NOT_FORMATTED: 目录未格式化&lt;/li&gt;
&lt;li&gt;COMPLETE_UPGRADE: 升级完成&lt;/li&gt;
&lt;li&gt;RECOVER_UPGRADE: 撤销升级&lt;/li&gt;
&lt;li&gt;COMPLETE_FINALIZE: 提交完成&lt;/li&gt;
&lt;li&gt;COMPLETE_ROLLBACK: 回滚完成&lt;/li&gt;
&lt;li&gt;RECOVER_ROLLBACK: 撤销回滚&lt;/li&gt;
&lt;li&gt;COMPLETE_CHECKPOINT: checkpoint完成&lt;/li&gt;
&lt;li&gt;RECOVER_CHECKPOINT: 撤销checkpoint&lt;/li&gt;
&lt;li&gt;NORMAL: 正常&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;DataStorage&lt;/h3&gt;

&lt;p&gt;DataStorage是DataNode上使用的存储类，指定了datanode上各类存储文件的前缀：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;subdir：子目录前缀&lt;/li&gt;
&lt;li&gt;blk_：块文件前缀&lt;/li&gt;
&lt;li&gt;dncp_：拷贝文件前缀&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;DatanodeBlockInfo&lt;/h2&gt;

&lt;p&gt;DataNode使用DatanodeBlockInfo管理block和其元数据之间的映射关系，结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/DatanodeBlockInfo.png&quot; alt=&quot;DatanodeBlockInfo&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;volmun：block所属的卷&lt;/li&gt;
&lt;li&gt;file：block文件&lt;/li&gt;
&lt;li&gt;detached：是否完成copy-on-write&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;FSDataSet相关&lt;/h2&gt;

&lt;p&gt;DataNode通过FSDataSet来完成数据的存储。FSDataset类结构如下：
&lt;img src=&quot;/images/hdfs/FSDataset.png&quot; alt=&quot;FSDataset&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;FSVolume&lt;/h3&gt;

&lt;p&gt;FSVolumne用于进行block文件所属的卷管理，统计存储目录额使用情况，其中：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;currentDir： 当前数据目录, 对应data/current目录&lt;/li&gt;
&lt;li&gt;dataDir： 数据目录&lt;/li&gt;
&lt;li&gt;tmpDir： 临时目录, 对应data/tmp目录&lt;/li&gt;
&lt;li&gt;dtacheDir: 用于实现写时复制的文件，对应data/detach目录&lt;/li&gt;
&lt;li&gt;usage: 目录使用的空间&lt;/li&gt;
&lt;li&gt;dfsusage: dfs使用的空间&lt;/li&gt;
&lt;li&gt;reseved: 空余空间&lt;/li&gt;
&lt;li&gt;blocksBeingWritten: 正在写入的block，对应data/blocksBeingWritten目录&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;FSVolumeSet&lt;/h3&gt;

&lt;p&gt;FSVolumeSet是FSVolume的集合，提供了所有容量，剩余空间等方法。其中getNextVolume中提供了round-robin策略选取下一个volume，从而实现简单的IO负载均衡，提高IO处理能力。&lt;/p&gt;

&lt;h3&gt;FSDataSet&lt;/h3&gt;

&lt;p&gt;FSDataSet是在FSVolumeSet之上进行封装实现FSDatasetInterface借口，向外提供块查询和操作方法。&lt;/p&gt;

&lt;p&gt;其中有几个主要属性:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;volumes: 卷集合（FSVolumeSet）&lt;/li&gt;
&lt;li&gt;ongoingCreates: 当前活动的文件&lt;/li&gt;
&lt;li&gt;maxBlocksPerDir: 每个目录下最多能存放发block数，可通过dfs.datanode.numblocks配置&lt;/li&gt;
&lt;li&gt;volumeMap：块与块文件的映射信息(HashMap&amp;lt;Block, DatanodeBlockInfo&gt;)，当前集合中所有的块信息均维护在该map中&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;FSDir&lt;/h3&gt;

&lt;p&gt;用于构建block块在datanode磁盘上的层次结构，默认情况下每个目录下最多64个子目录，最多能存储64个块。目录初始化时会递归扫描目录下的所有子目录和文件，构建一个树形结构。&lt;/p&gt;

&lt;p&gt;addBlock时，首先尝试在当前目录新加块，如果当前目录没有空闲空间，则尝试在子目录中添加，如果没有子目录，则新建一个子目录。&lt;/p&gt;

&lt;h3&gt;BlockAndFile&lt;/h3&gt;

&lt;p&gt;Block与其文件名的封装&lt;/p&gt;

&lt;h3&gt;ActiveFile&lt;/h3&gt;

&lt;p&gt;表示一个当前活动中的文件&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>HDFS源码学习（11）——SecondaryNameNode</title>
   <link href="http://jiang-bo.github.com/blog/2012/10/18/hdfs-secondary-namenode"/>
   <updated>2012-10-18T21:55:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/10/18/hdfs-secondary-namenode</id>
   <content type="html">&lt;h2&gt;概述&lt;/h2&gt;

&lt;p&gt;SecondaryNameNode在HDFS中的主要作用是帮助master NameNode周期性执行checkpoint操作。&lt;/p&gt;

&lt;p&gt;NameNode将运行过程中对文件的修改记录保存在EditLog中。当NameNode重新启动时会从FSImage中加载命名空间镜像，并将EditLog中的内容合并到FSImage中，将合并后的FSImage写入到磁盘，同时清空EditLog，共后续使用。但如果NameNode长时间不重启，随时间增长，EditLog将会越来越大（每次文件操作都要记录），大量占用NameNode磁盘空间，且会导致下一次重启花费大量时间在合并Editlog上。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，SecondaryNameNode会定期从NameNode下载最新的FSImage和EditLog，合并editLog日志到FSImage，将合并后的FSImage上传到NameNode，并清空NameNode上的Editlog，将EditLog日志大小控制在一定限度下。&lt;/p&gt;

&lt;h2&gt;代码解析&lt;/h2&gt;

&lt;p&gt;SecondaryNameNode代码结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/SecondaryNameNode.png&quot; alt=&quot;SecondaryNameNode&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SecondaryNameNode本身就是实现了Runnable接口，即一个可执行线程。&lt;/p&gt;

&lt;p&gt;checkpointImage表示当前SecondNameNode上的FsImage镜像，该类CheckpointStorage扩展自FSImage。&lt;/p&gt;

&lt;p&gt;其中有两个主要的可配置属性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;checkpointPeriod: 两次检查点的间隔时间，可通过fs.checkpoint.period配置&lt;/li&gt;
&lt;li&gt;checkpointSize: EditLog文件的最大值，当EditLog超过这个最大值时会强制之行checkpoint，可通过fs.checkpoint.size配置，默认是64M&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;run()&lt;/h3&gt;

&lt;p&gt;run方法代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public void run() {

    //
    // Poll the Namenode (once every 5 minutes) to find the size of the
    // pending edit log.
    //
    long period = 5 * 60;              // 5 minutes
    long lastCheckpointTime = 0;
    if (checkpointPeriod &amp;lt; period) {
      period = checkpointPeriod;
    }

    while (shouldRun) {
      try {
        Thread.sleep(1000 * period);
      } catch (InterruptedException ie) {
        // do nothing
      }
      if (!shouldRun) {
        break;
      }
      try {
        long now = System.currentTimeMillis();

        long size = namenode.getEditLogSize();
        if (size &amp;gt;= checkpointSize || 
            now &amp;gt;= lastCheckpointTime + 1000 * checkpointPeriod) {
          doCheckpoint();
          lastCheckpointTime = now;
        }
      } catch (IOException e) {
        LOG.error(&quot;Exception in doCheckpoint: &quot;);
        LOG.error(StringUtils.stringifyException(e));
        e.printStackTrace();
      } catch (Throwable e) {
        LOG.error(&quot;Throwable Exception in doCheckpoint: &quot;);
        LOG.error(StringUtils.stringifyException(e));
        e.printStackTrace();
        Runtime.getRuntime().exit(-1);
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其核心就是周期性（默认每个5分钟)调用doCheckpoint().&lt;/p&gt;

&lt;h3&gt;doCheckpoint()&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;  void doCheckpoint() throws IOException {

    // 准备合并所需的空间
    startCheckpoint();

    // 通知NameNode将修改信息记录到新的editlog中，并获取一个用于上传合并后的fsimage的token
    CheckpointSignature sig = (CheckpointSignature)namenode.rollEditLog();

    // error simulation code for junit test
    if (ErrorSimulator.getErrorSimulation(0)) {
      throw new IOException(&quot;Simulating error0 &quot; +
                            &quot;after creating edits.new&quot;);
    }
    //从NameNode获取fsimage和editslog
    downloadCheckpointFiles(sig);   // Fetch fsimage and edits
    //合并editlog到fsimage
    doMerge(sig);                   // Do the merge

    //上传合并后的fsimage到NameNode
    putFSImage(sig);

    // error simulation code for junit test
    if (ErrorSimulator.getErrorSimulation(1)) {
      throw new IOException(&quot;Simulating error1 &quot; +
                            &quot;after uploading new image to NameNode&quot;);
    }
    // 通知NameNode使用该fsimage作为最新的镜像
    namenode.rollFsImage();
    checkpointImage.endCheckpoint();

    LOG.warn(&quot;Checkpoint done. New Image Size: &quot; 
              + checkpointImage.getFsImageName().length());
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;1. startCheckpoint()&lt;/h4&gt;

&lt;p&gt;该方法主要用于准备合并所需的磁盘空间，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  private void startCheckpoint() throws IOException {
    checkpointImage.unlockAll();
    // 关闭当前Editlog
    checkpointImage.getEditLog().close();
    // 检查当前checkpoints目录，如果不存在则创建一个新目录，如果目录中存在异常，则尝试恢复该目录
    checkpointImage.recoverCreate(checkpointDirs, checkpointEditsDirs);
    // 为新的checkpoint准备目录空间，将当前的目录空间更名为lastcheckpoint.™p，新建一个current目录 
    checkpointImage.startCheckpoint();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. namenode.rollEditLog();&lt;/h4&gt;

&lt;p&gt;namenode.rollEditLog()实际通过NameNodeProtocol调用NameNode.rollEditLog()方法，并最终调用FSImage.rollEditLog()，该方法主要完成：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;调用FSEditLog.rollEditLog()关闭当前editLog，新建一个editLog：edits.new&lt;/li&gt;
&lt;li&gt;返回一个CheckpointSignature做为上传合并后镜像的token&lt;/li&gt;
&lt;/ol&gt;


&lt;h5&gt;2.1. FSEditLog.rollEditLog()&lt;/h5&gt;

&lt;p&gt;该方法主要完成：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;关闭当前editlog， 打开一个新的editlog： edit.new&lt;/li&gt;
&lt;li&gt;返回editlog的最新更新时间&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;代码结构如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  synchronized void rollEditLog() throws IOException {
    //检查edit.new是否已经存在，如果存在，检查是否所有目录都存在，如果是则认为edits.new已经建好了，直接返回
    //
    if (existsNew()) {
      for (Iterator&amp;lt;StorageDirectory&amp;gt; it = 
               fsimage.dirIterator(NameNodeDirType.EDITS); it.hasNext();) {
        File editsNew = getEditNewFile(it.next());
     if (!editsNew.exists()) { 
          throw new IOException(&quot;Inconsistent existance of edits.new &quot; +
                                editsNew);
        }
      }
      return; // nothing to do, edits.new exists!
    }

    //关闭当前的editLog
    close();                     // close existing edit log

    //
    // 新建一个editLog： edits.new
    //
    for (Iterator&amp;lt;StorageDirectory&amp;gt; it = 
           fsimage.dirIterator(NameNodeDirType.EDITS); it.hasNext();) {
      StorageDirectory sd = it.next();
      try {
        EditLogFileOutputStream eStream = 
             new EditLogFileOutputStream(getEditNewFile(sd));
        eStream.create();
        editStreams.add(eStream);
      } catch (IOException e) {
        // remove stream and this storage directory from list
        processIOError(sd);
       it.remove();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;3. downloadCheckpointFiles()&lt;/h4&gt;

&lt;p&gt;该方法用于从NameNode下载FSImage和FSEditLog，代码结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  private void downloadCheckpointFiles(CheckpointSignature sig
                                      ) throws IOException {

    checkpointImage.cTime = sig.cTime;
    checkpointImage.checkpointTime = sig.checkpointTime;

    // 获取fsimage
    String fileid = &quot;getimage=1&quot;;
    File[] srcNames = checkpointImage.getImageFiles();
    assert srcNames.length &amp;gt; 0 : &quot;No checkpoint targets.&quot;;
    TransferFsImage.getFileClient(fsName, fileid, srcNames);
    LOG.info(&quot;Downloaded file &quot; + srcNames[0].getName() + &quot; size &quot; +
             srcNames[0].length() + &quot; bytes.&quot;);

    // 获取editlog
    fileid = &quot;getedit=1&quot;;
    srcNames = checkpointImage.getEditsFiles();
    assert srcNames.length &amp;gt; 0 : &quot;No checkpoint targets.&quot;;
    TransferFsImage.getFileClient(fsName, fileid, srcNames);
    LOG.info(&quot;Downloaded file &quot; + srcNames[0].getName() + &quot; size &quot; +
        srcNames[0].length() + &quot; bytes.&quot;);

    // 标示checkpoint所需文件已经准备完成
    checkpointImage.checkpointUploadDone();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;4. doMerge()&lt;/h4&gt;

&lt;p&gt;doMerge主要完成editLog与fsimage的合并，实际调用的checkpointImage.doMerge(sig);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void doMerge(CheckpointSignature sig) throws IOException {
  getEditLog().open();
  StorageDirectory sdName = null;
  StorageDirectory sdEdits = null;
  Iterator&amp;lt;StorageDirectory&amp;gt; it = null;
  it = dirIterator(NameNodeDirType.IMAGE);
  if (it.hasNext())
    sdName = it.next();
  it = dirIterator(NameNodeDirType.EDITS);
  if (it.hasNext())
    sdEdits = it.next();
  if ((sdName == null) || (sdEdits == null))
    throw new IOException(&quot;Could not locate checkpoint directories&quot;);
  // 加载fsimage
  loadFSImage(FSImage.getImageFile(sdName, NameNodeFile.IMAGE));
  // 加载editlog，并合并到fsimage

  loadFSEdits(sdEdits);
  // 校验新fsimage的一致性，主要包括版本，更新时间，namespaceId
  sig.validateStorageInfo(this);
  // 将fsImage存储到本地，并创建新edits
  saveFSImage();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方法与NameNode启动时类似:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;加载fsiamge&lt;/li&gt;
&lt;li&gt;加载editslog，并作用到fsimage中&lt;/li&gt;
&lt;li&gt;校验合并后的fsimage&lt;/li&gt;
&lt;li&gt;将新fsimage存储到本地，并新建空的edit是目录&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;5. putFSImage(sig);&lt;/h4&gt;

&lt;p&gt;该方法比较简单，主要通过TransferFsImage工具类将合并后的fsimage上传到NameNode&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  private void putFSImage(CheckpointSignature sig) throws IOException {
    String fileid = &quot;putimage=1&amp;amp;port=&quot; + infoPort +
      &quot;&amp;amp;machine=&quot; +
      InetAddress.getLocalHost().getHostAddress() +
      &quot;&amp;amp;token=&quot; + sig.toString();
    LOG.info(&quot;Posted URL &quot; + fsName + fileid);
    TransferFsImage.getFileClient(fsName, fileid, (File[])null);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;6. namenode.rollFsImage();&lt;/h4&gt;

&lt;p&gt;上传完新fsiamge之后，SecondaryNameNode通过namenode.rollFsImage()通知NameNode使用新的fsimage.ckpt作为最新镜像，并清空editslog。该请求最终由NameNode上的FsImage.rollFsImage()处理，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; void rollFSImage() throws IOException {
    if (ckptState != CheckpointStates.UPLOAD_DONE) {
      throw new IOException(&quot;Cannot roll fsImage before rolling edits log.&quot;);
    }
    //
    // 校验fsimage.ckpt和edits.new是否存在于所有目录
    if (!editLog.existsNew()) {
      throw new IOException(&quot;New Edits file does not exist&quot;);
    }
    for (Iterator&amp;lt;StorageDirectory&amp;gt; it = 
                       dirIterator(NameNodeDirType.IMAGE); it.hasNext();) {
      StorageDirectory sd = it.next();
      File ckpt = getImageFile(sd, NameNodeFile.IMAGE_NEW);
      if (!ckpt.exists()) {
        throw new IOException(&quot;Checkpoint file &quot; + ckpt +
                              &quot; does not exist&quot;);
      }
    }
    //删除旧的edits，并将edits.new重命名为edits
    editLog.purgeEditLog(); // renamed edits.new to edits

    //
    // 重命名fsimage
    for (Iterator&amp;lt;StorageDirectory&amp;gt; it = 
                       dirIterator(NameNodeDirType.IMAGE); it.hasNext();) {
      StorageDirectory sd = it.next();
      File ckpt = getImageFile(sd, NameNodeFile.IMAGE_NEW);
      File curFile = getImageFile(sd, NameNodeFile.IMAGE);
      // renameTo fails on Windows if the destination file 
      // already exists.
      if (!ckpt.renameTo(curFile)) {
        curFile.delete();
        if (!ckpt.renameTo(curFile)) {
          // Close edit stream, if this directory is also used for edits
          if (sd.getStorageDirType().isOfType(NameNodeDirType.EDITS))
            editLog.processIOError(sd);
        // add storage to the removed list
          removedStorageDirs.add(sd);
          it.remove();
        }
      }
    }

    //
    // 更新所有目录的fstime
    //
    this.layoutVersion = FSConstants.LAYOUT_VERSION;
    this.checkpointTime = FSNamesystem.now();
    for (Iterator&amp;lt;StorageDirectory&amp;gt; it = 
                           dirIterator(); it.hasNext();) {
      StorageDirectory sd = it.next();
      // delete old edits if sd is the image only the directory
      if (!sd.getStorageDirType().isOfType(NameNodeDirType.EDITS)) {
        File editsFile = getImageFile(sd, NameNodeFile.EDITS);
        editsFile.delete();
      }
      // delete old fsimage if sd is the edits only the directory
      if (!sd.getStorageDirType().isOfType(NameNodeDirType.IMAGE)) {
        File imageFile = getImageFile(sd, NameNodeFile.IMAGE);
        imageFile.delete();
      }
      try {
        sd.write();
      } catch (IOException e) {
        LOG.error(&quot;Cannot write file &quot; + sd.getRoot(), e);
        // Close edit stream, if this directory is also used for edits
        if (sd.getStorageDirType().isOfType(NameNodeDirType.EDITS))
          editLog.processIOError(sd);
      //add storage to the removed list
        removedStorageDirs.add(sd);
        it.remove();
      }
    }
    ckptState = FSImage.CheckpointStates.START;
  }
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>HDFS源码学习（10）——NameNode与DataNode间的通信</title>
   <link href="http://jiang-bo.github.com/blog/2012/10/18/hdfs-namenode-and-datanode-communication"/>
   <updated>2012-10-18T21:54:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/10/18/hdfs-namenode-and-datanode-communication</id>
   <content type="html">&lt;p&gt;NameNode和DataNode间的通信分为四种场景：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;初始时DataNode注册：&lt;/li&gt;
&lt;li&gt;周期性心跳检测：&lt;/li&gt;
&lt;li&gt;周期性blockreport：&lt;/li&gt;
&lt;li&gt;完成一个副本的写入：&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;一、初始时DataNode注册&lt;/h2&gt;

&lt;p&gt;DataNode在启动时会向NameNode注册，注册时需要提交的信息有DatanodeRegistration表示。结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/DatanodeRegistration.png&quot; alt=&quot;DatanodeRegistration&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主要包括：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;name：机器名（主机名+服务端口号）&lt;/li&gt;
&lt;li&gt;infoPort: 状态信息服务端口好&lt;/li&gt;
&lt;li&gt;ipcPort： 提供ipc服务的端口号&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;此外，该类中的storageID是该datanode在集群中的唯一id，在注册时有NameNode分配&lt;/p&gt;

&lt;p&gt;注册的主要流程如下：
&lt;img src=&quot;/images/hdfs/register.png&quot; alt=&quot;DataNodeRegister&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;二、心跳检测（heartbeat）&lt;/h2&gt;

&lt;p&gt;DataNode通过周期性调用namenode.sendHeartbeat()来完成心跳检测.主要流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/sendHeartbeat.png&quot; alt=&quot;sendHeartbeat&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;三、blockReport&lt;/h2&gt;

&lt;p&gt;DataNode周期性向NameNode发送blockReport，告知自己最新的block信息：
&lt;img src=&quot;/images/hdfs/blockReport.png&quot; alt=&quot;blockReport&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;四、完成副本写入&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>HDFS源码学习（9）——安全模式（SafeMode）</title>
   <link href="http://jiang-bo.github.com/blog/2012/10/18/hdfs-namenode-safe-mode"/>
   <updated>2012-10-18T21:52:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/10/18/hdfs-namenode-safe-mode</id>
   <content type="html">&lt;h2&gt;一、SafeModeInfo&lt;/h2&gt;

&lt;p&gt;SafeModeInfo维护了系统安全模式下的状态信息，每当系统进入安全模式时都会创建一个SafeModeInfo实例维护状态信息，离开时会销毁这个实例。
该类结构如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/SafeModeInfo.png&quot; alt=&quot;SafeModeInfo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中threshold和extension为可配置项：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;threshold表示离开安全模式时打到最低备份数的block的比例&lt;/li&gt;
&lt;li&gt;extension表示进入安全模式的最低时长&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;二、SafeModeMonitor&lt;/h2&gt;

&lt;p&gt;FSNameSystem中SafeModeMonitor代码结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  class SafeModeMonitor implements Runnable {
    /** interval in msec for checking safe mode: {@value} */
    private static final long recheckInterval = 1000;

    /**
     */
    public void run() {
      while (fsRunning &amp;amp;&amp;amp; (safeMode != null &amp;amp;&amp;amp; !safeMode.canLeave())) {
        try {
          Thread.sleep(recheckInterval);
        } catch (InterruptedException ie) {
        }
      }
      // leave safe mode and stop the monitor
      try {
        leaveSafeMode(true);
      } catch(SafeModeException es) { // should never happen
        String msg = &quot;SafeModeMonitor may not run during distributed upgrade.&quot;;
        assert false : msg;
        throw new RuntimeException(msg, es);
      }
      smmthread = null;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其核心就是每个1秒检测一次是否能够离开模式（safeMode.canLeave()），如果可以，则尝试离开并停止SafeModeMonitor线程（leaveSafeMode(true)）&lt;/p&gt;

&lt;h3&gt;1.1. 是否能离开 —— safeMode.canLeave()&lt;/h3&gt;

&lt;p&gt;能够离开安全模式的标准是：
1. 已进入安全模式的时长大于等于 extension
2. 安全的block数比例打到门槛值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;synchronized boolean canLeave() {
  if (reached == 0)
    return false;
  if (now() - reached &amp;lt; extension) {
    reportStatus(&quot;STATE* Safe mode ON.&quot;, false);
    return false;
  }
  return !needEnter();
}

/** 
 * There is no need to enter safe mode 
 * if DFS is empty or {@link #threshold} == 0
 */
boolean needEnter() {
  return getSafeBlockRatio() &amp;lt; threshold;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.2. 离开安全模式 —— leaveSafeMode(true);&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;  public void leaveSafeMode(boolean checkForUpgrades) throws SafeModeException {
    writeLock();
    try {
    if (!isInSafeMode()) {
      NameNode.stateChangeLog.info(&quot;STATE* Safe mode is already OFF.&quot;); 
      return;
    }
    //获取升级状态，如在升级中，不能离开安全模式
    if(getDistributedUpgradeState())
      throw new SafeModeException(&quot;Distributed upgrade is in progress&quot;,
                                  safeMode);
    //调用SafeModeInfo.leave()离开安全模式
    safeMode.leave(checkForUpgrades);
    } finally {
      writeUnlock();
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.2.1 SafeModeInfo.leave()&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    synchronized void leave(boolean checkForUpgrades) {
      if(checkForUpgrades) {
        // 验证是否需要升级
        boolean needUpgrade = false;
        try {
          needUpgrade = startDistributedUpgradeIfNeeded();
        } catch(IOException e) {
          FSNamesystem.LOG.error(StringUtils.stringifyException(e));
        }
        if(needUpgrade) {
          //如果需要升级，进入手动安全模式
          safeMode = new SafeModeInfo();
          return;
        }
      }
      // 如果备份队列未初始化完，继续初始化该队列
      if (!isPopulatingReplQueues()) {
        initializeReplQueues();
      }
      long timeInSafemode = now() - systemStart;
      NameNode.stateChangeLog.info(&quot;STATE* Leaving safe mode after &quot; 
                                    + timeInSafemode/1000 + &quot; secs.&quot;);
      NameNode.getNameNodeMetrics().safeModeTime.set((int) timeInSafemode);

      if (reached &amp;gt;= 0) {
        NameNode.stateChangeLog.info(&quot;STATE* Safe mode is OFF.&quot;); 
      }
      reached = -1;
      safeMode = null;
      NameNode.stateChangeLog.info(&quot;STATE* Network topology has &quot;
                                   +clusterMap.getNumOfRacks()+&quot; racks and &quot;
                                   +clusterMap.getNumOfLeaves()+ &quot; datanodes&quot;);
      NameNode.stateChangeLog.info(&quot;STATE* UnderReplicatedBlocks has &quot;
                                   +neededReplications.size()+&quot; blocks&quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>HDFS源码学习（8）——Backup Mode</title>
   <link href="http://jiang-bo.github.com/blog/2012/10/18/hdfs-namenode-backup-mode"/>
   <updated>2012-10-18T21:51:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/10/18/hdfs-namenode-backup-mode</id>
   <content type="html">&lt;h2&gt;元数据的持久化&lt;/h2&gt;

&lt;p&gt;HDFS通过主要通过FSImage和FSEditLog来完成文件元数据的持久化。对文件系统的任何修改，NameNode都会通过Editlog记录下来，持久化到本地。同时整个系统的命名空间，所有的文件元信息均保存在FSImage中，包括block-&gt;File的映射，文件的属性等等。NameNode启动时会从本地磁盘加载FSImage和FSEditLog，并将EditLog中的日志信息合并到FSImage中进行之持久化（该合并过程称为一个检查点：checkpoint），并构建文件系统的元信息。&lt;/p&gt;

&lt;p&gt;但是持久化的数据中不包括block&amp;lt;-&gt;datanode的映射信息，该信息由每个datanode向NameNode发起blockReport()请求时报告其所拥有的block信息。&lt;/p&gt;

&lt;h3&gt;Editlog记录修改日志&lt;/h3&gt;

&lt;p&gt;EditLog的持久化文件是一个二进制文件，大体结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/EditLogFile.png&quot; alt=&quot;EditLogFile&quot; /&gt;&lt;/p&gt;

&lt;p&gt;EditLog文件开始是一个日志版本号，0.19版本的hdfs中该version为-18。
随后是每一条操作的事务日志，每条日志的起始为一个操作类型位，随后是该操作的详细信息，不同的操作类型所带的详细信息也不同。加载EditLog是根据layoutVersion和edit_op位采取不同的方式解析后面的详细信息。
EditLog能够记录如下17中操作：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/EditLogOp.png&quot; alt=&quot;EditLogOp&quot; /&gt;&lt;/p&gt;

&lt;p&gt;EditLog为每种操作都提供了相应的log方法，当系统中发生文件修改时，会调用相应的log方法记录日志&lt;/p&gt;

&lt;h2&gt;元数据加载与恢复&lt;/h2&gt;

&lt;p&gt;NameNode启动过程中最终会通过FSImage.loadFSImage()来从fsimage目录中加载最新的fsimage镜像和editslog，并合并构建命名空间。
代码结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  boolean loadFSImage() throws IOException {
    // 根据checkpointtime查找最新的fsimage
    long latestNameCheckpointTime = Long.MIN_VALUE;
    long latestEditsCheckpointTime = Long.MIN_VALUE;
    StorageDirectory latestNameSD = null;
    StorageDirectory latestEditsSD = null;
    boolean needToSave = false;
    isUpgradeFinalized = true;
    Collection&amp;lt;String&amp;gt; imageDirs = new ArrayList&amp;lt;String&amp;gt;();
    Collection&amp;lt;String&amp;gt; editsDirs = new ArrayList&amp;lt;String&amp;gt;();
    for (Iterator&amp;lt;StorageDirectory&amp;gt; it = dirIterator(); it.hasNext();) {
      StorageDirectory sd = it.next();
      if (!sd.getVersionFile().exists()) {
        needToSave |= true;
        continue; // some of them might have just been formatted
      }
      boolean imageExists = false, editsExists = false;
      if (sd.getStorageDirType().isOfType(NameNodeDirType.IMAGE)) {
        imageExists = getImageFile(sd, NameNodeFile.IMAGE).exists();
        imageDirs.add(sd.getRoot().getCanonicalPath());
      }
      if (sd.getStorageDirType().isOfType(NameNodeDirType.EDITS)) {
        editsExists = getImageFile(sd, NameNodeFile.EDITS).exists();
        editsDirs.add(sd.getRoot().getCanonicalPath());
      }

      checkpointTime = readCheckpointTime(sd);
      if ((checkpointTime != Long.MIN_VALUE) &amp;amp;&amp;amp; 
          ((checkpointTime != latestNameCheckpointTime) || 
           (checkpointTime != latestEditsCheckpointTime))) {
        // Force saving of new image if checkpoint time
        // is not same in all of the storage directories.
        needToSave |= true;
      }
      if (sd.getStorageDirType().isOfType(NameNodeDirType.IMAGE) &amp;amp;&amp;amp; 
         (latestNameCheckpointTime &amp;lt; checkpointTime) &amp;amp;&amp;amp; imageExists) {
        latestNameCheckpointTime = checkpointTime;
        latestNameSD = sd;
      }
      if (sd.getStorageDirType().isOfType(NameNodeDirType.EDITS) &amp;amp;&amp;amp; 
           (latestEditsCheckpointTime &amp;lt; checkpointTime) &amp;amp;&amp;amp; editsExists) {
        latestEditsCheckpointTime = checkpointTime;
        latestEditsSD = sd;
      }
      if (checkpointTime &amp;lt;= 0L)
        needToSave |= true;
      // set finalized flag
      isUpgradeFinalized = isUpgradeFinalized &amp;amp;&amp;amp; !sd.getPreviousDir().exists();
    }

    // 确保至少有一个fsimage和一个edits目录
    if (latestNameSD == null)
      throw new IOException(&quot;Image file is not found in &quot; + imageDirs);
    if (latestEditsSD == null)
      throw new IOException(&quot;Edits file is not found in &quot; + editsDirs);

    // 确保获得的fsimage和edits是同一个检查点
    if (latestNameCheckpointTime &amp;gt; latestEditsCheckpointTime
        &amp;amp;&amp;amp; latestNameSD != latestEditsSD
        &amp;amp;&amp;amp; latestNameSD.getStorageDirType() == NameNodeDirType.IMAGE
        &amp;amp;&amp;amp; latestEditsSD.getStorageDirType() == NameNodeDirType.EDITS) {
      // This is a rare failure when NN has image-only and edits-only
      // storage directories, and fails right after saving images,
      // in some of the storage directories, but before purging edits.
      // See -NOTE- in saveNamespace().
      LOG.error(&quot;This is a rare failure scenario!!!&quot;);
      LOG.error(&quot;Image checkpoint time &quot; + latestNameCheckpointTime +
          &quot; &amp;gt; edits checkpoint time &quot; + latestEditsCheckpointTime);
      LOG.error(&quot;Name-node will treat the image as the latest state of &quot; +
          &quot;the namespace. Old edits will be discarded.&quot;);
    } else if (latestNameCheckpointTime != latestEditsCheckpointTime)
      throw new IOException(&quot;Inconsitent storage detected, &quot; +
          &quot;image and edits checkpoint times do not match. &quot; +
          &quot;image checkpoint time = &quot; + latestNameCheckpointTime +
          &quot;edits checkpoint time = &quot; + latestEditsCheckpointTime);

    // 如果上次检查点中断了，则恢复该检查点
    needToSave |= recoverInterruptedCheckpoint(latestNameSD, latestEditsSD);

    long startTime = FSNamesystem.now();
    long imageSize = getImageFile(latestNameSD, NameNodeFile.IMAGE).length();

    //
    // 加载fsimage文件
    //
    latestNameSD.read();
    needToSave |= loadFSImage(getImageFile(latestNameSD, NameNodeFile.IMAGE));
    LOG.info(&quot;Image file of size &quot; + imageSize + &quot; loaded in &quot; 
        + (FSNamesystem.now() - startTime)/1000 + &quot; seconds.&quot;);

    // 加载最新的edits并作用于fsimage上
    if (latestNameCheckpointTime &amp;gt; latestEditsCheckpointTime)
      // the image is already current, discard edits
      needToSave |= true;
    else // latestNameCheckpointTime == latestEditsCheckpointTime
      needToSave |= (loadFSEdits(latestEditsSD) &amp;gt; 0);

    return needToSave;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中FSImage.loadFSImage(File curFile) 代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  boolean loadFSImage(File curFile) throws IOException {
    assert this.getLayoutVersion() &amp;lt; 0 : &quot;Negative layout version is expected.&quot;;
    assert curFile != null : &quot;curFile is null&quot;;

    FSNamesystem fsNamesys = FSNamesystem.getFSNamesystem();
    FSDirectory fsDir = fsNamesys.dir;

    //
    // Load in bits
    //
    boolean needToSave = true;
    DataInputStream in = new DataInputStream(new BufferedInputStream(
                              new FileInputStream(curFile)));
    try {
      /*
       * Note: Remove any checks for version earlier than 
       * Storage.LAST_UPGRADABLE_LAYOUT_VERSION since we should never get 
       * to here with older images.
       */

      /*
       * TODO we need to change format of the image file
       * it should not contain version and namespace fields
       */
      // 读取imageversion
      int imgVersion = in.readInt();
      // 读取namespaceid
      this.namespaceID = in.readInt();

      // 读取镜像中的文件数
      long numFiles;
      if (imgVersion &amp;lt;= -16) {
        numFiles = in.readLong();
      } else {
        numFiles = in.readInt();
      }

      this.layoutVersion = imgVersion;
      // 读取镜像时间戳
      if (imgVersion &amp;lt;= -12) {
        long genstamp = in.readLong();
        fsNamesys.setGenerationStamp(genstamp); 
      }

      needToSave = (imgVersion != FSConstants.LAYOUT_VERSION);

      // 读取每个文件的信息
      short replication = FSNamesystem.getFSNamesystem().getDefaultReplication();

      LOG.info(&quot;Number of files = &quot; + numFiles);

      byte[][] pathComponents;
      byte[][] parentPath = ;
      INodeDirectory parentINode = fsDir.rootDir;
      for (long i = 0; i &amp;lt; numFiles; i++) {
        long modificationTime = 0;
        long atime = 0;
        long blockSize = 0;
        //读取文件名(path)
        pathComponents = readPathComponents(in);
        //读取副本数
        replication = in.readShort();
        //调整副本数，使其不超过系统的最大和最小副本数限制
        replication = FSEditLog.adjustReplication(replication);
        //读取文件修改时间
        modificationTime = in.readLong();
        if (imgVersion &amp;lt;= -17) {
        //读取最近访问时间
          atime = in.readLong();
        }
        if (imgVersion &amp;lt;= -8) {
        //读取block块大小
          blockSize = in.readLong();
        }
        //读取block数
        int numBlocks = in.readInt();
        //构建blocks
        Block blocks[] = null;

        // 老版本hdfs中，numBlocks=0表示目录，新版本中numBlocks=-1表示目录
        if ((-9 &amp;lt;= imgVersion &amp;amp;&amp;amp; numBlocks &amp;gt; 0) ||
            (imgVersion &amp;lt; -9 &amp;amp;&amp;amp; numBlocks &amp;gt;= 0)) {
           //构建文件block信息
          blocks = new Block[numBlocks];
          for (int j = 0; j &amp;lt; numBlocks; j++) {
            blocks[j] = new Block();
            if (-14 &amp;lt; imgVersion) {
              blocks[j].set(in.readLong(), in.readLong(), 
                            Block.GRANDFATHER_GENERATION_STAMP);
            } else {
              // 读取block信息
              blocks[j].readFields(in);
            }
          }
        }
        // 老版本inode中不维护blocksize，如果存在多个block，blocksize选取第一个block的大小，如果只有一个block，则选该block大小和默认大小中较大的，如果没有block，则选用默认大小
        if (-8 &amp;lt;= imgVersion &amp;amp;&amp;amp; blockSize == 0) {
          if (numBlocks &amp;gt; 1) {
            blockSize = blocks[0].getNumBytes();
          } else {
            long first = ((numBlocks == 1) ? blocks[0].getNumBytes(): 0);
            blockSize = Math.max(fsNamesys.getDefaultBlockSize(), first);
          }
        }

        // 如果是目录（blocks=null），读取该目录的配额
        long nsQuota = -1L;
        if (imgVersion &amp;lt;= -16 &amp;amp;&amp;amp; blocks == null) {
          nsQuota = in.readLong();
        }
        long dsQuota = -1L;
        if (imgVersion &amp;lt;= -18 &amp;amp;&amp;amp; blocks == null) {
          dsQuota = in.readLong();
        }

        //获取权限信息
        PermissionStatus permissions = fsNamesys.getUpgradePermission();
        if (imgVersion &amp;lt;= -11) {
          permissions = PermissionStatus.read(in);
        }

        //如果该path为root，且设置了配额信息，则更新根目录的配额
        if (isRoot(pathComponents)) { // it is the root
          // update the root's attributes
          if (nsQuota != -1 || dsQuota != -1) {
            fsDir.rootDir.setQuota(nsQuota, dsQuota);
          }
          fsDir.rootDir.setModificationTime(modificationTime);
          fsDir.rootDir.setPermissionStatus(permissions);
          continue;
        }
        //如果该inode的parent与当前路径不一至，获取新的parentPaht
        if(!isParent(pathComponents, parentPath)) {
          parentINode = null;
          parentPath = getParent(pathComponents);
        }
        // 将该inode添加到inode树中
        parentINode = fsDir.addToParent(pathComponents, parentINode, permissions,
                                        blocks, replication, modificationTime, 
                                        atime, nsQuota, dsQuota, blockSize);
      }

      // 加载datanode信息，imgVersion&amp;lt;-12的版本事实上啥都不做，datanode信息已经不保存在fsimage中
      this.loadDatanodes(imgVersion, in);

      // 加载正在构建中的文件
      this.loadFilesUnderConstruction(imgVersion, in, fsNamesys);

    } finally {
      in.close();
    }

    return needToSave;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其核心就是加载并解析fsimage文件，构建命名空间，fsimage文件的结构参见《NameNode中主要数据结构》&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>HDFS源码学习（7）——Block管理</title>
   <link href="http://jiang-bo.github.com/blog/2012/10/18/hdfs-namenode-block-management"/>
   <updated>2012-10-18T21:46:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/10/18/hdfs-namenode-block-management</id>
   <content type="html">&lt;p&gt;HDFS通过一个BlockManager管理集群中所有的block信息&lt;/p&gt;

&lt;h2&gt;主要数据结构&lt;/h2&gt;

&lt;h3&gt;Block&lt;/h3&gt;

&lt;p&gt;Block是HDFS读写的基本单元，集群中每个block通过一个long id来唯一标示。&lt;/p&gt;

&lt;h3&gt;BlockInfo&lt;/h3&gt;

&lt;p&gt;维护一个block的元信息，主要通过&lt;/p&gt;

&lt;h3&gt;BlockMap&lt;/h3&gt;

&lt;p&gt;通过一个GSet&amp;lt;Block, BlockInfo&gt;维护一个block与其元数据信息的映射关系，元信息包括其所属的BlockCollection和存储该block的datanode节点，每个BlockMap有个初始容量capacity&lt;/p&gt;

&lt;h3&gt;BlockCollection&lt;/h3&gt;

&lt;h2&gt;Block和副本管理&lt;/h2&gt;

&lt;h3&gt;Block和副本状态&lt;/h3&gt;

&lt;p&gt;Block有如下状态：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;committed：所有的副本已经被创建且更新至最新&lt;/li&gt;
&lt;li&gt;Under construction: 需要创建一个或多个副本&lt;/li&gt;
&lt;li&gt;To be deleted: 所有副本需要被删除。发生在文件被删除或者block被重写&lt;/li&gt;
&lt;li&gt;Over-replicated: 过多的副本存在。此时副本中的一个需要设置为无效并删除。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;副本有如下状态：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Current: 正常状态，该副本正确反应block内容&lt;/li&gt;
&lt;li&gt;Conrrupt: 某个副本损坏。副本损坏是由client报告给namenode的。client通过checksum检查副本是否损坏，如果损坏了，通过BlockManager.invalidateBlock()处理&lt;/li&gt;
&lt;li&gt;On a faild DataNode: DataNode Heartbeat发现有DataNode失效时，即将在改datanode上创建的副本将被删除&lt;/li&gt;
&lt;li&gt;Out of Date: 当Datanode失效，且副本所属的block发生更新后，Datanode恢复正常。过期的block将通过blockreport报告给namenode，并将其删除&lt;/li&gt;
&lt;li&gt;Under construction: 副本尚未被写入并在Datanode上被验证。在NameNode看来，只有当收到blockReport并且报告中timestamp正确时，猜人物副本写入正常。&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;Block分配&lt;/h2&gt;

&lt;h2&gt;Block查询&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>HDFS源码学习（6）——租约管理（lease management)</title>
   <link href="http://jiang-bo.github.com/blog/2012/10/18/hdfs-namenode-lease-management"/>
   <updated>2012-10-18T21:44:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/10/18/hdfs-namenode-lease-management</id>
   <content type="html">&lt;p&gt;LeaseManagement是HDFS中的一个同步机制，用于保证同一时刻只有一个client对一个文件进行写或创建操作。如当新建一个文件f时，client向NameNode发起一个create请求，那么leaseManager会想该client分配一个f文件的lease。client凭借该lease完成文件的创建操作。此时其他client无法获得f的当client长时间（默认为超过1min）不进行操作时，发放的lease将被收回。&lt;/p&gt;

&lt;p&gt;LeaseManager主要完成两部分工作：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;文件create，write，complete操作时，创建lease、更新时间戳、回收lease&lt;/li&gt;
&lt;li&gt;一个后台线程定期检查是否有过期的lease&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;LeaseManager的代码结构如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/LeaseManager.png&quot; alt=&quot;LeaseManager&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中Lease表示一个租约，包括一个client(holder)所拥有的所有文件锁(paths)。&lt;/p&gt;

&lt;p&gt;Monitor是检查是否有过期租约的线程。&lt;/p&gt;

&lt;p&gt;LeaseManager中有几个主要数据结构：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;leases（TreeMap&amp;lt;String, Lease&gt;）：维护holder -&gt; leased的映射集合&lt;/li&gt;
&lt;li&gt;sortedLeases (TreeSet&lt;Lease&gt;): lease集合&lt;/li&gt;
&lt;li&gt;sortedLeaseByPath(TreeMap&amp;lt;String, Lease&gt;): 维护paths-&gt;lease的映射集合&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;一、创建lease&lt;/h2&gt;

&lt;p&gt;当client向NameNode发起create操作时，NameNode.create()调用FSNameSystem.startFile()-&gt;FSNameSystem.startFileInternal()，该方法最终会调用leaseManager.addLease(cons.clientName, src)来创建lease。&lt;/p&gt;

&lt;p&gt;LeaseManager.addLease()方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  synchronized Lease addLease(String holder, String src
      ) throws IOException {
    Lease lease = getLease(holder);
    if (lease == null) {
      lease = new Lease(holder);
      leases.put(holder, lease);
      sortedLeases.add(lease);
    } else {
      renewLease(lease);
    }
    sortedLeasesByPath.put(src, lease);
    lease.paths.add(src);
    return lease;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码结构简单：判断该client是否有lease，没有则新建一个lease，并将起加到leases集合中。否则更新lease。更新sortedLeasesByPath，将filepath加入到该lease的paths集合中&lt;/p&gt;

&lt;h2&gt;二、更新时间戳&lt;/h2&gt;

&lt;p&gt;针对已经存在的lease，通过LeasemManager.renewLease()来更新该lease的时间戳。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  synchronized void renewLease(Lease lease) {
    if (lease != null) {
      sortedLeases.remove(lease);
      lease.renew();
      sortedLeases.add(lease);
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lease.renew()代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/** Only LeaseManager object can renew a lease */
private void renew() {
  this.lastUpdate = FSNamesystem.now();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;三、compelete时回收lease&lt;/h2&gt;

&lt;p&gt;当client调用NameNode.complete()方法时，最终会调用FSNameSystem.completeFileInternal()方法。其中执行finalizeINodeFileUnderConstruction()是调用leaseManager.removeLease()释放lease。&lt;/p&gt;

&lt;p&gt;代码结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  synchronized void removeLease(String holder, String src) {
    Lease lease = getLease(holder);
    if (lease != null) {
      removeLease(lease, src);
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; removeLease(lease, src);代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  /**
   * Remove the specified lease and src.
   */
  synchronized void removeLease(Lease lease, String src) {
    sortedLeasesByPath.remove(src);
    if (!lease.removePath(src)) {
      LOG.error(src + &quot; not found in lease.paths (=&quot; + lease.paths + &quot;)&quot;);
    }

    if (!lease.hasPath()) {
      leases.remove(lease.holder);
      if (!sortedLeases.remove(lease)) {
        LOG.error(lease + &quot; not found in sortedLeases&quot;);
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;四、后台线程回收过期lease&lt;/h2&gt;

&lt;p&gt;Monitor回收lease线程代码结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; class Monitor implements Runnable {
    final String name = getClass().getSimpleName();

    /** Check leases periodically. */
    public void run() {
      for(; fsnamesystem.isRunning(); ) {
        fsnamesystem.writeLock();
        try {
          checkLeases();
        } finally {
          fsnamesystem.writeUnlock();
        }

        try {
          Thread.sleep(2000);
        } catch(InterruptedException ie) {
          if (LOG.isDebugEnabled()) {
            LOG.debug(name + &quot; is interrupted&quot;, ie);
          }
        }
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码结构简单，每个2s周期性执行checkLeases()。&lt;/p&gt;

&lt;h3&gt;4.1 checkLeases()&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;  /** Check the leases beginning from the oldest. */
  synchronized void checkLeases() {
    for(; sortedLeases.size() &amp;gt; 0; ) {
      final Lease oldest = sortedLeases.first();
      if (!oldest.expiredHardLimit()) {
        return;
      }

      LOG.info(&quot;Lease &quot; + oldest + &quot; has expired hard limit&quot;);

      final List&amp;lt;String&amp;gt; removing = new ArrayList&amp;lt;String&amp;gt;();
      // need to create a copy of the oldest lease paths, becuase 
      // internalReleaseLease() removes paths corresponding to empty files,
      // i.e. it needs to modify the collection being iterated over
      // causing ConcurrentModificationException
      String[] leasePaths = new String[oldest.getPaths().size()];
      oldest.getPaths().toArray(leasePaths);
      for(String p : leasePaths) {
        try {
          fsnamesystem.internalReleaseLeaseOne(oldest, p);
        } catch (IOException e) {
          LOG.error(&quot;Cannot release the path &quot;+p+&quot; in the lease &quot;+oldest, e);
          removing.add(p);
        }
      }

      for(String p : removing) {
        removeLease(oldest, p);
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Lease Recovery ——租约回收&lt;/h2&gt;

&lt;h3&gt;lease recovery时机&lt;/h3&gt;

&lt;p&gt;lease发放之后，在不用时会被回收，回收的产经除上述Monitor线程检测lease过期是回收外，还有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;NameNode收到DataNode的Sync block command时&lt;/li&gt;
&lt;li&gt;DFSClient主动关闭一个流时&lt;/li&gt;
&lt;li&gt;创建文件时，如果该DFSClient的lease超过soft limit时&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;lease recovery 算法&lt;/h3&gt;

&lt;p&gt;1) NameNode查找lease信息&lt;/p&gt;

&lt;p&gt;2) 对于lease中的每个文件f，令b为f的最后一个block，作如下操作：&lt;/p&gt;

&lt;p&gt;2.1) 获取b所在的datanode列表&lt;/p&gt;

&lt;p&gt;2.2) 令其中一个datanode作为primary datanode p&lt;/p&gt;

&lt;p&gt;2.3) p 从NameNode获取最新的时间戳&lt;/p&gt;

&lt;p&gt;2.4) p 从每个DataNode获取block信息&lt;/p&gt;

&lt;p&gt;2.5) p 计算最小的block长度&lt;/p&gt;

&lt;p&gt;2.6) p 用最小的block长度和最新的时间戳来更新具有有效时间戳的datanode&lt;/p&gt;

&lt;p&gt;2.7) p 通知NameNode更新结果&lt;/p&gt;

&lt;p&gt;2.8) NameNode更新BlockInfo&lt;/p&gt;

&lt;p&gt;2.9) NameNode从lease中删除f，如果此时该lease中所有文件都已被删除，将删除该lease&lt;/p&gt;

&lt;p&gt;2.10) Name提交修改的EditLog&lt;/p&gt;

&lt;h2&gt;Client续约 —— DFSClient.LeaseChecker&lt;/h2&gt;

&lt;p&gt;在NameNode上的LeaseManager.Monitor线程负责检查过期的lease，那么client为了防止尚在使用的lease过期，需要定期想NameNode发起续约请求。该任务有DFSClient中的LeaseChecker完成。&lt;/p&gt;

&lt;p&gt;LeaseChecker结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/LeaseChecker.png&quot; alt=&quot;LeaseChecker&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中pendingCreates是一个TreeMap&amp;lt;String, OutputStream&gt;用来维护src-&gt;当前正在写入的文件的DFSOutputStream的映射。&lt;/p&gt;

&lt;p&gt;其核心是周期性（每个1s）调用run()方法来对租约过半的lease进行续约&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void run() {
  long lastRenewed = 0;
  while (clientRunning &amp;amp;&amp;amp; !Thread.interrupted()) {
    //当租约周期过半时需要进行续约
    if (System.currentTimeMillis() - lastRenewed &amp;gt; (LEASE_SOFTLIMIT_PERIOD / 2)) {
      try {
        renew();
        lastRenewed = System.currentTimeMillis();
      } catch (IOException ie) {
        LOG.warn(&quot;Problem renewing lease for &quot; + clientName, ie);
      }
    }

    try {
      Thread.sleep(1000);
    } catch (InterruptedException ie) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(this + &quot; is interrupted.&quot;, ie);
      }
      return;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中renew()方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    private void renew() throws IOException {
      synchronized(this) {
        //如果当前创建中的文件列表为空，则不需要续约
        if (pendingCreates.isEmpty()) {
          return;
        }
      }
      //向NameNode发起续约请求
      namenode.renewLease(clientName);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NameNode接收到renewLease请求后，调用FSNameSystem.renewLease()并最终调用LeaseManager.renewLease()完成续约。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>HDFS源码学习（5）——副本管理（Replica Management)</title>
   <link href="http://jiang-bo.github.com/blog/2012/10/18/hdfs-namenode-replica-management"/>
   <updated>2012-10-18T21:43:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/10/18/hdfs-namenode-replica-management</id>
   <content type="html">&lt;p&gt;HDFS中的副本管理通过FSNameSystem.java中的ReplicationMonitor线程来完成。该线程代码结构较为简单。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  class ReplicationMonitor implements Runnable {
    static final int INVALIDATE_WORK_PCT_PER_ITERATION = 32;
    static final float REPLICATION_WORK_MULTIPLIER_PER_ITERATION = 2;
    public void run() {
      while (fsRunning) {
        try {
          computeDatanodeWork();
          processPendingReplications();
          Thread.sleep(replicationRecheckInterval);
        } catch (InterruptedException ie) {
          LOG.warn(&quot;ReplicationMonitor thread received InterruptedException.&quot;, ie);
          break;
        } catch (IOException ie) {
          LOG.warn(&quot;ReplicationMonitor thread received exception. &quot; + ie +  &quot; &quot; +
              StringUtils.stringifyException(ie));
        } catch (Throwable t) {
          LOG.fatal(&quot;ReplicationMonitor thread received Runtime exception. &quot; + t + &quot; &quot; +
              StringUtils.stringifyException(t));
          Runtime.getRuntime().exit(-1);
        }
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该线程只是周期性调用computeDatanodeWork()和processPendingReplications()。&lt;/p&gt;

&lt;h2&gt;一、computeDatanodeWork()&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;  public int computeDatanodeWork() throws IOException {
    int workFound = 0;
    int blocksToProcess = 0;
    int nodesToProcess = 0;
    // blocks should not be replicated or removed if safe mode is on
    if (isInSafeMode())
      return workFound;
    //计算需要备份的block数和节点数
    synchronized(heartbeats) {
      blocksToProcess = (int)(heartbeats.size() 
          * ReplicationMonitor.REPLICATION_WORK_MULTIPLIER_PER_ITERATION);
      nodesToProcess = (int)Math.ceil((double)heartbeats.size() 
          * ReplicationMonitor.INVALIDATE_WORK_PCT_PER_ITERATION / 100);
    }
    //执行备份
    workFound = computeReplicationWork(blocksToProcess); 

    // Update FSNamesystemMetrics counters
    pendingReplicationBlocksCount = pendingReplications.size();
    underReplicatedBlocksCount = neededReplications.size();
    scheduledReplicationBlocksCount = workFound;
    corruptReplicaBlocksCount = corruptReplicas.size();

    //HADOOP-5549 : Fix bug of schedule both replication and deletion work in one iteration
    workFound += computeInvalidateWork(nodesToProcess);
    return workFound;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.1. computeReplicationWork()&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;  private int computeReplicationWork(
                                  int blocksToProcess) throws IOException {
    // stall only useful for unit tests (see TestFileAppend4.java)
    if (stallReplicationWork)  {
      return 0;
    }

    // 选取需要备份的block
    List&amp;lt;List&amp;lt;Block&amp;gt;&amp;gt; blocksToReplicate =
      chooseUnderReplicatedBlocks(blocksToProcess);

    // 执行备份
    return computeReplicationWorkForBlocks(blocksToReplicate);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.1.1 选取需要备份的block —— chooseUnderReplicatedBlocks()&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;  List&amp;lt;List&amp;lt;Block&amp;gt;&amp;gt; chooseUnderReplicatedBlocks(int blocksToProcess) {
    // 初始化返回值数据结构，返回值是一个二维优先级列表
    List&amp;lt;List&amp;lt;Block&amp;gt;&amp;gt; blocksToReplicate =
      new ArrayList&amp;lt;List&amp;lt;Block&amp;gt;&amp;gt;(UnderReplicatedBlocks.LEVEL);
    for (int i = 0; i &amp;lt; UnderReplicatedBlocks.LEVEL; i++) {
      blocksToReplicate.add(new ArrayList&amp;lt;Block&amp;gt;());
    }

    writeLock();
    try {
      synchronized (neededReplications) {
        if (neededReplications.size() == 0) {
          return blocksToReplicate;
        }

        for (int priority = 0; priority&amp;lt;UnderReplicatedBlocks.LEVEL; priority++) {
        //遍历所有需要备份的block列表（UnderReplicatedBlocks结构）
        BlockIterator neededReplicationsIterator = neededReplications.iterator(priority);
        int numBlocks = neededReplications.size(priority);
        //检查该优先级列表中是否已经开始备份（relIndex数组中保存的是当前每个优先级列表中已备份的block索引）
        if (replIndex[priority] &amp;gt; numBlocks) {
          replIndex[priority] = 0;
        }
        // skip to the first unprocessed block, which is at replIndex
        for (int i = 0; i &amp;lt; replIndex[priority] &amp;amp;&amp;amp; neededReplicationsIterator.hasNext(); i++) {
          neededReplicationsIterator.next();
        }
        // 计算该优先级下需要备份的block数，低优先级的block备份数不超过总配额的20%
        int blocksToProcessIter = getQuotaForThisPriority(blocksToProcess,
            numBlocks, neededReplications.getSize(priority+1));
        blocksToProcess -= blocksToProcessIter;

        //便利改优先级列表将该优先级下的block添加到返回值中
        for (int blkCnt = 0; blkCnt &amp;lt; blocksToProcessIter; blkCnt++, replIndex[priority]++) {
          if (!neededReplicationsIterator.hasNext()) {
            // start from the beginning
            replIndex[priority] = 0;
            neededReplicationsIterator = neededReplications.iterator(priority);
            assert neededReplicationsIterator.hasNext() :
              &quot;neededReplications should not be empty.&quot;;
          }

          Block block = neededReplicationsIterator.next();
          blocksToReplicate.get(priority).add(block);
        } // end for
        }
      } // end try
      return blocksToReplicate;
    } finally {
      writeUnlock();
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.1.2. 备份blocks —— computeReplicationWorkForBlocks（）&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;  int computeReplicationWorkForBlocks(List&amp;lt;List&amp;lt;Block&amp;gt;&amp;gt; blocksToReplicate) {
    int requiredReplication, numEffectiveReplicas, priority;
    List&amp;lt;DatanodeDescriptor&amp;gt; containingNodes;
    DatanodeDescriptor srcNode;
    INodeFile fileINode = null;

    int scheduledWork = 0;
    List&amp;lt;ReplicationWork&amp;gt; work = new LinkedList&amp;lt;ReplicationWork&amp;gt;();

    writeLock();
    try {
      synchronized (neededReplications) {
        for (priority = 0; priority &amp;lt; blocksToReplicate.size(); priority++) {
          for (Block block : blocksToReplicate.get(priority)) {
            // block should belong to a file
            //获取该block所属的INode
            fileINode = blocksMap.getINode(block);
            // abandoned block not belong to a file
            if (fileINode == null ) {
              neededReplications.remove(block, priority); // remove from neededReplications
              replIndex[priority]--;
              continue;
            }
            //获取该文件需要的副本数
            requiredReplication = fileINode.getReplication();

            // 获取一个源datanode节点
            containingNodes = new ArrayList&amp;lt;DatanodeDescriptor&amp;gt;();
            NumberReplicas numReplicas = new NumberReplicas();
            srcNode = chooseSourceDatanode(block, containingNodes, numReplicas);
            if (srcNode == null) // block can not be replicated from any node
            {
              continue;
            }

          // 检查正在备份中的副本数是否满足备份需要，满足则不需要再备份
            numEffectiveReplicas = numReplicas.liveReplicas() +
              pendingReplications.getNumReplicas(block);
            if (numEffectiveReplicas &amp;gt;= requiredReplication) {
              neededReplications.remove(block, priority); // remove from neededReplications
              replIndex[priority]--;
              continue;
            }
            //添加到待备份列表中
            work.add(new ReplicationWork(block, fileINode, requiredReplication
                - numEffectiveReplicas, srcNode, containingNodes, priority));
          }
        }
      }
    } finally {
      writeUnlock();
    }

    // 选取一个备份目标datanode
    for(ReplicationWork rw : work){
      DatanodeDescriptor targets[] = chooseTarget(rw);
      rw.targets = targets;
    }

    writeLock();
    try {
      for(ReplicationWork rw : work){
        DatanodeDescriptor[] targets = rw.targets;
        if(targets == null || targets.length == 0){
          rw.targets = null;
          continue;
        }
        synchronized (neededReplications) {
          Block block = rw.block;
          priority = rw.priority;
          // 重新检查INode和备份数，因为全局锁已经释放
          // block should belong to a file
          fileINode = blocksMap.getINode(block);
          // abandoned block not belong to a file
          if (fileINode == null ) {
            neededReplications.remove(block, priority); // remove from neededReplications
            rw.targets = null;
            replIndex[priority]--;
            continue;
          }
          requiredReplication = fileINode.getReplication();


          NumberReplicas numReplicas = countNodes(block);
          numEffectiveReplicas = numReplicas.liveReplicas() +
            pendingReplications.getNumReplicas(block);
          if (numEffectiveReplicas &amp;gt;= requiredReplication) {
            neededReplications.remove(block, priority); // remove from neededReplications
            replIndex[priority]--;
            rw.targets = null;
            continue;
          }

          // 将block添加到datanode的需要备份的block列表中
          rw.srcNode.addBlockToBeReplicated(block, targets);

          scheduledWork++;

          //设置namenode的block调度计数器
          for (DatanodeDescriptor dn : targets) {
            dn.incBlocksScheduled();
          }

          // Move the block-replication into a &quot;pending&quot; state.
          // The reason we use 'pending' is so we can retry
          // replications that fail after an appropriate amount of time.
          //将该block移至pendingReplications（PendingReplicationBlocks）中，表示该block的状态为'pending'(正在备份中)。'pending'表示如果失败了还可以重试
          pendingReplications.add(block, targets.length);
          NameNode.stateChangeLog.debug(
            &quot;BLOCK* block &quot; + block
              + &quot; is moved from neededReplications to pendingReplications&quot;);

          // remove from neededReplications
          //从 neededReplication列表中移除该block
          if (numEffectiveReplicas + targets.length &amp;gt;= requiredReplication) {
            neededReplications.remove(block, priority); // remove from neededReplications
            replIndex[priority]--;
          }
        }
      }
    } finally {
      writeUnlock();
    }

    // 更新 metrics
    updateReplicationMetrics(work);

    // 打印debug信息
    if(NameNode.stateChangeLog.isInfoEnabled()){
      // log which blocks have been scheduled for replication
      for(ReplicationWork rw : work){
        // report scheduled blocks
        DatanodeDescriptor[] targets = rw.targets;
        if (targets != null &amp;amp;&amp;amp; targets.length != 0) {
          StringBuffer targetList = new StringBuffer(&quot;datanode(s)&quot;);
          for (int k = 0; k &amp;lt; targets.length; k++) {
            targetList.append(' ');
            targetList.append(targets[k].getName());
          }
          NameNode.stateChangeLog.info(
            &quot;BLOCK* ask &quot;
              + rw.srcNode.getName() + &quot; to replicate &quot;
              + rw.block + &quot; to &quot; + targetList);
        }
      }
    }

    // 记录一次备份操作
    if (NameNode.stateChangeLog.isDebugEnabled()) {
      NameNode.stateChangeLog.debug(&quot;BLOCK* neededReplications = &quot;
          + neededReplications.size() + &quot; pendingReplications = &quot;
          + pendingReplications.size());
    }
    return scheduledWork;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;1.1.2.1. 选取源datanode —— chooseSourceDatanode（）&lt;/h4&gt;

&lt;p&gt;获取一个源datanode节点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  private DatanodeDescriptor chooseSourceDatanode(
                                    Block block,
                                    List&amp;lt;DatanodeDescriptor&amp;gt; containingNodes,
                                    NumberReplicas numReplicas) {
    containingNodes.clear();
    DatanodeDescriptor srcNode = null;
    int live = 0;
    int decommissioned = 0;
    int corrupt = 0;
    int excess = 0;
    Iterator&amp;lt;DatanodeDescriptor&amp;gt; it = blocksMap.nodeIterator(block);
    Collection&amp;lt;DatanodeDescriptor&amp;gt; nodesCorrupt = corruptReplicas.getNodes(block);
    while(it.hasNext()) {
      DatanodeDescriptor node = it.next();
      Collection&amp;lt;Block&amp;gt; excessBlocks = 
        excessReplicateMap.get(node.getStorageID());
      if ((nodesCorrupt != null) &amp;amp;&amp;amp; (nodesCorrupt.contains(node)))
        corrupt++;
      else if (node.isDecommissionInProgress() || node.isDecommissioned())
        decommissioned++;
      else if (excessBlocks != null &amp;amp;&amp;amp; excessBlocks.contains(block)) {
        excess++;
      } else {
        live++;
      }
      containingNodes.add(node);
      // Check if this replica is corrupt
      // If so, do not select the node as src node
      if ((nodesCorrupt != null) &amp;amp;&amp;amp; nodesCorrupt.contains(node))
        continue;
      if(node.getNumberOfBlocksToBeReplicated() &amp;gt;= maxReplicationStreams)
        continue; // already reached replication limit
      // the block must not be scheduled for removal on srcNode
      if(excessBlocks != null &amp;amp;&amp;amp; excessBlocks.contains(block))
        continue;
      // never use already decommissioned nodes
      if(node.isDecommissioned())
        continue;
      // we prefer nodes that are in DECOMMISSION_INPROGRESS state
      if(node.isDecommissionInProgress() || srcNode == null) {
        srcNode = node;
        continue;
      }
      if(srcNode.isDecommissionInProgress())
        continue;
      // switch to a different node randomly
      // this to prevent from deterministically selecting the same node even
      // if the node failed to replicate the block on previous iterations
      if(r.nextBoolean())
        srcNode = node;
    }
    if(numReplicas != null)
      numReplicas.initialize(live, decommissioned, corrupt, excess);
    return srcNode;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;1.1.2.2. 选取目标datanode —— chooseTarget(rw);&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  private DatanodeDescriptor[] chooseTarget(ReplicationWork work) {
    if (!neededReplications.contains(work.block)) {
      return null;
    }
    if (work.blockSize == BlockCommand.NO_ACK) {
      LOG.warn(&quot;Block &quot; + work.block.getBlockId() + 
          &quot; of the file &quot; + work.fileINode.getFullPathName() + 
          &quot; is invalidated and cannot be replicated.&quot;);
      return null;
    }
    if (work.blockSize == DFSUtil.DELETED) {
      LOG.warn(&quot;Block &quot; + work.block.getBlockId() + 
          &quot; of the file &quot; + work.fileINode.getFullPathName() + 
          &quot; is a deleted block and cannot be replicated.&quot;);
      return null;
    }
    //实际调用replicator(BlockPlacementPolicy)的chooseTarget方法选取target
    return replicator.chooseTarget(work.fileINode,
        work.numOfReplicas, work.srcNode,
        work.containingNodes, null, work.blockSize);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;副本存放策略&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;img/BlockAllocation.png&quot; alt=&quot;BlockAllocation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图所示，HDFS默认的副本存放策略为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;第一个副本存放在当前datanode的本地&lt;/li&gt;
&lt;li&gt;第二个副本存放在与第一个副本所在datanode不在同一机架上的一个datanode上&lt;/li&gt;
&lt;li&gt;第三个副本存放在与第二个副本同一机架但不同datanode上&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>HDFS源码学习(4)——DataNode心跳检测（HeartBeat）</title>
   <link href="http://jiang-bo.github.com/blog/2012/10/18/hdfs-heartbeat"/>
   <updated>2012-10-18T21:38:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/10/18/hdfs-heartbeat</id>
   <content type="html">&lt;p&gt;HDFS中DataNode的心跳检测通过FSNameSystem中的HeartbeatMonitor完成。代码结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  class HeartbeatMonitor implements Runnable {
    /**
     */
    public void run() {
      while (fsRunning) {
        try {
          heartbeatCheck();
        } catch (Exception e) {
          FSNamesystem.LOG.error(StringUtils.stringifyException(e));
        }
        try {
          Thread.sleep(heartbeatRecheckInterval);
        } catch (InterruptedException ie) {
        }
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码很简单，心跳检测线程周期性调用heartbeatCheck()。&lt;/p&gt;

&lt;h2&gt;一、心跳检查——heartbeatCheck()&lt;/h2&gt;

&lt;p&gt;该方法主要用于检测是否有过期的心跳检测，如有，检测其上的block是否已经进行过重新备份。该线程每次只处理一个datanode。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  void heartbeatCheck() {
    if (isInSafeMode()) {
      // 安全模式下不做心跳检测
      return;
    }
    boolean allAlive = false;
    while (!allAlive) {
      boolean foundDead = false;
      DatanodeID nodeID = null;

      // 获取第一个dead datanode
      synchronized(heartbeats) {
        for (Iterator&amp;lt;DatanodeDescriptor&amp;gt; it = heartbeats.iterator();
             it.hasNext();) {
          DatanodeDescriptor nodeInfo = it.next();
          if (isDatanodeDead(nodeInfo)) {
            foundDead = true;
            nodeID = nodeInfo;
            break;
          }
        }
      }

      // 申请fsnamesystem锁，删除dead datanode
      if (foundDead) {
        writeLock();
        try {
          synchronized(heartbeats) {
            synchronized (datanodeMap) {
              DatanodeDescriptor nodeInfo = null;
              try {
                nodeInfo = getDatanode(nodeID);
              } catch (IOException e) {
                nodeInfo = null;
              }
              if (nodeInfo != null &amp;amp;&amp;amp; isDatanodeDead(nodeInfo)) {
                NameNode.stateChangeLog.info(&quot;BLOCK* NameSystem.heartbeatCheck: &quot;
                                             + &quot;lost heartbeat from &quot; + nodeInfo.getName());
                removeDatanode(nodeInfo);
              }
            }
          }
        } finally {
          writeUnlock();
        }
      }
      allAlive = !foundDead;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.1 判断是否已死 —— isDatanodeDead（）&lt;/h3&gt;

&lt;p&gt;判断一个datanode是否已经dead的标准很简单，当前距该节点最后的更新时间差是否已经超过心跳检测的过期时间限制&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private boolean isDatanodeDead(DatanodeDescriptor node) {
    return (node.getLastUpdate() &amp;lt;
            (now() - heartbeatExpireInterval));
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.2 删除datanode —— removeDatanode（）&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;  private void removeDatanode(DatanodeDescriptor nodeInfo) {
    synchronized (heartbeats) {
      if (nodeInfo.isAlive) {
        updateStats(nodeInfo, false);
        //从heartbeats中移除
        heartbeats.remove(nodeInfo);
        //更新datanode状态
        nodeInfo.isAlive = false;
      }
    }

    nodeInfo.hasInitialBlockReport = false;
    for (Iterator&amp;lt;Block&amp;gt; it = nodeInfo.getBlockIterator(); it.hasNext();) {
      //移除该节点上的block
      removeStoredBlock(it.next(), nodeInfo);
    }
    unprotectedRemoveDatanode(nodeInfo);
    clusterMap.remove(nodeInfo);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;1.2.1 removeStoredBlock（）&lt;/h4&gt;

&lt;p&gt;该方法更新block-&gt;datanode的映射(blocksMap)，如果block还有效，有可能导致block备份发生&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  void removeStoredBlock(Block block, DatanodeDescriptor node) {
    if (NameNode.stateChangeLog.isDebugEnabled()) {
      NameNode.stateChangeLog.debug(&quot;BLOCK* NameSystem.removeStoredBlock: &quot;
                                    +block + &quot; from &quot;+node.getName());
    }
    assert (hasWriteLock());
    if (!blocksMap.removeNode(block, node)) {
      if (NameNode.stateChangeLog.isDebugEnabled()) {
        NameNode.stateChangeLog.debug(&quot;BLOCK* NameSystem.removeStoredBlock: &quot;
                                      +block+&quot; has already been removed from node &quot;+node);
      }
      return;
    }

    //
    //检查是否需要备份删除的block
    INode fileINode = blocksMap.getINode(block);
    if (fileINode != null) {
      //减小当前系统中安全block（备份数满足最小值的block）数量
      decrementSafeBlockCount(block);
      //更新需要备份的block数量
      updateNeededReplications(block, -1, 0);
    }

    //
    // 从excessblocks中删除改block，并从excessReplicateMap删除改datanode
    Collection&amp;lt;Block&amp;gt; excessBlocks = excessReplicateMap.get(node.getStorageID());
    if (excessBlocks != null) {
      if (excessBlocks.remove(block)) {
        excessBlocksCount--;
        if (NameNode.stateChangeLog.isDebugEnabled()) {
          NameNode.stateChangeLog.debug(&quot;BLOCK* NameSystem.removeStoredBlock: &quot;
              +block+&quot; is removed from excessBlocks&quot;);
        }
        if (excessBlocks.size() == 0) {
          excessReplicateMap.remove(node.getStorageID());
        }
      }
    }

    // 从corruptReplicas中移除该block
    corruptReplicas.removeFromCorruptReplicasMap(block, node);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;1.2.1.1  BlocksMap.removeNode（）&lt;/h5&gt;

&lt;p&gt;其中BlocksMap.removeNode()方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  boolean removeNode(Block b, DatanodeDescriptor node) {
    BlockInfo info = blocks.get(b);
    if (info == null)
      return false;

    // 从datanode 的blocklist中移除block，并从block的datalist中移除datanode
    boolean removed = node.removeBlock(info);

    if (info.getDatanode(0) == null     // no datanodes left
              &amp;amp;&amp;amp; info.inode == null) {  // does not belong to a file
      //从blocksmap中移除该block
      blocks.remove(b);  // remove block from the map
    }
    return removed;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;1.2.1.2 减小当前安全的block数 —— decrementSafeBlockCount()&lt;/h5&gt;

&lt;p&gt;减小当前副本数安全的的block数，此举有可能触发系统进入安全模式（safemode）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  void decrementSafeBlockCount(Block b) {
    if (safeMode == null) // mostly true
      return;

    safeMode.decrementSafeBlockCount((short)countNodes(b).liveReplicas());
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中safeMode.decrementSafeBlockCount()代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;synchronized void decrementSafeBlockCount(short replication) {

  if (replication == safeReplication-1) {
    //安全的block数减一
    this.blockSafe--;
    //检查是否需要进入到safemode
    checkMode();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SafeModeInfo.checkMode()代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    private void checkMode() {
      //当安全的block数比例降至安全值以下，进入安全模式
      if (needEnter()) {
        enter();
        // check if we are ready to initialize replication queues
        if (canInitializeReplQueues() &amp;amp;&amp;amp; !isPopulatingReplQueues()) {
          //初始化副本队列
          initializeReplQueues();
        }
        reportStatus(&quot;STATE* Safe mode ON.&quot;, false);
        return;
      }
      // 如果安全模式已经关闭或者门槛小于0，则跳出安全模式
      if (!isOn() ||                           // safe mode is off
          extension &amp;lt;= 0 || threshold &amp;lt;= 0) {  // don't need to wait
        this.leave(true); // leave safe mode
        return;
      }

      //之前已经进入安全模式，直接返回
      if (reached &amp;gt; 0) {  // threshold has already been reached before
        reportStatus(&quot;STATE* Safe mode ON.&quot;, false);
        return;
      }
      // 启动SafeModeMonitor线程
      reached = now();
      smmthread = new Daemon(new SafeModeMonitor());
      smmthread.start();
      reportStatus(&quot;STATE* Safe mode extension entered.&quot;, true);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;1.2.1.3 更新需要备份的列表 —— updateNeededReplications（）&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;  /* updates a block in under replication queue */
  void updateNeededReplications(Block block,
                        int curReplicasDelta, int expectedReplicasDelta) {
    writeLock();
    try {
    //计算当前副本数
    NumberReplicas repl = countNodes(block);
    //期望的副本数
    int curExpectedReplicas = getReplication(block);
    //将该block更新到需要备份的列表中（neededReplications）
    neededReplications.update(block, 
                              repl.liveReplicas(), 
                              repl.decommissionedReplicas(),
                              curExpectedReplicas,
                              curReplicasDelta, expectedReplicasDelta);
    } finally {
      writeUnlock();
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;1.2.2 移除datanode —— unprotectedRemoveDatanode&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  void unprotectedRemoveDatanode(DatanodeDescriptor nodeDescr) {
    //重置清空datanode中block信息
    nodeDescr.resetBlocks();
    //从invlidateSet中移除datanode
    removeFromInvalidates(nodeDescr.getStorageID());
    if (NameNode.stateChangeLog.isDebugEnabled()) {
      NameNode.stateChangeLog.debug(
                                    &quot;BLOCK* NameSystem.unprotectedRemoveDatanode: &quot;
                                    + nodeDescr.getName() + &quot; is out of service now.&quot;);
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;1.2.2.1 removeFromInvalidates()&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;  private void removeFromInvalidates(String storageID) {
    //从recentInvalidateSet中移除该datanode
    Collection&amp;lt;Block&amp;gt; blocks = recentInvalidateSets.remove(storageID);
    if (blocks != null) {
      //从正在删除的block总数中减去当前节点上的block总数
      pendingDeletionBlocksCount -= blocks.size();
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;二、 处理心跳检测请求 —— handleHeartbeat()&lt;/h2&gt;

&lt;p&gt;NameNode只负责创建一个HeartbeatMonitor来通过每个datanode的最新更新时间周期性检查是否有过期的datanode，而每个datanode是否的最新更新时间是由datanode主动向namenode报告的，namenode通过handleHeartbeat()处理心跳请求。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  DatanodeCommand[] handleHeartbeat(DatanodeRegistration nodeReg,
      long capacity, long dfsUsed, long remaining,
      int xceiverCount, int xmitsInProgress) throws IOException {
    DatanodeCommand cmd = null;
    synchronized (heartbeats) {
      synchronized (datanodeMap) {
        DatanodeDescriptor nodeinfo = null;
        try {
          nodeinfo = getDatanode(nodeReg);
        } catch(UnregisteredDatanodeException e) {
          return new DatanodeCommand[]{DatanodeCommand.REGISTER};
        }

        // 检查该datanode是否需要被关闭，可以通过设置datanode的adminState为DECOMMISSIONED来关闭一个datanode
        if (nodeinfo != null &amp;amp;&amp;amp; shouldNodeShutdown(nodeinfo)) {
          setDatanodeDead(nodeinfo);
          throw new DisallowedDatanodeException(nodeinfo);
        }

        if (nodeinfo == null || !nodeinfo.isAlive) {
          return new DatanodeCommand[]{DatanodeCommand.REGISTER};
        }

        updateStats(nodeinfo, false);
        nodeinfo.updateHeartbeat(capacity, dfsUsed, remaining, xceiverCount);
        updateStats(nodeinfo, true);

        //检查租约恢复状态
        cmd = nodeinfo.getLeaseRecoveryCommand(Integer.MAX_VALUE);
        if (cmd != null) {
          return new DatanodeCommand[] {cmd};
        }

        ArrayList&amp;lt;DatanodeCommand&amp;gt; cmds = new ArrayList&amp;lt;DatanodeCommand&amp;gt;(2);
        //检查正在备份中的副本
        cmd = nodeinfo.getReplicationCommand(
              maxReplicationStreams - xmitsInProgress);
        if (cmd != null) {
          cmds.add(cmd);
        }
        //检查无效的block
        cmd = nodeinfo.getInvalidateBlocks(blockInvalidateLimit);
        if (cmd != null) {
          cmds.add(cmd);
        }
        if (!cmds.isEmpty()) {
          return cmds.toArray(new DatanodeCommand[cmds.size()]);
        }
      }
    }

    //检查是否需要升级系统
    cmd = getDistributedUpgradeCommand();
    if (cmd != null) {
      return new DatanodeCommand[] {cmd};
    }
    return null;
  }
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>HDFS源码学习（3）——NameNode中的线程</title>
   <link href="http://jiang-bo.github.com/blog/2012/10/18/hdfs-namenode-thread"/>
   <updated>2012-10-18T21:37:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/10/18/hdfs-namenode-thread</id>
   <content type="html">&lt;p&gt;NameNode存在三种运行模式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Normal： NameNode正常服务的状态&lt;/li&gt;
&lt;li&gt;Safe mode：NameNode重启时进入Safe mode，该模式下整个系统是只读的，以便于NameNode手机DataNode信息&lt;/li&gt;
&lt;li&gt;Backup mode：备份NameNode处于Backup mode，被动的接收主NameNode的检查点信息&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;在NameNode中存在如下几种线程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;DataNode 健康检查管理线程&lt;/li&gt;
&lt;li&gt;副本管理线程&lt;/li&gt;
&lt;li&gt;租约管理（lease Management）&lt;/li&gt;
&lt;li&gt;IPC Handler 线程&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>HDFS源码学习(2)——NameNode初始化</title>
   <link href="http://jiang-bo.github.com/blog/2012/10/18/hdfs-namenode-startup"/>
   <updated>2012-10-18T21:35:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/10/18/hdfs-namenode-startup</id>
   <content type="html">&lt;h2&gt;main()&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;  public static void main(String argv[]) throws Exception {
    try {
      StringUtils.startupShutdownMessage(NameNode.class, argv, LOG);
      //创建nameNode
      NameNode namenode = createNameNode(argv, null);
      if (namenode != null)
        namenode.join();
    } catch (Throwable e) {
      LOG.error(StringUtils.stringifyException(e));
      System.exit(-1);
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;createNameNode()&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;  public static NameNode createNameNode(String argv[], 
                                 Configuration conf) throws IOException {
    if (conf == null)
      conf = new Configuration();
      //从命令行参数中提取启动配置项数据
    StartupOption startOpt = parseArguments(argv);
    if (startOpt == null) {
      printUsage();
      return null;
    }
    //设置启动参数
    setStartupOption(conf, startOpt);

    switch (startOpt) {
      case FORMAT:
        boolean aborted = format(conf, true);
        System.exit(aborted ? 1 : 0);
      case FINALIZE:
        aborted = finalize(conf, true);
        System.exit(aborted ? 1 : 0);
      default:
    }

    //新建NameNode
    NameNode namenode = new NameNode(conf);
    return namenode;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;NameNode()&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;  public NameNode(Configuration conf) throws IOException {
    super(conf);
    try {
    //初始化
      initialize(getConf());
    } catch (IOException e) {
      this.stop();
      throw e;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;initialize()&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;  private void initialize(Configuration conf) throws IOException {
    InetSocketAddress socAddr = NameNode.getAddress(conf);
    int handlerCount = conf.getInt(&quot;dfs.namenode.handler.count&quot;, 10);
    // 关键-&amp;gt;创建一个RPC Server
    this.server = RPC.getServer(this, socAddr.getHostName(), socAddr.getPort(),
                                handlerCount, false, conf);

    // The rpc-server port can be ephemeral... ensure we have the correct info
    this.serverAddress = this.server.getListenerAddress(); 
    FileSystem.setDefaultUri(conf, getUri(serverAddress));
    LOG.info(&quot;Namenode up at: &quot; + this.serverAddress);

    myMetrics = new NameNodeMetrics(conf, this);

    //关键-&amp;gt;创建一个FSNameSystem
    this.namesystem = new FSNamesystem(this, conf);
    //启动HTTP Server
    startHttpServer(conf);
    //启动RPC Server
    this.server.start();  //start RPC server   

    startTrashEmptier(conf);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;FSNameSystem()&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;  FSNamesystem(NameNode nn, Configuration conf) throws IOException {
    try {
      //初始化FSNameSystem
      initialize(nn, conf);
      userPasswordInformation = new UserPasswordInformation(conf);
      extendAccessControlList = new ExtendAccessControlList(conf);
    } catch(IOException e) {
      LOG.error(getClass().getSimpleName() + &quot; initialization failed.&quot;, e);
      close();
      throw e;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;FSNameSystem.initialize()&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;  private void initialize(NameNode nn, Configuration conf) throws IOException {
    this.systemStart = now();
    this.fsLock = new ReentrantReadWriteLock(); // non-fair locking
    setConfigurationParameters(conf);

    this.nameNodeAddress = nn.getNameNodeAddress();
    this.registerMBean(conf); // register the MBean for the FSNamesystemStutus

    //创建FSDirectory
    this.dir = new FSDirectory(this, conf);
    StartupOption startOpt = NameNode.getStartupOption(conf);

    //加载FSImage
    this.dir.loadFSImage(getNamespaceDirs(conf),
                         getNamespaceEditsDirs(conf), startOpt);
    long timeTakenToLoadFSImage = now() - systemStart;
    LOG.info(&quot;Finished loading FSImage in &quot; + timeTakenToLoadFSImage + &quot; msecs&quot;);
    NameNode.getNameNodeMetrics().fsImageLoadTime.set(
                              (int) timeTakenToLoadFSImage);
    this.safeMode = new SafeModeInfo(conf);
    setBlockTotal();
    //创建PendingReplicationBlocks
    pendingReplications = new PendingReplicationBlocks(
                            conf.getInt(&quot;dfs.replication.pending.timeout.sec&quot;, 
                                        -1) * 1000L);
    //创建心跳检查线程                                          
    this.hbthread = new Daemon(new HeartbeatMonitor());
    //创建租约管理线程
    this.lmthread = new Daemon(leaseManager.new Monitor());
    //创建副本管理线程
    this.replthread = new Daemon(new ReplicationMonitor());
    hbthread.start();
    lmthread.start();
    replthread.start();

    // 副本超额block管理线程
    this.overreplthread = new Daemon(new OverReplicationMonitor());
    overreplthread.start();

    this.hostsReader = new HostsFileReader(conf.get(&quot;dfs.hosts&quot;,&quot;&quot;),
                                           conf.get(&quot;dfs.hosts.exclude&quot;,&quot;&quot;));
    //创建退役节点管理线程
    this.dnthread = new Daemon(new DecommissionManager(this).new Monitor(
        conf.getInt(&quot;dfs.namenode.decommission.interval&quot;, 30),
        conf.getInt(&quot;dfs.namenode.decommission.nodes.per.interval&quot;, 5)));
    dnthread.start();

    this.dnsToSwitchMapping = ReflectionUtils.newInstance(
        conf.getClass(&quot;topology.node.switch.mapping.impl&quot;, ScriptBasedMapping.class,
            DNSToSwitchMapping.class), conf);

    /* If the dns to swith mapping supports cache, resolve network 
     * locations of those hosts in the include list, 
     * and store the mapping in the cache; so future calls to resolve
     * will be fast.
     */
    if (dnsToSwitchMapping instanceof CachedDNSToSwitchMapping) {
      dnsToSwitchMapping.resolve(new ArrayList&amp;lt;String&amp;gt;(hostsReader.getHosts()));
    }
    //创建副本定位器用于定位副本存放位置
    this.replicator = BlockPlacementPolicy.getInstance(
        conf,
        this,
        this.clusterMap,
        this.hostsReader,
        this.dnsToSwitchMapping,
        this);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;FSDirectory(this, conf)&lt;/h2&gt;

&lt;p&gt;新建FSDirecotry&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; FSDirectory(FSNamesystem ns, Configuration conf) {
    //创建一个FSImage，并实例化构建FSDirectory
    this(new FSImage(), ns, conf);
    fsImage.setCheckpointDirectories(FSImage.getCheckpointDirs(conf, null),
                                FSImage.getCheckpointEditsDirs(conf, null));
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;this(new FSImage(), ns, conf);&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;FSDirectory(FSImage fsImage, FSNamesystem ns, Configuration conf) {
    this.bLock = new ReentrantReadWriteLock(); // non-fair
    this.cond = bLock.writeLock().newCondition();
    //创建根目录
    rootDir = new INodeDirectoryWithQuota(INodeDirectory.ROOT_NAME,
        ns.createFsOwnerPermissions(new FsPermission((short)0755)),
        Integer.MAX_VALUE, -1);
    this.fsImage = fsImage;
    namesystem = ns;
    initialize(conf);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;FSDirectory.initialize()&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;  private void initialize(Configuration conf) {
    MetricsContext metricsContext = MetricsUtil.getContext(&quot;dfs&quot;);
    directoryMetrics = MetricsUtil.createRecord(metricsContext, &quot;FSDirectory&quot;);
    directoryMetrics.setTag(&quot;sessionId&quot;, conf.get(&quot;session.id&quot;));
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;FSDirectory.loadFSImage()&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;  void loadFSImage(Collection&amp;lt;File&amp;gt; dataDirs,
                   Collection&amp;lt;File&amp;gt; editsDirs,
                   StartupOption startOpt) throws IOException {
    // format before starting up if requested
    if (startOpt == StartupOption.FORMAT) {
      fsImage.setStorageDirectories(dataDirs, editsDirs);
      fsImage.format();
      startOpt = StartupOption.REGULAR;
    }
    try {
      //从datadir和editdirs加载FSImage
      if (fsImage.recoverTransitionRead(dataDirs, editsDirs, startOpt)) {
        fsImage.saveNamespace(true);
      }
      //初始化Editlog
      FSEditLog editLog = fsImage.getEditLog();
      assert editLog != null : &quot;editLog must be initialized&quot;;
      if (!editLog.isOpen())
        editLog.open();
      fsImage.setCheckpointDirectories(null, null);
    } catch(IOException e) {
      fsImage.close();
      throw e;
    }
    writeLock();
    try {
      this.ready = true;
      cond.signalAll();
    } finally {
      writeUnlock();
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;FSImage.recoverTransitionRead（）&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;  boolean recoverTransitionRead(Collection&amp;lt;File&amp;gt; dataDirs,
                             Collection&amp;lt;File&amp;gt; editsDirs,
                                StartupOption startOpt
                                ) throws IOException {
    assert startOpt != StartupOption.FORMAT : 
      &quot;NameNode formatting should be performed before reading the image&quot;;

    // none of the data dirs exist
    if (dataDirs.size() == 0 || editsDirs.size() == 0)  
      throw new IOException(
        &quot;All specified directories are not accessible or do not exist.&quot;);

    if(startOpt == StartupOption.IMPORT 
        &amp;amp;&amp;amp; (checkpointDirs == null || checkpointDirs.isEmpty()))
      throw new IOException(&quot;Cannot import image from a checkpoint. &quot;
                          + &quot;\&quot;fs.checkpoint.dir\&quot; is not set.&quot; );

    if(startOpt == StartupOption.IMPORT 
        &amp;amp;&amp;amp; (checkpointEditsDirs == null || checkpointEditsDirs.isEmpty()))
      throw new IOException(&quot;Cannot import image from a checkpoint. &quot;
                          + &quot;\&quot;fs.checkpoint.edits.dir\&quot; is not set.&quot; );

    setStorageDirectories(dataDirs, editsDirs);
    // 1.检查所有目录的状态和一致性
    Map&amp;lt;StorageDirectory, StorageState&amp;gt; dataDirStates = 
             new HashMap&amp;lt;StorageDirectory, StorageState&amp;gt;();
    boolean isFormatted = false;
    for (Iterator&amp;lt;StorageDirectory&amp;gt; it = 
                      dirIterator(); it.hasNext();) {
      StorageDirectory sd = it.next();
      StorageState curState;
      try {
        curState = sd.analyzeStorage(startOpt);
        // sd is locked but not opened
        switch(curState) {
        case NON_EXISTENT:
          // name-node fails if any of the configured storage dirs are missing
          throw new InconsistentFSStateException(sd.getRoot(),
                                                 &quot;storage directory does not exist or is not accessible.&quot;);
        case NOT_FORMATTED:
          break;
        case NORMAL:
          break;
        default:  // recovery is possible
          sd.doRecover(curState);      
        }
        if (curState != StorageState.NOT_FORMATTED 
            &amp;amp;&amp;amp; startOpt != StartupOption.ROLLBACK) {
          sd.read(); // read and verify consistency with other directories
          isFormatted = true;
        }
        if (startOpt == StartupOption.IMPORT &amp;amp;&amp;amp; isFormatted)
          // import of a checkpoint is allowed only into empty image directories
          throw new IOException(&quot;Cannot import image from a checkpoint. &quot; 
              + &quot; NameNode already contains an image in &quot; + sd.getRoot());
      } catch (IOException ioe) {
        sd.unlock();
        throw ioe;
      }
      dataDirStates.put(sd,curState);
    }

    if (!isFormatted &amp;amp;&amp;amp; startOpt != StartupOption.ROLLBACK 
                     &amp;amp;&amp;amp; startOpt != StartupOption.IMPORT)
      throw new IOException(&quot;NameNode is not formatted.&quot;);
    if (layoutVersion &amp;lt; LAST_PRE_UPGRADE_LAYOUT_VERSION) {
      checkVersionUpgradable(layoutVersion);
    }
    if (startOpt != StartupOption.UPGRADE
          &amp;amp;&amp;amp; layoutVersion &amp;lt; LAST_PRE_UPGRADE_LAYOUT_VERSION
          &amp;amp;&amp;amp; layoutVersion != FSConstants.LAYOUT_VERSION)
        throw new IOException(
                          &quot;\nFile system image contains an old layout version &quot; + layoutVersion
                          + &quot;.\nAn upgrade to version &quot; + FSConstants.LAYOUT_VERSION
                          + &quot; is required.\nPlease restart NameNode with -upgrade option.&quot;);
    // check whether distributed upgrade is reguired and/or should be continued
    verifyDistributedUpgradeProgress(startOpt);

    // 2. Format unformatted dirs.
    this.checkpointTime = 0L;
    for (Iterator&amp;lt;StorageDirectory&amp;gt; it = 
                     dirIterator(); it.hasNext();) {
      StorageDirectory sd = it.next();
      StorageState curState = dataDirStates.get(sd);
      switch(curState) {
      case NON_EXISTENT:
        assert false : StorageState.NON_EXISTENT + &quot; state cannot be here&quot;;
      case NOT_FORMATTED:
        LOG.info(&quot;Storage directory &quot; + sd.getRoot() + &quot; is not formatted.&quot;);
        LOG.info(&quot;Formatting ...&quot;);
        sd.clearDirectory(); // create empty currrent dir
        break;
      default:
        break;
      }
    }
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>HDFS源码学习（1）——NameNode主要数据结构</title>
   <link href="http://jiang-bo.github.com/blog/2012/10/18/hdfs-namenode-datastructure"/>
   <updated>2012-10-18T11:04:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/10/18/hdfs-namenode-datastructure</id>
   <content type="html">&lt;h2&gt;FSNameSystem&lt;/h2&gt;

&lt;p&gt;FSNameSystem是HDFS文件系统实际执行的核心，提供各种增删改查文件操作接口。其内部维护多个数据结构之间的关系：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;fsname-&gt;block列表的映射&lt;/li&gt;
&lt;li&gt;所有有效blocks集合&lt;/li&gt;
&lt;li&gt;block与其所属的datanodes之间的映射（该映射是通过block reports动态构建的，维护在namenode的内存中。每个datanode在启动时向namenode报告其自身node上的block）&lt;/li&gt;
&lt;li&gt;每个datanode与其上的blocklist的映射&lt;/li&gt;
&lt;li&gt;采用心跳检测根据LRU算法更新的机器（datanode）列表&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;FSDirectory&lt;/h3&gt;

&lt;p&gt;FSDirectory用于维护当前系统中的文件树。&lt;/p&gt;

&lt;p&gt;其内部主要组成结构包括一个INodeDirectoryWithQuota作为根目录(rootDir)和一个FSImage来持久化文件树的修改操作。&lt;/p&gt;

&lt;h4&gt;INode&lt;/h4&gt;

&lt;p&gt;HDFS中文件树用类似VFS中INode的方式构建，整个HDFS中文件被表示为INodeFile，目录被表示为INodeDirectory。INodeDiretoryWithQuota是INodeDirectory的扩展类，即带配额的文件目录&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/INode.png&quot; alt=&quot;INode&quot; /&gt;&lt;/p&gt;

&lt;p&gt;INodeFile表示INode书中的一个文件，扩展自INode，除了名字(name)，父节点(parent)等之外，一个主要元素是blocks，一个BlockInfo数组，表示该文件对应的block信息。&lt;/p&gt;

&lt;h3&gt;BlocksMap&lt;/h3&gt;

&lt;p&gt;BlocksMap用于维护Block -&gt; { INode, datanodes, self ref } 的映射
&lt;img src=&quot;/images/hdfs/BlocksMap.png&quot; alt=&quot;BlocksMap&quot; /&gt;
BlocksMap结构比较简单，实际上就是一个Block到BlockInfo的映射。&lt;/p&gt;

&lt;h4&gt;Block&lt;/h4&gt;

&lt;p&gt;Block是HDFS中的基本读写单元，主要包括：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;blockId: 一个long类型的块id&lt;/li&gt;
&lt;li&gt;numBytes: 块大小&lt;/li&gt;
&lt;li&gt;generationStamp: 块更新的时间戳&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;BlockInfo&lt;/h4&gt;

&lt;p&gt;BlockInfo扩展自Block，除基本信息外还包括一个inode引用，表示该block所属的文件；以及一个神奇的三元组数组Object[] triplets，用来表示保存该block的datanode信息，假设系统中的备份数量为3。那么这个数组结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/triplets.png&quot; alt=&quot;triplets&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;DN1，DN2，DN3分别表示存有改block的三个datanode的引用(DataNodeDescriptor）&lt;/li&gt;
&lt;li&gt;DN1-prev-blk表示在DN1上block列表中当前block的前置block引用&lt;/li&gt;
&lt;li&gt;DN1-next-blk表示在DN1上block列表中当前block的后置block引用&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;DN2,DN3的prev-blk和next-blk类似。
HDFS采用这种结构存放block-&gt;datanode list的信息主要是为了节省内存空间，block-&gt;datanodelist之间的映射关系需要占用大量内存，如果同样还要将datanode-&gt;blockslist的信息保存在内存中，同样要占用大量内存。采用三元组这种方式能够从其中一个block获得到改block所属的datanode上的所有block列表。&lt;/p&gt;

&lt;h4&gt;FSImage&lt;/h4&gt;

&lt;p&gt;FSImage用于持久化文件树的变更以及系统启动时加载持久化数据。
HDFS启动时通过FSImage来加载磁盘中原有的文件树，系统Standby之后，通过FSEditlog来保存在文件树上的修改，FSEditLog定期将保存的修改信息刷到FSImage中进行持久化存储。
FSImage中文件元信息的存储结构如下（参见FImage.saveFSImage()方法）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hdfs/FSImage.png&quot; alt=&quot;FSImage&quot; /&gt;&lt;/p&gt;

&lt;h5&gt;FSImage头部信息&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;layoutVersion(int):image layout版本号，0.19版本的hdfs中为-18&lt;/li&gt;
&lt;li&gt;namespaceId(int): 命名空间ID，系统初始化时生成，在一个namenode生命周期内保持不变，datanode想namenode注册是返回改id作为registerId，以后每次datanode与namenode通信时都携带该id，不认识的id的请求将被拒绝。&lt;/li&gt;
&lt;li&gt;numberItemOfTree(long): 系统中的文件总数&lt;/li&gt;
&lt;li&gt;generationTimeStamp: 生成image的时间戳&lt;/li&gt;
&lt;/ol&gt;


&lt;h5&gt;INode信息&lt;/h5&gt;

&lt;p&gt;FSImage头之后是numberItemOfTree个INode信息，INode信息分为文件(INodeFile)和文件目录(INodeDirectory)两类，两者大体一致，分为INode头，Blocks区（目录没有blocks）和文件权限。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;INode头&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;nameLen(short): 文件名长度&lt;/li&gt;
&lt;li&gt;filename(String): 文件名&lt;/li&gt;
&lt;li&gt;replication(short): 备份数量&lt;/li&gt;
&lt;li&gt;modificationTime(long): 最近修改时间&lt;/li&gt;
&lt;li&gt;accessTime(long): 最近访问时间&lt;/li&gt;
&lt;li&gt;preferedBlockSize(long): 块大小（目录为0）&lt;/li&gt;
&lt;li&gt;block num(int): 块数量（目录为-1）&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;Blocks区&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;blockId(long)&lt;/li&gt;
&lt;li&gt;numBytes(long,block大小)&lt;/li&gt;
&lt;li&gt;generationTimeStamp(long, 更新时间戳）&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;文件权限&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;username(String): 文件用户名&lt;/li&gt;
&lt;li&gt;group(String): 所属组&lt;/li&gt;
&lt;li&gt;fileperm(short): 文件权限&lt;/li&gt;
&lt;/ol&gt;


&lt;h5&gt;underconstructionFile区&lt;/h5&gt;

&lt;p&gt;layoutverion&amp;lt;-18版本的fsimage还包括正在构建的文件区。与普通Inode信息类似，均有inode头和blocks区以及文件权限，除此之外，underConstructionFile还包括：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;client信息&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;clientName：client明&lt;/li&gt;
&lt;li&gt;clientMachine： client机器名&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;已分配的datanode信息&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ipcport： 服务端口&lt;/li&gt;
&lt;li&gt;capacity: 容量&lt;/li&gt;
&lt;li&gt;dfsuse： 已使用的空间&lt;/li&gt;
&lt;li&gt;remaining： 剩余空间&lt;/li&gt;
&lt;li&gt;lastupdate： 最新更新时间&lt;/li&gt;
&lt;li&gt;xceiverCount&lt;/li&gt;
&lt;li&gt;location： datanode位置&lt;/li&gt;
&lt;li&gt;hostName：主机名&lt;/li&gt;
&lt;li&gt;state： admin管理状态&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;其他结构&lt;/h2&gt;

&lt;h3&gt;CorruptReplicasMap&lt;/h3&gt;

&lt;p&gt;CorruptReplicasMap通过一个TreeMap维护corrupt状态block的blocks--&gt;datanodedescriptor(s)映射。一个block备份在多个datanode中，当其中的一个或多个datanode上的block损坏时，会将该datanode加到treeMap中该block对应的datanodeDescriptor集合中。FSNameSystem通过该Map来维护所有损坏的block与其对应datanode的关系。&lt;/p&gt;

&lt;h3&gt;Map&amp;lt;String, LightWeightHashSet&lt;Block&gt;&gt; recentInvalidateSets&lt;/h3&gt;

&lt;p&gt;维护最近失效的block集合，map中为storageId-&gt;ArrayList&lt;Block&gt;，当某个block的一个datanode上副本失效时会将改block和对应的datanode的storeageId添加到recentInvalidateSet中，当datanode想namenode进行heartbeat时，namenode会检查该datanode中是否有损坏的block，如有，则通知datanode删除改block。&lt;/p&gt;

&lt;h3&gt;NavigableMap&amp;lt;String, DatanodeDescriptor&gt;  datanodeMap&lt;/h3&gt;

&lt;p&gt;datanodeMap用于维护datanode-&gt;block的映射&lt;/p&gt;

&lt;h3&gt;ArrayList&lt;DatanodeDescriptor&gt; heartbeats&lt;/h3&gt;

&lt;p&gt;维护多有当前活着的节点&lt;/p&gt;

&lt;h3&gt;UnderReplicatedBlocks neededReplications&lt;/h3&gt;

&lt;p&gt;通过一个优先级队列来维护当前需要备份的block集合，副本数越少的block优先级越高，0为最高级，表示当前只有一个副本。&lt;/p&gt;

&lt;h3&gt;PendingReplicationBlocks pendingReplications;&lt;/h3&gt;

&lt;p&gt;维护当前正在备份的block集合，并且进行备份请求的时间统计，并通过一个后台线程（PendingReplicationMonitor）来周期性（默认为5分钟）的统计超时的备份请求，当发生超时时，会将这个block重新添加到neededReplications列表中。
&lt;img src=&quot;/images/hdfs/PendingReplicationBlocks.png&quot; alt=&quot;PendingReplicationBlocks&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;LightWeightLinkedSet&lt;Block&gt; overReplicatedBlocks&lt;/h3&gt;

&lt;p&gt;当前需要检查是否备份过多的block集合&lt;/p&gt;

&lt;h3&gt;Map&amp;lt;String, Collection&lt;Block&gt;&gt; excessReplicateMap&lt;/h3&gt;

&lt;p&gt;维护系统中datanode与其上的超额备份block的集合，这些超额的备份将被删除。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>本地编译Hadoop小记</title>
   <link href="http://jiang-bo.github.com/blog/2012/09/24/compile-hadoop"/>
   <updated>2012-09-24T15:28:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/09/24/compile-hadoop</id>
   <content type="html">&lt;h2&gt;Git源码&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git clone git://git.apache.org/hadoop-common.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;视网速不通，略慢&lt;/p&gt;

&lt;h2&gt;编译&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;cd hadoop-common
mvn install -DskipTests
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;抛异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[ERROR] Failed to execute goal org.apache.maven.plugins:maven-antrun-plugin:1.6:run (compile-proto) on project hadoop-common: An Ant BuildException has occured: exec returned: 127 -&amp;gt; [Help 1]
org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.maven.plugins:maven-antrun-plugin:1.6:run (compile-proto) on project hadoop-common: An Ant BuildException has occured: exec returned: 127
    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:217)
    at... 
    Caused by: /Users/Shared/Workspace/hadoop/hadoop-common/hadoop-common-project/hadoop-common/target/antrun/build-main.xml:23: exec returned: 127
    at org.apache.tools.ant.taskdefs.ExecTask.runExecute(ExecTask.java:650)
    at org.apache.tools.ant.taskdefs.ExecTask.runExec(ExecTask.java:676)
    at org.apache.tools.ant.taskdefs.ExecTask.execute(ExecTask.java:502)
    at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)
    at sun.reflect.GeneratedMethodAccessor16.invoke(Unknown Source)
    ... 21 more
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原因是缺少protocol buffer， 找不到protoc命令。&lt;/p&gt;

&lt;h3&gt;安装protocol buffer&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;wget https://protobuf.googlecode.com/files/protobuf-2.4.1.tar.bz2
tar -xvf protobuf-2.4.1.tar.bz2
cd protobuf-2.4.1
./configure &amp;amp;&amp;amp; make
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;导入Eclipse&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;mvn eclipse:eclipse -DdownloadSources=true -DdownloadJavadocs=true
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>关于Memcache内存管理模型的理解</title>
   <link href="http://jiang-bo.github.com/blog/2012/08/31/something-about-memcache-internal"/>
   <updated>2012-08-31T07:52:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/08/31/something-about-memcache-internal</id>
   <content type="html">&lt;script async class=&quot;speakerdeck-embed&quot; data-id=&quot;504049be5ec53c000202daa6&quot; data-ratio=&quot;1.299492385786802&quot; src=&quot;//speakerdeck.com/assets/embed.js&quot;&gt;&lt;/script&gt;


&lt;h2&gt;说在前面&lt;/h2&gt;

&lt;p&gt;本文不包含为什么使用memcache，以及如何使用memcache等基础知识。相关知识请查阅各类手册。
另，为便于理解，最好手头准备一份memcache的源码，本文使用的是目前最新的1.4.4版本源码，可自行到github上clone。&lt;/p&gt;

&lt;h2&gt;Item、Chunk、Page、Slab&lt;/h2&gt;

&lt;h3&gt;Data Item&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;+---------------------------------------+
|  key-value | cas | suffix | item head |  
+---------------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Item指实际存放到memcache中的数据对象结构，除key-value数据外，还包括memcache自身对数据对象的描述信息（Item=key+value+后缀长+32byte结构体）&lt;/p&gt;

&lt;h3&gt;Chunk&lt;/h3&gt;

&lt;p&gt;Chunk指Memcache用来存放Data Item的最小单元，同一个Slab中的chunk大小是固定的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+------------------------------+
|   data item    | empty space |
+------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Page&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;+-------------------------------------+
|  chunk1 | chunk2 | chunk3 | chunk4  |
+-------------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个Slab中按照Page来申请内存，Page的大小默认为1M，可以通过-l参数调整，最小1k，最大128m.&lt;/p&gt;

&lt;h3&gt;Slab&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;+--------------------------------+
|  Page1 | Page2 | Page3 | Page4 |
+--------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Memcache将分配给它的内存（-m 参数指定，默认64m）按照Chunk大小不同，划分为多个slab。&lt;/p&gt;

&lt;p&gt;他们三者的关系如下图所示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                 Chunk
                   ^                                                         
+------------------|------------------------------------------------------------+
|   Memory         |                                                            | 
|  +---------------|---------------------------------------------------------+  |
|  |      +--------|---------------------+  +------------------------------+ |  |
|  |      |Page1 +-|---+ +-----+ +-----+ |  |Page2 +-----+ +-----+ +-----+ | |  |
|  | Slab |(1M)  | 96B | | 68B | | 72B | |  |(1M)  | 92B | | 76B | | 84B | | |  | 
|  |  1   |      +-----+ +-----+ +-----+ |  |      +-----+ +-----+ +-----+ | |  |
|  |      +------------------------------+  +------------------------------+ |  |
|  +-------------------------------------------------------------------------+  |
|                                                                               |
|  +-------------------------------------------------------------------------+  |
|  |      +------------------------------+  +------------------------------+ |  |
|  |      |Page1 +------+    +------+    |  |Page2 +------+    +-------+   | |  |
|  | Slab | (1M) | 128B |    | 120B |    |  |(1M)  | 128B |    | 97B   |   | |  |
|  |   2  |      +------+    +------+    |  |      +------+    +-------+   | |  |
|  |      +------------------------------+  +------------------------------+ |  |
|  +-------------------------------------------------------------------------+  |
+-------------------------------------------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Slab内存分配&lt;/h2&gt;

&lt;h3&gt;slab初始化&lt;/h3&gt;

&lt;p&gt;Memcache启动时会进行slab初始化（参见slabs.c中slabs_init()函数），默认最小的chunksize为80（查看源码会发现settings中chunk_size默认为48，但是实际还需要加上一个32bytes的item结构体），可以通过-n参数调整，按照然后按照factor（默认为1.25，可以通过-f参数调整）(_关于参数更多的memcache默认参数可以参考memcache.c中settings的设置_)比例递增，划分出多个不同chunk大小的slab空间，即slab1的chunk大小=80，slab2的chunk大小为80*1.25=100，slab3的chunk大小为80*1.25*1.25=125，但最大一个一个chunk不会大于一个Page的大小（默认1M）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;一下代码节选自 slabs.c
 95 void slabs_init(const size_t limit, const double factor, const bool prealloc) {
 96     int i = POWER_SMALLEST - 1;
 97     unsigned int size = sizeof(item) + settings.chunk_size;
 98  
 99     mem_limit = limit;
100  
101     if (prealloc) {
102         /* Allocate everything in a big chunk with malloc */
103         mem_base = malloc(mem_limit);
104         if (mem_base != NULL) {
105             mem_current = mem_base;
106             mem_avail = mem_limit;
107         } else {
108             fprintf(stderr, &quot;Warning: Failed to allocate requested memory in&quot;
109                     &quot; one large chunk.\nWill allocate in smaller chunks\n&quot;);
110         }
111     }
112  
113     memset(slabclass, 0, sizeof(slabclass));
114  
115     while (++i &amp;lt; POWER_LARGEST &amp;amp;&amp;amp; size &amp;lt;= settings.item_size_max / factor) {
116         /* Make sure items are always n-byte aligned */
117         if (size % CHUNK_ALIGN_BYTES)
118             size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);
119  
120         slabclass[i].size = size;
121         slabclass[i].perslab = settings.item_size_max / slabclass[i].size;
122         size *= factor;
123         if (settings.verbose &amp;gt; 1) {
124             fprintf(stderr, &quot;slab class %3d: chunk size %9u perslab %7u\n&quot;,
125                     i, slabclass[i].size, slabclass[i].perslab);
126         }
127     }
128  
129     power_largest = i;
130     slabclass[power_largest].size = settings.item_size_max;
131     slabclass[power_largest].perslab = 1;
132     if (settings.verbose &amp;gt; 1) {
133         fprintf(stderr, &quot;slab class %3d: chunk size %9u perslab %7u\n&quot;,
134                 i, slabclass[i].size, slabclass[i].perslab);
135     }
136  
137     /* for the test suite:  faking of how much we've already malloc'd */
138     {
139         char *t_initial_malloc = getenv(&quot;T_MEMD_INITIAL_MALLOC&quot;);
140         if (t_initial_malloc) {
141             mem_malloced = (size_t)atol(t_initial_malloc);
142         }
143  
144     }
145  
146     if (prealloc) {
147         slabs_preallocate(power_largest);
148     }
149 }                             
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PS：prealloc指的是直接申请一个大的chunk存放所有数据，默认是不采用这种方式的。&lt;/p&gt;

&lt;h3&gt;数据存储过程&lt;/h3&gt;

&lt;p&gt;一个数据项的大致存储量过程可以理解为（完整代码较长，不在粘贴，具体可参见items.c中do_item_alloc()方法）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;构造一个数据项结构体，计算数据项的大小，（假设默认配置下，数据项大小为102B）&lt;/li&gt;
&lt;li&gt;根据数据项的大小，找到最合适的slab，（100&amp;lt;102&amp;lt;125，所以存储在slab3中）&lt;/li&gt;
&lt;li&gt;检查该slab中是否有过期的数据，如有清理掉&lt;/li&gt;
&lt;li&gt;如果没有过期的数据项，则从当前slab中申请空间，参见slabs.c中slab_alloc()方法。&lt;/li&gt;
&lt;li&gt;如果当前slab中申请失败，则尝试根据LRU算法逐出一个数据项，默认memcache是允许逐出的，如果被设置为禁止逐出，那么这是会反生悲剧的oom了&lt;/li&gt;
&lt;li&gt;获取到item空间后将数据存储到改空间中，并追加到该slab的item列表中&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;一个slab的申请一个chunk空间的过程大致如下（以下代码节选自slabs.c）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;195 static int do_slabs_newslab(const unsigned int id) { 
196     slabclass_t *p = &amp;amp;slabclass[id];
197     int len = settings.slab_reassign ? settings.item_size_max
198         : p-&amp;gt;size * p-&amp;gt;perslab;
199     char *ptr;             
200            
201     if ((mem_limit &amp;amp;&amp;amp; mem_malloced + len &amp;gt; mem_limit &amp;amp;&amp;amp; p-&amp;gt;slabs &amp;gt; 0) ||
202         (grow_slab_list(id) == 0) ||    
203         ((ptr = memory_allocate((size_t)len)) == 0)) {
204            
205         MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);
206         return 0;          
207     }      
208            
209     memset(ptr, 0, (size_t)len);    
210     split_slab_page_into_freelist(ptr, id);
211            
212     p-&amp;gt;slab_list[p-&amp;gt;slabs++] = ptr; 
213     mem_malloced += len;   
214     MEMCACHED_SLABS_SLABCLASS_ALLOCATE(id);
215            
216     return 1;              
217 }
218  
219 /*@null@*/ 
220 static void *do_slabs_alloc(const size_t size, unsigned int id) {
221     slabclass_t *p;        
222     void *ret = NULL;      
223     item *it = NULL;       
224  
225     if (id &amp;lt; POWER_SMALLEST || id &amp;gt; power_largest) {
226         MEMCACHED_SLABS_ALLOCATE_FAILED(size, 0);
227         return NULL;
228     }
229  
230     p = &amp;amp;slabclass[id];
231     assert(p-&amp;gt;sl_curr == 0 || ((item *)p-&amp;gt;slots)-&amp;gt;slabs_clsid == 0);
232  
233     /* fail unless we have space at the end of a recently allocated page,
234        we have something on our freelist, or we could allocate a new page */
235     if (! (p-&amp;gt;sl_curr != 0 || do_slabs_newslab(id) != 0)) {
236         /* We don't have more memory available */
237         ret = NULL;
238     } else if (p-&amp;gt;sl_curr != 0) {
239         /* return off our freelist */
240         it = (item *)p-&amp;gt;slots;
241         p-&amp;gt;slots = it-&amp;gt;next;
242         if (it-&amp;gt;next) it-&amp;gt;next-&amp;gt;prev = 0;
243         p-&amp;gt;sl_curr--;
244         ret = (void *)it;
245     }
246  
247     if (ret) {
248         p-&amp;gt;requested += size;
249         MEMCACHED_SLABS_ALLOCATE(size, id, p-&amp;gt;size, ret);
250     } else {
251         MEMCACHED_SLABS_ALLOCATE_FAILED(size, id);
252     }
253  
254     return ret;
255 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;slab优先从slots（空闲chunk空间列表）中申请空间，如果没有则尝试申请一个Page的新空间（do_slab_newslab()），申请新slab是会先判断是否进行slab_reasgin（重新分配slab空间，默认不开启）。&lt;/p&gt;

&lt;h2&gt;内存浪费&lt;/h2&gt;

&lt;p&gt;根据上述描述，Memcache使用Slab预分配的方式进行内存管理提升了性能（减少分配内存的消耗），但是带来了内存浪费，主要体现在：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Data Item Size &amp;lt;= Chunk Size，Chunk是存储数据项的最小单元，数据项的大小必须不大于其所在的Chunk大小。也就是说76B的数据对象存入96B的Chunk中，将带来96B-76B=20B的空间浪费。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Memcache是按照Page申请和使用内存的，当Page大小不是Chunk的整数倍时，余下的空间将被浪费。即如果PageSize=1M，ChunkSize=1000B,那么将有1024*1024%1000=576B的空间浪费。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Memcache默认是不开启slab reasign的，也就是说分配已经分配给一个slab的内存空间，即使该slab不用，默认也不会分配给其他slab的&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;案例分析：定长问题导致逐出&lt;/h2&gt;

&lt;p&gt;memcache的chunk分布是均匀的，这是为了通用性考虑，但是现实中一些场景chunk的分布是不均运的，例如为了减小对数据库的压力，对数据进行了全量缓存，为标识数据库中不存在的记录，向缓存中放置了一个stupidObject。这个对象大小是固定的，且该数据的量很大，导致该数据类型所在的slab占用了大量缓存空间。再一次调整对象结构时，修改了这个StupidObject大小，使其分布在另一个slab中，但是这个原分配的slab空间不会回收，空闲空间不足，导致大量逐出。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>使用方法链和静态工厂构造流畅接口</title>
   <link href="http://jiang-bo.github.com/blog/2012/04/08/build-fluent-interface-with-method-chain-and-static-factory"/>
   <updated>2012-04-08T11:23:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/04/08/build-fluent-interface-with-method-chain-and-static-factory</id>
   <content type="html">&lt;h3&gt;问题现象&lt;/h3&gt;

&lt;p&gt;现有的VO，DO，Model等模型类中，均遵循JavaBean规范，为对属性的访问提供了getter和setter方法，并且在实际使用时通常为构造一个模型实例，需要调用大段的setter方法。下面以VasViewVO为例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class VasViewVO {

    private String description;

    private Date gmtOpen;

    private Date gmtClose;

    private CreditVasType serviceType;

    private CreditVasMemberStatus creditVasMemberStatus;
    ...//此处省略getter和setter方法
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常按照如下方式构造一个VasViewVO实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    VasViewVO vasViewVO = new VasViewVO();
    vasViewVO.setCreditVasMemberStatus(CreditVasMemberStatus.OPEN);
    vasViewVO.setGmtOpen(new Date());
    vasViewVO.setServiceType(CreditVasType.fastpay);
    vasViewVO.setDescription(&quot;open fastpay&quot;);
    //do something with vasViewVO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如此构造VasViewVO的实例并非有严重的逻辑错误或者其他的问题，只是不够简洁易懂（贴近自然语言）。
最近学习过jQuery的都知道，jQuery中可以按如下方式连续调用api&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $(&quot;p&quot;).hide().fadeIn(&quot;slow&quot;).slideUp(&quot;slow&quot;).slideDown(&quot;slow&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果Java程序中也可以使用类似的方式将会简洁许多。&lt;/p&gt;

&lt;h3&gt;解决方法&lt;/h3&gt;

&lt;h4&gt;使用方法链&lt;/h4&gt;

&lt;p&gt;jQuery中之所以能够连续调用api，主要是因为每个方法返回的都是一个jQuery对象。Java本身也可这样做，即返回一个this(自身引用)，也就是常说的&lt;a href=&quot;http://en.wikipedia.org/wiki/Method_chaining&quot;&gt;方法链&lt;/a&gt;。
方法链的实现非常简单，通常的setter方法返回void，方法链返回的是this引用，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public VasViewVO description(String description) {
        this.description = description;
        return this;
    }

    public VasViewVO gmtOpen(Date gmtOpen) {
        this.gmtOpen = gmtOpen;
        return this;
    }

    public VasViewVO gmtClose(Date gmtClose) {
        this.gmtClose = gmtClose;
        return this;
    }

    public VasViewVO serviceType(CreditVasType serviceType) {
        this.serviceType = serviceType;
        return this;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如此一来在调用时只需要新建一个对象，连续调用赋值方法即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    VasViewVO vasView = new VasViewVO();
    vasView.creditVasMemberStatus(CreditVasMemberStatus.CLOSE)
            .description(&quot;Commoent cxxx&quot;).gmtClose(new Date())
            .gmtOpen(new Date()).serviceType(CreditVasType.fastpay);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如此相比连续调用5次setter方法简洁的多。&lt;/p&gt;

&lt;h4&gt;使用静态工厂和static import优化&lt;/h4&gt;

&lt;p&gt;使用方法链之后简化了setter调用，但是每次还必须要先new一个实例，略显繁琐。这个问题可以通过Effectvie Java的第一条静态工厂来解决，即在VasViewVO内部实现一个静态工厂方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public static VasViewVO with() {
        return new VasViewVO();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个with的方法名与一般的静态工厂所用的getInstance，newInstance不同，主要时为了更加贴近自然语言。
如此，构造一个VasViewVO实例就可简化为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    VasViewVO vasViewVO = VasViewVO.with()
                .creditVasMemberStatus(CreditVasMemberStatus.CLOSE)
                .description(&quot;Commoent cxxx&quot;).gmtClose(new Date())
                .gmtOpen(new Date()).serviceType(CreditVasType.fastpay);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码已经很简洁，不过每次都是用枚举类长长的类名，感觉很是不雅，可以通过static import解决，最终的到的简化后构造一个VasViewVO实例的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import static  com.alibaba.china.credit.common.constants.CreditVasType.*;
import static com.alibaba.china.credit.vas.dal.constant.CreditVasMemberStatus.*;
public class Test{
    public static void main(String[] args) {
        . . .

        VasViewVO vasViewVO = VasViewVO.with()
            .creditVasMemberStatus(CLOSE)
            .description(&quot;Commoent cxxx&quot;).gmtClose(new Date())
            .gmtOpen(new Date()).serviceType(fastpay);
        . . .
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;进阶总结&lt;/h3&gt;

&lt;p&gt;程序设计要解决的是讲现实世界中的问题描述转化为计算机可识别的计算机语言（二进制码），因此编程语言必须为这一转化过程提供有效的抽像机制。现有编程语言提供的抽象机制侧重各有不同，在C，C++，JAVA等通用语言中更关注语言的基本语义，离实际的问题域描述较远；SQL，CSS等特定领域语言更关注特定问题域问题的抽象，更贴近实际的问题描述。&lt;/p&gt;

&lt;p&gt;站在人的角度，语言越是贴近实际问题的描述越是容易理解，对问题的描述也更加准确。但现有的特定领域语言又不具备通用变成语言解决问题的的通用性，因此我们更希望能够在通用语言上进行更高层次的抽象，使其更加贴近具体的问题域。某种程度上讲语言提供的API或者方法库就是对基本问题的更高层次抽象，但离具体的问题域还是太远，有时我们更渴望更加贴近具体问题的语言来解决问题并兼具通用语言的通用性，因此诞生了通用语言的内部DSL。
&lt;a href=&quot;http://www.martinfowler.com/bliki/FluentInterface.html&quot;&gt;流畅接口（Fluent Interface）&lt;/a&gt;是实现内部DSL的重要手段，&lt;a href=&quot;http://en.wikipedia.org/wiki/Fluent_interface&quot;&gt;wikipedia上如此描述&lt;/a&gt;Fluent Interface：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A fluent interface (as first coined by Eric Evans and Martin Fowler) is an implementation of an object oriented API that aims to provide for more readable code. A fluent interface is normally implemented by using method chaining to relay the instruction context of a subsequent call (but a fluent interface entails more than just method chaining)。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法链（method chain）是实现Fluent Interface的重要手段（注意，method chain!= Fluent Interface!=DSL）。但仅仅有方法链是不足够构建有效的DSL的，除此之外还需要一些且他编程技巧，比如static factory和static import等，具体请参见&lt;a href=&quot;http://www.infoq.com/articles/internal-dsls-java&quot;&gt;《An Approach to Internal Domain－Specific Languages in Java》&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>java.lang.instrument笔记</title>
   <link href="http://jiang-bo.github.com/blog/2012/02/21/java-lang-instrument"/>
   <updated>2012-02-21T17:13:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/02/21/java-lang-instrument</id>
   <content type="html">&lt;h2&gt;什么是Instrumentation？&lt;/h2&gt;

&lt;p&gt;java Instrumentation指的是可以用独立于应用程序之外的代理（agent）程序来监测和协助运行在JVM上的应用程序。这种监测和协助包括但不限于获取JVM运行时状态，替换和修改类定义等。
Java SE5中使用JVM TI替代了JVM PI和JVM DI。提供一套代理机制，支持独立于JVM应用程序之外的程序以代理的方式连接和访问JVM。java.lang.instrument是在JVM TI的基础上提供的Java版本的实现。
Instrumentation提供的主要功能是修改jvm中类的行为。
Java SE6中由两种应用Instrumentation的方式，premain（命令行）和agentmain（运行时）&lt;/p&gt;

&lt;h2&gt;premain方式&lt;/h2&gt;

&lt;p&gt;在Java SE5时代，Instrument只提供了premain一种方式，即在真正的应用程序（包含main方法的程序）main方法启动前启动一个代理程序。例如使用如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java -javaagent:agent_jar_path[=options] java_app_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以在启动名为java_app_name的应用之前启动一个agent_jar_path指定位置的agent jar。
实现这样一个agent jar包，必须满足两个条件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在这个jar包的manifest文件中包含Premain-Class属性，并且改属性的值为代理类全路径名。&lt;/li&gt;
&lt;li&gt;代理类必须提供一个public static void premain(String args, Instrumentation inst)或 public static void premain(String args) 方法。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;当在命令行启动该代理jar时，VM会根据manifest中指定的代理类，使用于main类相同的系统类加载器（即ClassLoader.getSystemClassLoader()获得的加载器）加载代理类。在执行main方法前执行premain()方法。如果premain(String args, Instrumentation inst)和premain(String args)同时存在时，优先使用前者。其中方法参数args即命令中的options，类型为String（注意不是String[]），因此如果需要多个参数，需要在方法中自己处理（比如用&quot;;&quot;分割多个参数之类）；inst是运行时由VM自动传入的Instrumentation实例，可以用于获取VM信息。&lt;/p&gt;

&lt;h2&gt;premain实例-打印所有的方法调用&lt;/h2&gt;

&lt;p&gt;下面实现一个打印程序执行过程中所有方法调用的功能，这个功能可以通过AOP其他方式实现，这里只是尝试使用Instrumentation进行ClassFile的字节码转换实现：&lt;/p&gt;

&lt;h3&gt;构造agent类&lt;/h3&gt;

&lt;p&gt;premain方式的agent类必须提供premain方法，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package test;

import java.lang.instrument.Instrumentation;

public class Agent {

    public static void premain(String args, Instrumentation inst){
        System.out.println(&quot;Hi, I'm agent!&quot;);
        inst.addTransformer(new TestTransformer());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;premain有两个参数，args为自定义传入的代理类参数，inst为VM自动传入的Instrumentation实例。 premain方法的内容很简单，除了标准输出外，只有&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;inst.addTransformer(new TestTransformer());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这行代码的意思是向inst中添加一个类的转换器。用于转换类的行为。&lt;/p&gt;

&lt;h3&gt;构造Transformer&lt;/h3&gt;

&lt;p&gt;下面来实现上述过程中的TestTransformer来完成打印调用方法的类定义转换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package test;

import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.IllegalClassFormatException;
import java.security.ProtectionDomain;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldInsnNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;

public class TestTransformer implements ClassFileTransformer {

    @Override
    public byte[] transform(ClassLoader arg0, String arg1, Class&amp;lt;?&amp;gt; arg2,
            ProtectionDomain arg3, byte[] arg4)
            throws IllegalClassFormatException {
        ClassReader cr = new ClassReader(arg4);
        ClassNode cn = new ClassNode();
        cr.accept(cn, 0);
        for (Object obj : cn.methods) {
            MethodNode md = (MethodNode) obj;
            if (&quot;&amp;lt;init&amp;gt;&quot;.endsWith(md.name) || &quot;&amp;lt;clinit&amp;gt;&quot;.equals(md.name)) {
                continue;
            }
            InsnList insns = md.instructions;
            InsnList il = new InsnList();
            il.add(new FieldInsnNode(Opcodes.GETSTATIC, &quot;java/lang/System&quot;,
                    &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;));
            il.add(new LdcInsnNode(&quot;Enter method-&amp;gt; &quot; + cn.name+&quot;.&quot;+md.name));
            il.add(new MethodInsnNode(Opcodes.INVOKEVIRTUAL,
                    &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;));
            insns.insert(il);
            md.maxStack += 3;

        }
        ClassWriter cw = new ClassWriter(0);
        cn.accept(cw);
        return cw.toByteArray();
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TestTransformer实现了ClassFileTransformer接口，该接口只有一个transform方法，参数传入包括该类的类加载器，类名，原字节码字节流等，返回被转换后的字节码字节流。
TestTransformer主要使用ASM实现在所有的类定义的方法中，在方法开始出添加了一段打印该类名和方法名的字节码。在转换完成后返回新的字节码字节流。详细的ASM使用请参考ASM手册。&lt;/p&gt;

&lt;h3&gt;设置MANIFEST.MF&lt;/h3&gt;

&lt;p&gt;设置MANIFEST.MF文件中的属性，文件内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Manifest-Version: 1.0
Premain-Class: test.Agent
Created-By: 1.6.0_29
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;测试&lt;/h3&gt;

&lt;p&gt;代码编写完成后将代码编译打成agent.jar。
编写测试代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class TestAgent {

    public static void main(String[] args) {
        TestAgent ta = new TestAgent();
        ta.test();
    }

    public void test() {
        System.out.println(&quot;I'm TestAgent&quot;);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从命令行执行该类，并设置agent.jar&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java -javaagent:agent.jar TestAgent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将打印出程序运行过程中实际执行过的所有方法名：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hi, I'm agent!
Enter method-&amp;gt; test/TestAgent.main
Enter method-&amp;gt; test/TestAgent.test
I'm TestAgent
Enter method-&amp;gt; java/util/IdentityHashMap$KeySet.iterator
Enter method-&amp;gt; java/util/IdentityHashMap$IdentityHashMapIterator.hasNext
Enter method-&amp;gt; java/util/IdentityHashMap$KeyIterator.next
Enter method-&amp;gt; java/util/IdentityHashMap$IdentityHashMapIterator.nextIndex
Enter method-&amp;gt; java/util/IdentityHashMap$IdentityHashMapIterator.hasNext
Enter method-&amp;gt; java/util/IdentityHashMap$KeySet.iterator
Enter method-&amp;gt; java/util/IdentityHashMap$IdentityHashMapIterator.hasNext
Enter method-&amp;gt; java/util/IdentityHashMap$KeyIterator.next
Enter method-&amp;gt; java/util/IdentityHashMap$IdentityHashMapIterator.nextIndex
Enter method-&amp;gt; com/apple/java/Usage$3.run
。。。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从输出中可以看出，程序首先执行的是代理类中的premain方法（不过代理类自身不会被自己转换，所以不能打印出代理类的方法名），然后是应用程序中的main方法。&lt;/p&gt;

&lt;h2&gt;agentmain方式&lt;/h2&gt;

&lt;p&gt;premain时Java SE5开始就提供的代理方式，给了开发者诸多惊喜，不过也有些须不变，由于其必须在命令行指定代理jar，并且代理类必须在main方法前启动。因此，要求开发者在应用前就必须确认代理的处理逻辑和参数内容等等，在有些场合下，这是比较苦难的。比如正常的生产环境下，一般不会开启代理功能，但是在发生问题时，我们不希望停止应用就能够动态的去修改一些类的行为，以帮助排查问题，这在应用启动前是无法确定的。
为解决运行时启动代理类的问题，Java SE6开始，提供了在应用程序的VM启动后在动态添加代理的方式，即agentmain方式。
与Permain类似，agent方式同样需要提供一个agent jar，并且这个jar需要满足：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在manifest中指定Agent-Class属性，值为代理类全路径&lt;/li&gt;
&lt;li&gt;代理类需要提供public static void agentmain(String args, Instrumentation inst)或public static void agentmain(String args)方法。并且再二者同时存在时以前者优先。args和inst和premain中的一致。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;不过如此设计的再运行时进行代理有个问题——如何在应用程序启动之后再开启代理程序呢？
JDK6中提供了Java Tools API，其中Attach API可以满足这个需求。&lt;/p&gt;

&lt;p&gt;Attach API中的VirtualMachine代表一个运行中的VM。其提供了loadAgent()方法，可以在运行时动态加载一个代理jar。具体需要参考&lt;a href=&quot;&quot;&gt;《Attach API》&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;agentmain实例-打印当前已加载的类&lt;/h2&gt;

&lt;h3&gt;构造agent类&lt;/h3&gt;

&lt;p&gt;agentmain方式的代理类必须提供agentmain方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package loaded;

import java.lang.instrument.Instrumentation;

public class LoadedAgent {
    @SuppressWarnings(&quot;rawtypes&quot;)
    public static void agentmain(String args, Instrumentation inst){
        Class[] classes = inst.getAllLoadedClasses();
        for(Class cls :classes){
            System.out.println(cls.getName());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;agentmain方法通过传入的Instrumentation实例获取当前系统中已加载的类。&lt;/p&gt;

&lt;h3&gt;设置MANNIFEST.MF&lt;/h3&gt;

&lt;p&gt;设置MANIFEST.MF文件，指定Agent-Class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Manifest-Version: 1.0
Agent-Class: loaded.LoadedAgent
Created-By: 1.6.0_29
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;绑定到目标VM&lt;/h3&gt;

&lt;p&gt;将agent类和MANIFEST.MF文件编译打成loadagent.jar后，由于agent main方式无法向pre main方式那样在命令行指定代理jar，因此需要借助Attach Tools API。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package attach;

import java.io.IOException;

import com.sun.tools.attach.AgentInitializationException;
import com.sun.tools.attach.AgentLoadException;
import com.sun.tools.attach.AttachNotSupportedException;
import com.sun.tools.attach.VirtualMachine;

public class Test {
    public static void main(String[] args) throws AttachNotSupportedException,
            IOException, AgentLoadException, AgentInitializationException {
        VirtualMachine vm = VirtualMachine.attach(args[0]);
        vm.loadAgent(&quot;/Users/jiangbo/Workspace/code/java/javaagent/loadagent.jar&quot;);

    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该程序接受一个参数为目标应用程序的进程id，通过Attach Tools API的VirtualMachine.attach方法绑定到目标VM，并向其中加载代理jar。&lt;/p&gt;

&lt;h3&gt;构造目标测试程序&lt;/h3&gt;

&lt;p&gt;构造一个测试用的目标应用程序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package attach;

public class TargetVM {
    public static void main(String[] args) throws InterruptedException{
        while(true){
            Thread.sleep(1000);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个测试程序什么都不做，只是不停的sleep。:)
运行该程序，获得进程ID=33902。
运行上面绑定到VM的Test程序，将进程id作为参数传入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java attach.Test 33902
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;观察输出，会打印出系统当前所有已经加载类名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java.lang.NoClassDefFoundError
java.lang.StrictMath
java.security.SignatureSpi
java.lang.Runtime
java.util.Hashtable$EmptyEnumerator
sun.security.pkcs.PKCS7
java.lang.InterruptedException
java.io.FileDescriptor$1
java.nio.HeapByteBuffer
java.lang.ThreadGroup
[Ljava.lang.ThreadGroup;
java.io.FileSystem
。。。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;参考文档&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html&quot;&gt;java.lang.instrument API docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blogs.oracle.com/CoreJavaTechTips/entry/the_attach_api&quot;&gt;The Attach API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html&quot;&gt;Java SE6新特性：Instrumentation新功能&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;附：agent jar中manifest的属性&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Premain-Class: 当在VM启动时，在命令行中指定代理jar时，必须在manifest中设置Premain-Class属性，值为代理类全类名，并且该代理类必须提供premain方法。否则JVM会异常终止。&lt;/li&gt;
&lt;li&gt;Agent-Class: 当在VM启动之后，动态添加代理jar包时，代理jar包中manifest必须设置Agent-Class属性，值为代理类全类名，并且该代理类必须提供agentmain方法，否则无法启动该代理。&lt;/li&gt;
&lt;li&gt;Boot-Class-Path: Bootstrap class loader加载类时的搜索路径，可选。&lt;/li&gt;
&lt;li&gt;Can-Redefine-Classes: true/false；标示代理类是否能够重定义类。可选。&lt;/li&gt;
&lt;li&gt;Can-Retransform-Classes: true/false；标示代理类是否能够转换类定义。可选。&lt;/li&gt;
&lt;li&gt;Can-Set-Native-Prefix::true/false；标示代理类是否需要本地方法前缀，可选。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt; 当一个代理jar包中的manifest文件中既有Premain-Class又有Agent-Class时，如果以命令行方式在VM启动前指定代理jar，则使用Premain-Class；反之如果在VM启动后，动态添加代理jar，则使用Agent-Class &lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jetty ClassLoader解析</title>
   <link href="http://jiang-bo.github.com/blog/2012/02/14/jetty-classloader"/>
   <updated>2012-02-14T00:26:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/02/14/jetty-classloader</id>
   <content type="html">&lt;h2&gt;什么是类加载器？&lt;/h2&gt;

&lt;p&gt;类加载器（ClassLoader）指将类加载到虚拟机中的代码模块，所有的类必须通过加载器被加载到JVM中。JVM规范将累加在的过程外置于JVM实现，让应用程序自己决定如何获取所需类，这种机制位类层次划分，热加载，模块化奠定了基础。&lt;/p&gt;

&lt;h2&gt;类加载器分类&lt;/h2&gt;

&lt;p&gt;类加载器主要分为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;启动类加载器(Bootstrap ClassLoader)：主要负责加载&amp;lt;JAVA_HOME&gt;\lib目录中或者-Xbootclasspath中指定的，并且被虚拟机识别的类库加载到VM中。这个加载器是JVM自身的一部分，用本地代码实现的(openjdk中源码位于hotspot/src/share/vm/classfile/classLoader.cpp中)，无法直接被java代码引用。&lt;/li&gt;
&lt;li&gt;扩展类加载器(Extension ClassLoader)：主要负责加载jdk扩展类库&amp;lt;JAVA_HOME&gt;\lib\ext或者java.ext.dirs系统属性指定的目录中jar文件，由sun.misc.Launcher$ExtClassLoader实现&lt;/li&gt;
&lt;li&gt;系统类加载器(System ClassLoader)：用于加载CLASSPATH中指定的类，由sun.misc.Launcher$AppClassLoader实现。该类即ClassLoader.getSystemLoader()的返回值，是应用程序默认的类加载器。&lt;/li&gt;
&lt;li&gt;自定义加载器(User ClassLoader)：用户可以自定义自己的类加载器&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;双亲委托模型&lt;/h2&gt;

&lt;p&gt;JDK中要求所有的自定义ClassLoader 必须扩展自抽象类java.lang.ClassLoader。该类的文档说名中有一个段关于delegate model的描述：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The ClassLoader class uses a &lt;code&gt;delegation model&lt;/code&gt; to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine's built-in class loader, called the &quot;bootstrap class loader&quot;, does not itself have a parent but may serve as the parent of a ClassLoader instance.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;简单来说这个delegate model要求除了Bootstrap ClassLoader之外，其余ClassLoader都需要关联一个parent ClassLoader（这种关联方式采用的时组合而非继承），在执行加载class时，首先委托给parent ClassLoader加载，只有当parent ClassLoader无法加载时，再由自身加载。各加载器的关联关系如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        Bootstrap ClassLoader
                 |
        Extension ClassLoader
                 |
        System ClassLoader
            /           \
    User1 ClassLoader   User2 ClassLoader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bootstrap ClassLoader是最根层的加载器，用户自定义加载器建议使用系统类加载器作为parent。
这种委托模型的好处显而易见，它维护了类加载器之间的层次优先级关系。使所有的类加载优先由parent加载，这保证了java基础类库中的加载只会有一份。以java.lang.Object为例，委托模式保证了这个类最终只会由BootstrapClassLoader来加载，以此来保证所有环境中只有同一个类。否则由各加载器自由发挥，当用户自己定义各同名的java.lang.Object类时，系统会出现多分Objec类，最根基的行为出现混乱。（当然，你还是可以自定义出一个同名的java.lang.Object，并且顺利通过编译，但是它正常情况下永远不会被加载）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;这个委托模型并非jvm的强制规范，只是jdk中建议的一种模式，有时会发现不遵守这种模式的行为却能产生奇妙的效果，如热部署，OSGI等。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;Jetty中的ClassLoader&lt;/h2&gt;

&lt;p&gt;jetty，tomcat等web容器通常都会对classloader做扩展，因为一个正常的容器至少要保证其内部运行的多个webapp之间：私有的类库不受影响，并且公有的类库可以共享。这正好发挥classloader的层级划分优势。
jetty中有一个org.mortbay.jetty.webapp.WebAppClassLoader，负责加载一个webapp context中的应用类，WebAppClassLoader以系统类加载器作为parent，用于加载系统类。不过servlet规范使得web容器的classloader比正常的classloader委托模型稍稍复杂，servlet规范要求：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;WEB-INF/lib 和 WEB-INF/classes优先于父容器中的类加载，比如WEB-INF/classes下有个XYZ类，CLASSPATH下也有个XYZ类，jetty中优先加载的是WEB-INF/classes下的，这与正常的父加载器优先相反。&lt;/li&gt;
&lt;li&gt;系统类比如java.lang.String不遵循第一条， WEB-INF/classes或WEB-INF/lib下的类不能替换系统类。不过规范中没有明确规定哪些是系统类，jetty中的实现是按照类的全路径名判断。&lt;/li&gt;
&lt;li&gt;Server的实现类不被应用中的类引用，即Server的实现类不能被人和应用类加载器加载。不过，同样的，规范里没有明确规定哪些是Server的实现类，jetty中同样是按照类的全路径名判断。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;为了处理上述三个问题，jetty的应用类加载器(org.mortbay.jetty.webapp.WebAppClassLoader)做了些特殊处理。&lt;/p&gt;

&lt;h3&gt;WebAppClassLoader的实现&lt;/h3&gt;

&lt;p&gt;首先看WebAppClassLoader的实现，WebAppClassLoader的构造器中有如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;super(new URL[]{},parent!=null?parent
            :(Thread.currentThread().getContextClassLoader()!=null?Thread.currentThread().getContextClassLoader()
                    :(WebAppClassLoader.class.getClassLoader()!=null?WebAppClassLoader.class.getClassLoader()
                            :ClassLoader.getSystemClassLoader())));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表明WebAppClassLoader还是按照正常的范式设置parent classloader
然后看重要的loadclass方法实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
protected synchronized Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve) throws ClassNotFoundException
{
    Class&amp;lt;?&amp;gt; c= findLoadedClass(name);
    ClassNotFoundException ex= null;
    boolean tried_parent= false;

    boolean system_class=_context.isSystemClass(name);
    boolean server_class=_context.isServerClass(name);

    if (system_class &amp;amp;&amp;amp; server_class)
    {
        return null;
    }

    if (c == null &amp;amp;&amp;amp; _parent!=null &amp;amp;&amp;amp; (_context.isParentLoaderPriority() || system_class) &amp;amp;&amp;amp; !server_class)
    {
        tried_parent= true;
        try
        {
            c= _parent.loadClass(name);
            if (LOG.isDebugEnabled())
                LOG.debug(&quot;loaded &quot; + c);
        }
        catch (ClassNotFoundException e)
        {
            ex= e;
        }
    }

    if (c == null)
    {
        try
        {
            c= this.findClass(name);
        }
        catch (ClassNotFoundException e)
        {
            ex= e;
        }
    }

    if (c == null &amp;amp;&amp;amp; _parent!=null &amp;amp;&amp;amp; !tried_parent &amp;amp;&amp;amp; !server_class )
        c= _parent.loadClass(name);

    if (c == null)
        throw ex;

    if (resolve)
        resolveClass(c);

    if (LOG.isDebugEnabled())
        LOG.debug(&quot;loaded &quot; + c+ &quot; from &quot;+c.getClassLoader());

    return c;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;loadclass按照：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;findLoadedClass(name)-检查类是否已经加载&lt;/li&gt;
&lt;li&gt;判断该类是否为系统类或server类&lt;/li&gt;
&lt;li&gt;如果该类未加载且父加载器不为空且设置了父加载器优先或类类为系统类，且该类不是server类，则尝试使用父加载器加载该类&lt;/li&gt;
&lt;li&gt;如果不是父加载器优先或者父加载器未加载到该类，使用WebAppClassLoader加载该类&lt;/li&gt;
&lt;li&gt;如果是不是父加载器优先，并且WebAppClassLoader未加载到该类，尝试使用父加载器加载该类&lt;/li&gt;
&lt;li&gt;找到则返回，否则抛出ClassNotFoundException&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;ClassLoader Priority&lt;/h3&gt;

&lt;p&gt;上述过程涉及一个加载器优先级的概念，这也是针对前述第一条规范中WEB-INF/lib和WEB-INF/classes类优先的处理。jetty中父加载器优先的配置项可以通过环境变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;org.eclipse.jetty.server.webapp.parentLoaderPriority=false(默认)/true来设置
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以通过&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;org.eclipse.jetty.webapp.WebAppContext.setParentLoaderPriority(boolean)方法来设置
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优于该配置默认是false，因此在load class过程中优先使用WebAppClassLoader加载WEB-INF/lib和WEB-INF/classes中的类。
当将该配置项设为true时需要确认类加载顺序没有问题。&lt;/p&gt;

&lt;h3&gt;设置系统类&lt;/h3&gt;

&lt;p&gt;规范2中约定系统类不能被应用类覆盖，但是没有明确规定哪些时系统类，jetty中以类的package路径名来区分，当类的package路径名位包含于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public final static String[] __dftSystemClasses =
    {
        &quot;java.&quot;,                            
        &quot;javax.&quot;,                           
        &quot;org.xml.&quot;,                         
        &quot;org.w3c.&quot;,                         
        &quot;org.apache.commons.logging.&quot;,      
        &quot;org.eclipse.jetty.continuation.&quot;,  
        &quot;org.eclipse.jetty.jndi.&quot;,          
        &quot;org.eclipse.jetty.plus.jaas.&quot;,     
        &quot;org.eclipse.jetty.websocket.WebSocket&quot;, 
        &quot;org.eclipse.jetty.websocket.WebSocketFactory&quot;, 
        &quot;org.eclipse.jetty.servlet.DefaultServlet&quot; 
    } ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;时，会被认为是系统类。（该定义位于&lt;a href=&quot;https://github.com/eclipse/jetty.project/blob/master/jetty-webapp/src/main/java/org/eclipse/jetty/webapp/WebAppContext.java&quot;&gt;WebAppContext@github&lt;/a&gt;中）&lt;/p&gt;

&lt;p&gt;因此，我们可以通过 org.eclipse.jetty.webapp.WebAppContext.setSystemClasses(String Array)或者org.eclipse.jetty.webapp.WebAppContext.addSystemClass(String)来设置系统类。
再次提醒，系统类是对多有应用都可见。&lt;/p&gt;

&lt;h3&gt;设置Server类&lt;/h3&gt;

&lt;p&gt;规范3中约定Server类不对任何应用可见。jetty同样是用package路径名来区分哪些是Server类。Server类包括：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final static String[] __dftServerClasses =
{
    &quot;-org.eclipse.jetty.continuation.&quot;, 
    &quot;-org.eclipse.jetty.jndi.&quot;,         
    &quot;-org.eclipse.jetty.plus.jaas.&quot;,    
    &quot;-org.eclipse.jetty.websocket.WebSocket&quot;, 
    &quot;-org.eclipse.jetty.websocket.WebSocketFactory&quot;, 
    &quot;-org.eclipse.jetty.servlet.DefaultServlet&quot;, 
    &quot;-org.eclipse.jetty.servlet.listener.&quot;, 
    &quot;org.eclipse.jetty.&quot;                
} ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以通过， org.eclipse.jetty.webapp.WebAppContext.setServerClasses(String Array) 或org.eclipse.jetty.webapp.WebAppContext.addServerClass(String)方法设置Server类。
注意，Server类是对所有应用都不可见的，但是WEB-INF/lib下的类可以替换Server类。&lt;/p&gt;

&lt;h3&gt;自定义WebApp ClassLoader&lt;/h3&gt;

&lt;p&gt;当默认的WebAppClassLoader不能满足需求时，可以自定义WebApp ClassLoader，不过jetty建议自定义的classloader要扩展于默认的WebAppClassLoader实现。具体请参考&lt;a href=&quot;http://wiki.eclipse.org/Jetty/Reference&quot;&gt;jetty手册&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>解决Mac上解压Windows压缩包乱码问题</title>
   <link href="http://jiang-bo.github.com/blog/2012/02/13/unzip-file-from-win-to-mac"/>
   <updated>2012-02-13T16:53:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/02/13/unzip-file-from-win-to-mac</id>
   <content type="html">&lt;p&gt;Windows上默认使用的GBK编码，Mac上默认使用的unicode编码，因此Win上的压缩包再Mac上解压会出现文件名乱码:(
下面是用ruby写的一个解决方法：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/jiang-bo/codingforfun/blob/master/ruby/utils/unzipFromWinToMac.rb&quot;&gt;source@github&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require 'zip/zip'
require 'iconv'

# To unzip zipfile which zip in GBK to UTF-8.
#
# When you zip a file on Windows, it will encode in GBK default.
# Then you unzip it on Mac OSX which use unicode default, it will be wrong.
# This code is used to fix this problem:)
#
# @Author: jiang-bo
Zip::ZipInputStream::open(zipFile){
  |io|
  while(entry = io.get_next_entry)
    name=Iconv.iconv(&quot;UTF-8&quot;,&quot;GBK&quot;, entry.name)[0]

    puts &quot;Extracting #{name}&quot;
    if name.end_with?('/')
      Dir.mkdir(name.to_s)
    else
      entry.extract(name.to_s)
    end
  end
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要依赖rubyzip和iconv两个包：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install rubyzip
gem install iconv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用ruby zip中ZipInputStream打开压缩包，然后使用Iconv.iconv将其中的文件名由'GBK'转码为'UTF-8'。
然后解压压缩包。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>JVM Luncher Lifecycle</title>
   <link href="http://jiang-bo.github.com/blog/2012/02/10/jvm-luncher-lifecycle"/>
   <updated>2012-02-10T23:51:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/02/10/jvm-luncher-lifecycle</id>
   <content type="html">&lt;h1&gt;JVM运行时环境&lt;/h1&gt;
</content>
 </entry>
 
 <entry>
   <title>CentOS6编译OpenJDK7</title>
   <link href="http://jiang-bo.github.com/blog/2012/02/10/compile-openjdk7-on-centos6"/>
   <updated>2012-02-10T14:39:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/02/10/compile-openjdk7-on-centos6</id>
   <content type="html">&lt;h2&gt;一.环境准备&lt;/h2&gt;

&lt;h3&gt;1.jdk&lt;/h3&gt;

&lt;p&gt;在编译JDK7之前，需要有个JDK6版本，这个貌似有个鸡生蛋，还是蛋生鸡的问题，不过，这个确实需要:)&lt;/p&gt;

&lt;h3&gt;2.alsa包&lt;/h3&gt;

&lt;p&gt;linux版本的jdk编译需要ALSA（Advanced Linux Sound Architecture）包，大部分linux发行版都没有预装，CentOS可以通过如下命令检查：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; rpm -qa |grep alsa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;alsa-lib和alsa-lib-devel均需要。CentOS缺少alsa-lib-devel，通过如下命令安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; yum install alsa-lib-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3.cups-devel&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;yum install cups-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4.libXi-devel&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;yum install libXi-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;5.freetype2.3&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;wget http://download.savannah.gnu.org/releases/freetype/freetype-2.3.12.tar.gz
tar -xvf freetype-2.3.12.tar.gz
cd freetype-2.3.12
./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;6. ant&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;wget http://mirror.bit.edu.cn/apache//ant/binaries/apache-ant-1.8.2-bin.zip
unzip apache-ant-1.8.2-bin.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;7.g++&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;yum install gcc gcc-c++
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;二、设置环境变量&lt;/h2&gt;

&lt;p&gt;jdk编译过程中有一些环境变量需要设置，详细的请参考README-builds.html，下面写的只是一些必须设置的环境变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export ALT_BOOTDIR=/usr/opt/jdk # 预装的jdk7目录
export ANT_HOME=ant安装目录
export ALT_FREETYPE_HEADERS_PATH=/usr/local/include/freetype2 #freetype2头文件安装目录
export ALT_FREETYPE_LIB_PATH=/usr/local/lib #freetype2 lib目录
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;三、编译&lt;/h2&gt;

&lt;h3&gt;1.健全检查&lt;/h3&gt;

&lt;p&gt;可以通过如下命令检查环境配置是否准备好：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make sanity ARCH_DATA_MODEL=64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果最终输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Sanity check passed.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则表示环境检查通过，否则需要根据提示信息排查问题。&lt;/p&gt;

&lt;h3&gt;2.执行编译&lt;/h3&gt;

&lt;p&gt;通过如下命令开始编译：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make ARCH_DATA_MODEL=64
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3.问题排查：&lt;/h3&gt;

&lt;p&gt;编译过程中出现一些问题：&lt;/p&gt;

&lt;h3&gt;1)缺少jaxp和jaxws&lt;/h3&gt;

&lt;p&gt;错误信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ERROR: Cannot find source for project jaxp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原因是现在jaxp源码分支和jdk源码分支分开了，但是jaxws是jdk中的一部分，所以完全编译需要jaxp源码，针对该问题的描述可以查看README-build.html中TroubleShooting部分。
解决方式有两种：
一种是先下载好源码包，以drops的方式安装，具体参考README-build.html
另外一种是使用在线安装，在编译时加入允许下载源码的配置:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make ARCH_DATA_MODEL=64 ALLOW_DOWNLOADS=true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2)缺少X＊库&lt;/h3&gt;

&lt;p&gt;编译过程中多次出现如下缺少X*, awt之类的错误，基本上都是因为缺乏图形相关的库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;../../../src/solaris/native/sun/awt/img_util_md.h:32: ??:expected specifier-qualifier-list before 'XID'
make[5]: *** [/home/jiangbo/Workspace/jdk/openjdk/build/linux-amd64/tmp/sun/sun.awt/awt/obj64/BufImgSurfaceData.o] Error 1
make[5]: *** Waiting for unfinished jobs....
make[5]: Leaving directory `/home/jiangbo/Workspace/jdk/openjdk/jdk/make/sun/awt'
make[4]: *** [library_parallel_compile] Error 2
make[4]: Leaving directory `/home/jiangbo/Workspace/jdk/openjdk/jdk/make/sun/awt'
make[3]: *** [all] Error 1
make[3]: Leaving directory `/home/jiangbo/Workspace/jdk/openjdk/jdk/make/sun'
make[2]: *** [all] Error 1
make[2]: Leaving directory `/home/jiangbo/Workspace/jdk/openjdk/jdk/make'
make[1]: *** [jdk-build] Error 2
make[1]: Leaving directory `/home/jiangbo/Workspace/jdk/openjdk'
make: *** [build_product_image] Error 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决方式时安装X相关的库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install libX*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个有些暴力，不过比较有效:)&lt;/p&gt;

&lt;h2&gt;四、测试编译结果&lt;/h2&gt;

&lt;p&gt;漫长的编译之后直至出现如下类似内容时，表示编译完成了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- Build times ----------
Target all_product_build
Start 2012-02-09 10:38:39
End   2012-02-09 11:14:37
00:01:41 corba
00:06:19 hotspot
00:15:49 jaxp
00:01:30 jaxws
00:10:03 jdk
00:00:36 langtools
00:35:58 TOTAL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译完成后，编译结果维语build/linux-amd64目录下，可以写个简单的Java程序测试编译结果&lt;/p&gt;

&lt;p&gt;Test.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Test{
        public static void main(String[] args){
                System.out.println(&quot;Hello&quot;);
        }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost openjdk]# ./build/linux-amd64/bin/java Test.java
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost openjdk]# ./build/linux-amd64/bin/java Test
Hello
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>如何用ruby获取本机IP&发送給Gtalk</title>
   <link href="http://jiang-bo.github.com/blog/2012/01/04/how-to-get-ip-and-send-to-gtalk-by-ruby"/>
   <updated>2012-01-04T17:35:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2012/01/04/how-to-get-ip-and-send-to-gtalk-by-ruby</id>
   <content type="html">&lt;h3&gt;问题&lt;/h3&gt;

&lt;p&gt;有一台server用的是动态ip，每次重启后ip地址就变了，因此写了一个脚本，每次在server重启后，自动将ip发送到我的gtalk上。&lt;/p&gt;

&lt;h3&gt;解决&lt;/h3&gt;

&lt;h4&gt;如何获取本机IP&lt;/h4&gt;

&lt;p&gt;用ruby获取本机的动态ip，网上很多教程都用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require 'socket'

IPSocket.getaddress(Socket.gethostname)
puts TCPSocket.gethostbyname(Socket.gethostname)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个在mac下是正常的，但是在linux下就只能拿到127.0.0.1
在StackOverflow上有另一种解决方案&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require 'socket'

def local_ip
  orig, Socket.do_not_reverse_lookup = Socket.do_not_reverse_lookup, true  # turn off reverse DNS resolution temporarily

  UDPSocket.open do |s|
    s.connect '64.233.187.99', 1
    s.addr.last
  end
ensure
  Socket.do_not_reverse_lookup = rig
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段主要是通过开启一个UDP链接来获取本地对外ip，因为UDP是无状态，所以不会实际建立网络链接，但是会获取本机对外ip。&lt;/p&gt;

&lt;h4&gt;如何发送消息&lt;/h4&gt;

&lt;p&gt;获取ip后需要通过gtalk发送，gtalk使用的是xmpp协议，ruby中协议有多种开源实现，比较简单通用的是xmpp4r，详细教程请看这里
首先需要安装xmpp4r-simple&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install xmpp4r-simple
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，貌似这个gem不支持1.9.*，所以使用之前先将ruby切换到1.8.7版本
然后编写代码，主要两步：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;建立链接&lt;/li&gt;
&lt;li&gt;发送消息&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; require 'rubygems'
 require 'xmpp4r-simple'  

 username = gmailusername
 password = gmailpassword
 to_username = destination_gmailusername  

 puts &quot;Connecting to jabber server..&quot;
 jabber = Jabber::Simple.new(username+'@gmail.com',password)
 puts &quot;Connected.&quot;
 jabber.deliver(to_username+&quot;@gmail.com&quot;, &quot;Hello..!&quot;)
 sleep(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，最后那个sleep不能少，尽管我还不知道为啥:(&lt;/p&gt;

&lt;p&gt;如此以来整个的获取ip，发送給gtalk的脚本为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require 'rubygems'
require 'socket'
require 'xmpp4r-simple'

def local_ip
  orig, Socket.do_not_reverse_lookup = Socket.do_not_reverse_lookup, true  # turn off reverse DNS resolution temporarily

  UDPSocket.open do |s|
    s.connect '64.233.187.99', 1
    s.addr.last
  end
ensure
  Socket.do_not_reverse_lookup = orig
end

jabber = Jabber::Simple.new('gmailuseanme@gmail.com','password')
jabber.deliver('destusenam@gmail.com', local_ip)
sleep 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;设置自动运行&lt;/h4&gt;

&lt;p&gt;linux设置自动运行是老生常谈了，在/etc/rc.local加上一句运行脚本的命令即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ruby /home/jiangbo/ruby/getIP.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;结尾&lt;/h3&gt;

&lt;p&gt;这样每次机器重启时，就能够通过gtalk获取到ip了，不过还遗留一个问题，就是在机器重启时，必须保证接收消息的gtalk在线，因为这种方式的消息gtalk不会自动重法，目前不知怎么解决。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>我的2011&2012</title>
   <link href="http://jiang-bo.github.com/blog/2011/12/31/my2011and2012"/>
   <updated>2011-12-31T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2011/12/31/my2011and2012</id>
   <content type="html">&lt;p&gt;一眨眼，一年又过去了，奔三的步伐又向前迈进了一步…&lt;/p&gt;

&lt;p&gt;&lt;h2&gt;2011流水账&lt;/h2&gt;&lt;/p&gt;

&lt;p&gt;1月～3月，入职来第一次正是参加了大项目，中间夹杂个春节，据说每年年底做大项目是部门的传统，今年也不例外啊:(，项目苦了写，不过学了不少&lt;/p&gt;

&lt;p&gt;&lt;p&gt;4月～6月，公司进行服务化改造，作为主力开发参与了部门的服务化建设，期间送走了两个同事好友，一个去了厦门，一个回了宁波，各自寻找自己的幸福去了。&lt;br /&gt;
附加一句，上半年基本还处在阴霾期，期间养成了去酒吧喝酒的习惯，有钱去酒吧，没钱去地摊，酒量现在还可以。&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;7月～8月，参加了另外一个项目，8月底的时候由于上半年持续表现不错，连续两个3.75，所以被升了一级，薪水也有了不错的涨幅:)。同时部门也组织了一次outing，去了舟山嵊泗岛，很祥和的小渔村，很不错。中间的时候李辉来杭州玩，许久不见的兄弟啊&lt;/p&gt;

&lt;p&gt;9月第一次自己带了一个小项目。同时又送走一位同事。&lt;/p&gt;

&lt;p&gt;十一期间，休了半个月的假，和同事几人一起去了趟西藏，花光了半年多的积蓄，感觉无法用语言形容，还会再去的，一定&lt;/p&gt;

&lt;p&gt;11月～12月，需求不断，每日都投入在工作中，有些疲惫哈&lt;/p&gt;

&lt;p&gt;&lt;h2&gt;2011总结&lt;/h2&gt;&lt;/p&gt;

&lt;p&gt;回顾下11年初定的三个目标：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;1. 工作顺利挺进，争取升一级&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2. 保养皮肤，争取帅一点&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;3. 去西藏，无论如何，我一定会去的&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;p&gt;第一点顺利完成；第二点除了痘少些，人也老些，基本没变；第三点纠结许久也顺利完成，而且收获远超期望。&lt;br /&gt;
除了以上三点，还有些额外收获，譬如结束单身生活啥的:)，老家盖新房啥的&lt;br /&gt;
总的来说11年过的还算不错，基本算是从阴霾走向光明，逐渐奔向幸福，哈哈&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;h2&gt;2012的三件事&lt;/h2&gt;&lt;/p&gt;

&lt;p&gt;按照惯例，还是列下明年的目标把，不多，还是三个：&lt;/p&gt;

&lt;p&gt;&lt;ol&gt;
&lt;li&gt;自己做个网站&lt;/li&gt;
&lt;li&gt;再一次长途旅行（环青海湖或这挺进新疆，诚征驴友）&lt;/li&gt;
&lt;li&gt;还有一个很重要的事，一时想不起来了，暂定“顺利度过2012吧！”&lt;/li&gt;
&lt;/ol&gt;&lt;/p&gt;

&lt;p&gt;&lt;h2&gt;祝福&lt;/h2&gt;&lt;/p&gt;

&lt;p&gt;还是按照惯例，最后送上祝福：&lt;/p&gt;

&lt;p&gt;&lt;p&gt;亲们，尽管我这个人平时很少和大家联系，但我内心真的很想念你们，大家都要幸福啊！&lt;br /&gt;
2012，幸福快乐！&lt;/p&gt;
&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>优化rails new时bundle install速度</title>
   <link href="http://jiang-bo.github.com/blog/2011/12/17/rails_new_optimize_bundle_install"/>
   <updated>2011-12-17T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2011/12/17/rails_new_optimize_bundle_install</id>
   <content type="html">&lt;p&gt;最近痴迷ruby和ror，但是每次rails new xxx时总会在bundle install 停留很久，学习了下，发现rails new时会进行bundle install，自动到rubygems.org上检查是否有更新。如果确定不需要更新，事实上是可以跳过这个步骤的，方法很简单：
&lt;code&gt;
rails new my_app --skip-bundle
&lt;/code&gt;
另外在单独执行bundle install时默认也会自动检查所有更新，解决方法时
&lt;code&gt;
bundle insall --local
&lt;/code&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Rails中常见的错误</title>
   <link href="http://jiang-bo.github.com/blog/2011/12/17/rails-common-error"/>
   <updated>2011-12-17T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2011/12/17/rails-common-error</id>
   <content type="html">&lt;p&gt;&lt;h1&gt;Rails中常见错误总结&lt;/h1&gt;
&lt;h3&gt;NoMothedError&lt;/h3&gt;
NoMethodError通常表示引用了错误的方法，比如link_to写成了lunk_to。根据页面上的错误提示很容易能够定位到错误代码位于哪一行。
&lt;h3&gt;NameError&lt;/h3&gt;
NameError常见于引用了错误的变量，比如变量不存在等
&lt;h3&gt;SyntaxError: unexpected $end&lt;/h3&gt;
SyntaxError加上unexpected $end, expected keyword_end的错误，通常是少了end关键字。def和do必须要有对应的end。不过通常错误提示无法定位具体哪一行缺少了end，需要自己审查代码逻辑。
&lt;h3&gt;invalid multibyte char(US-ASCII)&lt;/h3&gt;
如果使用的是Ruby1.9，出现:invalid multibyte char(US-ASCII)的时候，通常表示代码源文件中有UTF-8字符，比如中文，根据Ruby1.9规范，必须在源文件的头部加上编码注解&lt;br /&gt;
#encoding: utf-8&lt;br /&gt;
并且代码的源文件格式必须时utf-8的。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>chrome中清除dns缓存</title>
   <link href="http://jiang-bo.github.com/blog/2011/12/07/clean-dns-cache-on-chrome"/>
   <updated>2011-12-07T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2011/12/07/clean-dns-cache-on-chrome</id>
   <content type="html">&lt;p&gt;web开发经常要做各种host绑定的切换，firefox下有个DNS Flusher插件，但没有chrome版本，其实在chrome下清除DNS缓存非常简单：&lt;br /&gt;
1、用chrome打开：chrome://net-internals/#dns&lt;br /&gt;
2、点击上面的“clean host cache”&lt;br /&gt;
为了方便使用，可以加个bookmark:)&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Mac上制作Ubuntu USB启动盘</title>
   <link href="http://jiang-bo.github.com/blog/2011/11/09/create_ubuntu_usb_startdisk_on_mac"/>
   <updated>2011-11-09T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2011/11/09/create_ubuntu_usb_startdisk_on_mac</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;Mac上制作Ubuntu USB启动盘&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、下载ubuntu iso镜像&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、将iso转换为img文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;$ hdiutil convert -format UDRW -o /path/to/generate/img/file /path/to/your/iso/file&lt;/p&gt;

&lt;p&gt;该命令会生成一个.img的磁盘镜像文件，但是mac osx会默认追加一个.dmg，即生成的文件后缀是.img.dmg，这个后缀没关系，可以忽略&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、查看USB的盘符&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;$ diskutil list&lt;/p&gt;

&lt;p&gt;/dev/disk0&lt;/p&gt;

&lt;p&gt;#:                       TYPE NAME                    SIZE       IDENTIFIER&lt;/p&gt;

&lt;p&gt;0:      GUID_partition_scheme                        *250.1 GB   disk0&lt;/p&gt;

&lt;p&gt;1:                        EFI                         209.7 MB   disk0s1&lt;/p&gt;

&lt;p&gt;2:                  Apple_HFS Macintosh HD            249.2 GB   disk0s2&lt;/p&gt;

&lt;p&gt;3:                 Apple_Boot Recovery HD             650.0 MB   disk0s3&lt;/p&gt;

&lt;p&gt;/dev/disk1&lt;/p&gt;

&lt;p&gt;#:                       TYPE NAME                    SIZE       IDENTIFIER&lt;/p&gt;

&lt;p&gt;0:     FDisk_partition_scheme                        *4.0 GB     disk1&lt;/p&gt;

&lt;p&gt;1:                 DOS_FAT_32 UNTITLED                4.0 GB     disk1s1&lt;/p&gt;

&lt;p&gt;该命令查看当前系统上挂载的磁盘，其中/dev/disk1是我的USB磁盘。不同的系统disk后的数字可能不一样，但一般都是diskN的模式&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、卸载USB磁盘&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;$ diskutil unmountDisk /dev/disk1&lt;/p&gt;

&lt;p&gt;Unmount of all volumes on disk1 was successful&lt;/p&gt;

&lt;p&gt;使用diskutil unmountDisk卸载USB磁盘，注意卸载（umount）与弹出(eject)的区别:)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、将镜像写入USB&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;$ sudo dd if=ubuntu.img.dmg of=/dev/rdisk1 bs=1m&lt;/p&gt;

&lt;p&gt;将第二步生成的img文件写入到USB磁盘/dev/rdisk1。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;六、弹出USB&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;$ diskutil eject /dev/disk1&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>vim支持GBK编码</title>
   <link href="http://jiang-bo.github.com/blog/2011/09/08/vim_gbk"/>
   <updated>2011-09-08T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2011/09/08/vim_gbk</id>
   <content type="html">&lt;p&gt;&lt;h2&gt;&lt;strong&gt;一、让ubuntu支持GBK编码&lt;/strong&gt;&lt;/h2&gt;
Ubuntu默认对中文只支持UTF-8编码，可以通过一些修改让Ubuntu支持GBK编码。&lt;/p&gt;

&lt;p&gt;首先用gedit /var/lib/locales/supported.d/local来修改 /var/lib/locales/supported.d/local文件，在文件中添加如下内容：&lt;br /&gt;
zh_CN.UTF- 8 UTF- 8&lt;br /&gt;
en_US.UTF- 8 UTF- 8&lt;br /&gt;
zh_CN.GBK GBK&lt;br /&gt;
zh_CN.GB2312 GB2312&lt;br /&gt;
接着用sudo dpkg-reconfigure --force locales强制更新设置
&lt;h2&gt;&lt;strong&gt;二、设置Vimrc支持GBK&lt;/strong&gt;&lt;/h2&gt;
set fileencodings=utf-8,gbk,gb2312&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Velocity源码分析（二）——渲染执行之Introspection</title>
   <link href="http://jiang-bo.github.com/blog/2011/08/26/velocity_introspection"/>
   <updated>2011-08-26T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2011/08/26/velocity_introspection</id>
   <content type="html">&lt;p&gt;&lt;div&gt;&lt;span style=&quot;font-size: large;&quot;&gt;&lt;strong&gt;一、何为Introspection&lt;/strong&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style=&quot;font-size: large;&quot;&gt;&lt;strong&gt;
&lt;/strong&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;Instrospection（自省，xing，“吾日三省吾身”的“省”）源自哲学术语，指的是一种自我检视的精神行为。&lt;/div&gt;
&lt;div&gt;&lt;em&gt;Introspection is the self-observation and reporting of conscious inner thoughts, desires and sensations. It is a conscious and purposive process relying on thinking, reasoning, and examining one's own thoughts, feelings, and, in more spiritual cases, one's soul. &lt;/em&gt;&lt;/div&gt;
&lt;div style=&quot;text-align: right;&quot;&gt;——Wikipedia&lt;/div&gt;
&lt;div&gt;在计算机科学中，借用了哲学中的Introspeciton术语，表示一种能够识别一个事物它是什么，知道什么，能做什么的能力。典型的应用场景是面向对象语言中的类型自省（type introspeciton）。&lt;/div&gt;
&lt;div&gt;&lt;em&gt;In computing, type introspection is a capability of some object-oriented programming languages to determine the type of an object at runtime.&lt;/em&gt;&lt;/div&gt;
&lt;div style=&quot;text-align: right;&quot;&gt;——Wikipedia&lt;/div&gt;
&lt;div&gt;以Java为例，Java提供了可以在运行时获取和检查JavaBean的接口API，实例如下：&lt;/div&gt;
&lt;pre class=&quot;brush:java&quot;&gt;import java.beans.BeanInfo;
import java.beans.Introspector;
import java.beans.IntrospectionException;
import java.beans.PropertyDescriptor;
public class SimpleBean{
    private final String name = &quot;SimpleBean&quot;;
    private int size;
    public String getName(){
        return this.name;
    }
    public int getSize(){
            return this.size;
    }
    public void setSize( int size ) {
        this.size = size;
    }
    public static void main( String[] args )            throws IntrospectionException   {
        BeanInfo info = Introspector.getBeanInfo( SimpleBean.class );
for ( PropertyDescriptor pd : info.getPropertyDescriptors() )             System.out.println( pd.getName() );
}
}&lt;/pre&gt;
&lt;div&gt;Introspector.getBeanInfo(SimpleBean.class)是Java提供的一个自省工具类，可以在运行时获取SimpleBean类的类型信息BeanInfo，包括属性名、方法名、Bean描述等等信息。&lt;/div&gt;
&lt;div&gt;查阅资料过程中发现有些人认为自省即反射（Reflection），反射即自省，因为Java中自省是通过反射实现的。我认为这两个概念还是有区别的，自省是一个目的或者说机制，是一个上层的接口封装，而反射是达到这个目的或者实现这个机制的方法，是底层的具体实现。&lt;/div&gt;
&lt;div&gt;&lt;span style=&quot;font-size: large;&quot;&gt;&lt;strong&gt;二、Velocity中的渲染执行&lt;/strong&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style=&quot;font-size: large;&quot;&gt;&lt;strong&gt;
&lt;/strong&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style=&quot;font-size: medium;&quot;&gt;&lt;strong&gt;2.1 velocity中Introspection概述&lt;/strong&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style=&quot;font-size: medium;&quot;&gt;&lt;strong&gt;
&lt;/strong&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;Velocity作为一种模板语言允许我们向Context中放置一些JavaBean实例，并在模板中通过变量方式引用。如下所示：&lt;/div&gt;
&lt;div&gt;Welcome! ${person.name} !&lt;/div&gt;
&lt;div&gt;该模板中有一个引用变量${person.name}，在执行渲染时必须要知道person是个什么东东，person.name又是个什么东东，这里就需要自省机制发挥作用。&lt;/div&gt;
&lt;div&gt;Veloctiy的的自省机制实现位于源码包org.apache.velocity.util.introspection中，其主要类图结构如下：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;/images/uploads/2011/08/class-structure.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-63&quot; title=&quot;class-structure.png&quot; src=&quot;/images/uploads/2011/08/class-structure.png&quot; alt=&quot;&quot; width=&quot;863&quot; height=&quot;351&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Uberspect中定义了渲染执行时所需的主要接口。该接口主要提供四个方法：&lt;/div&gt;
&lt;div&gt;
&lt;ol&gt;
	&lt;li&gt;getIterator()：支持迭代#foreache&lt;/li&gt;
	&lt;li&gt;getMethod()：支持方法调用&lt;/li&gt;
	&lt;li&gt;getPropertyGet()：支持获取属性值&lt;/li&gt;
	&lt;li&gt;getPropertySet()：支持设置属性值&lt;/li&gt;
&lt;/ol&gt;
Uberspect有个默认的实现UberspectImpl，该实现使用默认的Introspector完成基本的自省功能。Introspector扩展自基类IntrospectorBase，增添异常日志功能。&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;
&lt;div&gt;IntrospectorBase内部维护了一个introspectCache，用于缓存已经完成自省的类和方法信息。&lt;/div&gt;
&lt;div&gt;IntrospectorCacheImpl内通过一个HashMap维护一个class与其对应的类型信息，类型信息用一个ClassMap表示。&lt;/div&gt;
&lt;div&gt;一个ClassMap内部维护了一个MethodCache，用于缓存该类已经解析出得方法信息。&lt;/div&gt;
&lt;div&gt;MethodMap表示一个方法信息。&lt;/div&gt;
&lt;div&gt;&lt;span style=&quot;font-size: medium;&quot;&gt;&lt;strong&gt;2.2 渲染执行详细流程&lt;/strong&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style=&quot;font-size: medium;&quot;&gt;&lt;strong&gt;
&lt;/strong&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;下面一如下模板为例，解释velocity中introspection的实际执行：&lt;/div&gt;
&lt;div&gt;template.vm&lt;/div&gt;
&lt;div&gt;${person.sayHi()}! I'm ${person.name}&lt;/div&gt;
&lt;div&gt;该模板的作用表示分别调用context中名为person的对象的sayHi()方法和name属性。该模板经过语法解析生成的AST如下（关于AST解析请参考上一篇velocity源码分析）：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;/images/uploads/2011/08/syntax-tree.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-64&quot; title=&quot;syntax-tree.png&quot; src=&quot;/images/uploads/2011/08/syntax-tree.png&quot; alt=&quot;&quot; width=&quot;483&quot; height=&quot;185&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;图1.语法解析后的AST&lt;/div&gt;
&lt;div&gt;${person.say()}被解析为一个拥有AST子节点的ASTReference节点，”! I’m”为一个ASTText节点，$person.name被解析为一个拥有ASTIdentifier子节点的ASTReference节点，”。”被解析为一个ASTText节点。&lt;/div&gt;
&lt;div&gt;引擎从根节点开始执行渲染ASTprocess的render方法主要是遍历子节点，依次执行子节点的渲染方法。&lt;/div&gt;
&lt;div&gt;ASTReference.render()方法主要调用其内部的execute（）方法获取实际的引用值，execute代码如下：&lt;/div&gt;
&lt;pre class=&quot;brush:java&quot;&gt;    public Object execute(Object o, InternalContextAdapter context)
        throws MethodInvocationException
    {&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;        if (referenceType == RUNT)&lt;br /&gt;
            return null;&lt;br /&gt;
        Object result = getVariableValue(context, rootString);&lt;/p&gt;

&lt;p&gt;        if (result == null &amp;amp;&amp;amp; !strictRef)&lt;br /&gt;
        {&lt;br /&gt;
            return EventHandlerUtil.invalidGetMethod(rsvc, context,&lt;br /&gt;
                    &quot;$&quot; + rootString, null, null, uberInfo);&lt;br /&gt;
        }&lt;/p&gt;

&lt;p&gt;        try&lt;br /&gt;
        {&lt;br /&gt;
            Object previousResult = result;&lt;br /&gt;
            int failedChild = -1;&lt;br /&gt;
            for (int i = 0; i &amp;lt; numChildren; i++)&lt;br /&gt;
            {&lt;br /&gt;
                if (strictRef &amp;amp;&amp;amp; result == null)&lt;br /&gt;
                {&lt;br /&gt;
                    String name = jjtGetChild(i).getFirstToken().image;&lt;br /&gt;
                    throw new VelocityException(&quot;Attempted to access '&quot;&lt;br /&gt;
                        + name + &quot;' on a null value at &quot;&lt;br /&gt;
                        + Log.formatFileString(uberInfo.getTemplateName(),&lt;br /&gt;
                        + jjtGetChild(i).getLine(), jjtGetChild(i).getColumn()));&lt;br /&gt;
                }&lt;br /&gt;
                previousResult = result;&lt;br /&gt;
                //遍历执行子节点的execute方法&lt;br /&gt;
                result = jjtGetChild(i).execute(result,context);&lt;br /&gt;
                if (result == null &amp;amp;&amp;amp; !strictRef)  // If strict and null then well catch this&lt;br /&gt;
                                                   // next time through the loop&lt;br /&gt;
                {&lt;br /&gt;
                    failedChild = i;&lt;br /&gt;
                    break;&lt;br /&gt;
                }&lt;br /&gt;
            }&lt;/p&gt;

&lt;p&gt;            /**&lt;br /&gt;
            ......&lt;br /&gt;
            */&lt;br /&gt;
    }
&lt;div&gt;1.execute方法先根据对象的名字从context中获取对象实例。&lt;/div&gt;
&lt;div&gt;2.遍历所有子节点，执行子节点的execute方法。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;span style=&quot;font-size: small;&quot;&gt;2.2.1 ASTMethod节点渲染&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;ASTMethod的execute方法中关键代码如下：&lt;/div&gt;
&lt;div&gt;
&lt;pre class=&quot;brush:java&quot;&gt;    public Object execute(Object o, InternalContextAdapter context)
        throws MethodInvocationException
    {
        if (o instanceof NullInstance &amp;amp;&amp;amp; ((NullInstance) o).isNotNull()) {
            return o;
        }&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;        /*&lt;br /&gt;
         *  获取方法信息&lt;br /&gt;
         */&lt;/p&gt;

&lt;p&gt;        VelMethod method = null;&lt;/p&gt;

&lt;p&gt;        Object [] params = new Object[paramCount];&lt;/p&gt;

&lt;p&gt;        try&lt;br /&gt;
        {&lt;br /&gt;
            // 计算参数类型&lt;br /&gt;
            final Class[] paramClasses = paramCount &amp;gt; 0 ? new Class[paramCount] : ArrayUtils.EMPTY_CLASS_ARRAY;&lt;/p&gt;

&lt;p&gt;            for (int j = 0; j &amp;lt; paramCount; j++)&lt;br /&gt;
            {&lt;br /&gt;
                params[j] = jjtGetChild(j + 1).value(context);&lt;/p&gt;

&lt;p&gt;                if (params[j] != null)&lt;br /&gt;
                {&lt;br /&gt;
                    paramClasses[j] = params[j].getClass();&lt;br /&gt;
                }&lt;br /&gt;
            }&lt;/p&gt;

&lt;p&gt;             //从cache中获取Method信息&lt;br /&gt;
            MethodCacheKey mck = new MethodCacheKey(methodName, paramClasses);&lt;br /&gt;
            IntrospectionCacheData icd =  context.icacheGet( mck );&lt;/p&gt;

&lt;p&gt;            if ( icd != null &amp;amp;&amp;amp; (o != null &amp;amp;&amp;amp; icd.contextData == o.getClass()) )&lt;br /&gt;
            {&lt;br /&gt;
                method = (VelMethod) icd.thingy;&lt;br /&gt;
            }&lt;br /&gt;
            else&lt;br /&gt;
            {&lt;br /&gt;
                //缓存未命中，调用UberIntrospectImpl.getMethod()执行自省&lt;br /&gt;
                method = rsvc.getUberspect().getMethod(o, methodName, params, new Info(getTemplateName(), getLine(), getColumn()));&lt;/p&gt;

&lt;p&gt;                if ((method != null) &amp;amp;&amp;amp; (o != null))&lt;br /&gt;
                {&lt;br /&gt;
                    icd = new IntrospectionCacheData();&lt;br /&gt;
                    icd.contextData = o.getClass();&lt;br /&gt;
                    icd.thingy = method;&lt;br /&gt;
                    //更新缓存&lt;br /&gt;
                    context.icachePut( mck, icd );&lt;br /&gt;
                }&lt;br /&gt;
            }&lt;/p&gt;

&lt;p&gt;            if (typeOptimum &amp;amp;&amp;amp; method instanceof VelMethodImpl) {&lt;br /&gt;
                this.recordedData = icd;&lt;br /&gt;
            }&lt;/p&gt;

&lt;p&gt;            /*&lt;br /&gt;
             *  ....&lt;br /&gt;
             */&lt;br /&gt;
    }

&lt;div&gt;1.首先从IntrospectionCache中查找已经缓存的自省结果信息&lt;/div&gt;
&lt;div&gt;2.如果未找到，则使用uberspector进行自省，获取方法信息，并缓存自省结果。&lt;/div&gt;
&lt;div&gt;3.调用自省返回的VelMethod的invoke方法，获取执行结果。&lt;/div&gt;
&lt;div&gt;其中，获取方法信息的过程&lt;/div&gt;
&lt;div&gt;method = rsvc.getUberspect().getMethod(o, methodName, params, new Info(getTemplateName(), getLine(), getColumn()));&lt;/div&gt;
&lt;div&gt;实际调用就是UberspectImpl.getMethod()方法，该方法执行流程如下：&lt;/div&gt;
&lt;div&gt;
&lt;pre class=&quot;brush:java&quot;&gt;    public VelMethod getMethod(Object obj, String methodName, Object[] args, Info i)
            throws Exception
    {
        if (obj == null)
        {
            return null;
        }
        //调用Inspector.getMethod()
        Method m = introspector.getMethod(obj.getClass(), methodName, args);
        if (m != null)
        {&lt;/pre&gt;
&lt;pre class=&quot;brush:java&quot;&gt;            //封装VelMethodImpl
            return new VelMethodImpl(m);
        }&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;        Class cls = obj.getClass();&lt;br /&gt;
        // if it's an array&lt;br /&gt;
        if (cls.isArray())&lt;br /&gt;
        {&lt;br /&gt;
            // check for support via our array-&amp;gt;list wrapper&lt;br /&gt;
            m = introspector.getMethod(ArrayListWrapper.class, methodName, args);&lt;br /&gt;
            if (m != null)&lt;br /&gt;
            {&lt;br /&gt;
                // and create a method that knows to wrap the value&lt;br /&gt;
                // before invoking the method&lt;br /&gt;
                return new VelMethodImpl(m, true);&lt;br /&gt;
            }&lt;br /&gt;
        }&lt;br /&gt;
        // watch for classes, to allow calling their static methods (VELOCITY-102)&lt;br /&gt;
        else if (cls == Class.class)&lt;br /&gt;
        {&lt;br /&gt;
            m = introspector.getMethod((Class)obj, methodName, args);&lt;br /&gt;
            if (m != null)&lt;br /&gt;
            {&lt;br /&gt;
                return new VelMethodImpl(m);&lt;br /&gt;
            }&lt;br /&gt;
        }&lt;br /&gt;
        return null;&lt;br /&gt;
    }

&lt;div&gt;该方式实际调用Introspector.getMethod()方法。&lt;/div&gt;
&lt;div&gt;
&lt;pre class=&quot;brush:java&quot;&gt;    public Method getMethod(final Class c, final String name, final Object[] params)
        throws IllegalArgumentException
    {
        try
        {
            //调用父类IntrospectorBase.getMethod()方法
            return super.getMethod(c, name, params);
        }
        catch(MethodMap.AmbiguousException ae)
        {
           /*异常处理*/
        }&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;        return null;&lt;br /&gt;
    }

&lt;div&gt;Introspector.getMethod()实际只是扩展了其父类的getMethod方法，增加了异常日志功能。&lt;/div&gt;
&lt;div&gt;IntrospectorBase.getMethod()代码如下：&lt;/div&gt;
&lt;div&gt;
&lt;pre class=&quot;brush:java&quot;&gt;    public Method getMethod(final Class c, final String name, final Object[] params)
            throws IllegalArgumentException,MethodMap.AmbiguousException
    {
        if (c == null)
        {
            throw new IllegalArgumentException (&quot;class object is null!&quot;);
        }
        
        if (params == null)
        {
            throw new IllegalArgumentException(&quot;params object is null!&quot;);
        }&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;        IntrospectorCache ic = getIntrospectorCache();&lt;/p&gt;

&lt;p&gt;        ClassMap classMap = ic.get(c);&lt;br /&gt;
        if (classMap == null)&lt;br /&gt;
        {&lt;br /&gt;
            classMap = ic.put(c);&lt;br /&gt;
        }&lt;/p&gt;

&lt;p&gt;        return classMap.findMethod(name, params);&lt;br /&gt;
    }

&lt;div&gt;该方法首先获取从IntrospectorCache中获取表示类信息的classMap，如果没找到则在cache中put该类型信息。有意思的是这里没有常见的缓存未命中直接查询的过程，而是直接更新缓存，也就意味着put方法里有构造类型信息的过程。&lt;/div&gt;
&lt;div&gt;IntrospectorCache.put()代码如下&lt;/div&gt;
&lt;div&gt;
&lt;pre class=&quot;brush:java&quot;&gt;    public ClassMap put(final Class c)
    {
        //构造ClassMap
        final ClassMap classMap = new ClassMap(c, log);
        synchronized (classMapCache)
        {
            classMapCache.put(c, classMap);
            classNameCache.add(c.getName());
        }
        return classMap;
    }&lt;/pre&gt;
&lt;/div&gt;
&lt;div&gt;put方法首先构造一个ClassMap，然后更新classMapCache。&lt;/div&gt;
&lt;div&gt;构造ClassMap的过程如下：&lt;/div&gt;
&lt;div&gt;
&lt;pre class=&quot;brush:java&quot;&gt;    public ClassMap(final Class clazz, final Log log)
    {
        this.clazz = clazz;
        this.log = log;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;        if (debugReflection &amp;amp;&amp;amp; log.isDebugEnabled())&lt;br /&gt;
        {&lt;br /&gt;
            log.debug(&quot;=================================================================&quot;);&lt;br /&gt;
            log.debug(&quot;== Class: &quot; + clazz);&lt;br /&gt;
        }&lt;/p&gt;

&lt;p&gt;        methodCache = createMethodCache();&lt;/p&gt;

&lt;p&gt;        if (debugReflection &amp;amp;&amp;amp; log.isDebugEnabled())&lt;br /&gt;
        {&lt;br /&gt;
            log.debug(&quot;=================================================================&quot;);&lt;br /&gt;
        }&lt;br /&gt;
    }

&lt;div&gt;关键是构造一个MethodCache，createMethodCache过程如下：&lt;/div&gt;
&lt;div&gt;
&lt;pre class=&quot;brush:java&quot;&gt;    private MethodCache createMethodCache()
    {
        MethodCache methodCache = new MethodCache(log);
        for (Class classToReflect = getCachedClass(); classToReflect != null ; classToReflect = classToReflect.getSuperclass())
        {
            if (Modifier.isPublic(classToReflect.getModifiers()))
            {
                populateMethodCacheWith(methodCache, classToReflect);
            }
            Class [] interfaces = classToReflect.getInterfaces();
            for (int i = 0; i &amp;lt; interfaces.length; i++)
            {
                populateMethodCacheWithInterface(methodCache, interfaces[i]);
            }
        }
        // return the already initialized cache
        return methodCache;
    }&lt;/pre&gt;
&lt;/div&gt;
&lt;div&gt;createMethodCache()首先构造一个MethodCache实例，然后通过反射获得类型的public方法信息，并递归的获取其实现的接口方法信息。&lt;/div&gt;
&lt;div&gt;IntrospectorBase.getMethod()方法获取到该ClassMap后，通过classMap.getMethod()返回一个需要的method，由于多态的存在，一个类会有多个同名方法，所以getMethod()过程中有一个根据参数类型寻找最佳匹配的方法getBestMatch（）这里有个循环遍历所有方法，并且比较所有参数类型的过程，而且这个过程在每次模板渲染执行时都会进行，代价很高，因此尽量少在放入模板的类中写多态方法有助提高渲染执行性能。&lt;/div&gt;
&lt;div&gt;至此一个ClassMap构造完毕，即一个类的自省过程完成。UberinspectorImpl成功的拿到了需要的方法信息，然后将Method封装VelMethodImpl返回。&lt;/div&gt;
&lt;div&gt;ASTMethod节点执行渲染时调用invoke方法实际调用的就是Method.invoke()，获得方法执行结果写入输出流中，完成渲染。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;span style=&quot;font-size: small;&quot;&gt;2.2.2 ASTIdentifier节点渲染&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;ASTIdentifier的execute方法中关键代码如下&lt;/div&gt;
&lt;div&gt;（TODO：ASTIndentifier.execute()代码）&lt;/div&gt;
&lt;div&gt;1.从IntrospectionCache中查找已经缓存的信息。&lt;/div&gt;
&lt;div&gt;2.如果缓存未命中，使用uberspector进行自省，并缓存自省结果&lt;/div&gt;
&lt;div&gt;3.调用自省的返回的VelPropertyGet的invoke方法，反射执行起get方法。&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;UberspectImpl.getPropertyGet()方法关键代码如下：&lt;/div&gt;
&lt;div&gt;
&lt;pre class=&quot;brush:java&quot;&gt;    public VelPropertyGet getPropertyGet(Object obj, String identifier, Info i)
            throws Exception
    {
        if (obj == null)
        {
            return null;
        }&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;        Class claz = obj.getClass();&lt;/p&gt;

&lt;p&gt;         // 构造get&quot;属性名&quot;()形式的Executor&lt;br /&gt;
        AbstractExecutor executor = new PropertyExecutor(log, introspector, claz, identifier);&lt;/p&gt;

&lt;p&gt;        //构造一个Map形式的Executor&lt;br /&gt;
        if (!executor.isAlive())&lt;br /&gt;
        {&lt;br /&gt;
            executor = new MapGetExecutor(log, claz, identifier);&lt;br /&gt;
        }&lt;/p&gt;

&lt;p&gt;        // 构造get(&quot;属性名&quot;)形式的Executor&lt;/p&gt;

&lt;p&gt;        if (!executor.isAlive())&lt;br /&gt;
        {&lt;br /&gt;
            executor = new GetExecutor(log, introspector, claz, identifier);&lt;br /&gt;
        }&lt;br /&gt;
        //构建is&quot;属性名&quot;形式的executor&lt;br /&gt;
        if (!executor.isAlive())&lt;br /&gt;
        {&lt;br /&gt;
            executor = new BooleanPropertyExecutor(log, introspector, claz,&lt;br /&gt;
                                                   identifier);&lt;br /&gt;
        }&lt;/p&gt;

&lt;p&gt;        return (executor.isAlive()) ? new VelGetterImpl(executor) : null;&lt;br /&gt;
    }

&lt;div&gt;1.首先根据对象的class类型和属性名构造一个get”属性名”的方法的PropertyExecutor。&lt;/div&gt;
&lt;div&gt;2.如果未找到get”属性名”的方法，则尝试构造一个Map.key形式的MapGetExecutor。&lt;/div&gt;
&lt;div&gt;3.如果也不是Map.key形式，尝试构造一个get(“属性名”)的GetExecutor。&lt;/div&gt;
&lt;div&gt;4.如果还没找到，则尝试构造一is”属性名”形式的BooleanPropertyExecutor。&lt;/div&gt;
&lt;div&gt;5.最终返回一个封装了Executor的VelGetImpl，如果未找到则返回null。&lt;/div&gt;
&lt;div&gt;所有的Executor均扩展自AbstractExecutor，VelGetImpl通过内置一个executor执行方法调用。Executor类图关系如下&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;/images/uploads/2011/08/Excuter-class-structure.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-76&quot; title=&quot;Executor类图结构&quot; src=&quot;/images/uploads/2011/08/Excuter-class-structure.png&quot; alt=&quot;&quot; width=&quot;682&quot; height=&quot;380&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Executor实现中除MapGetExecutor外，其余的Executor均通过内置一个introspector实现方法的构建，过程与上述ASTMethod节点渲染过程中introspector.getMethod()一致，只是方法名做了封装，如GetExecutor的方法名为get， PropertyExecutor的方法名为get”属性名”， BooleanPropertyExecutor方法名为is”属性名”，具体构建流程不再赘述。&lt;/div&gt;
&lt;div&gt;最终，ASTIndentifier.execute()方法通过UberInspectImpl.getPropertyGet()获得VelGetImpl，并调用VelGetImpl.invoke()获取方法执行的结果，写入输出流，完成渲染。&lt;/div&gt;
&lt;div&gt;UberInspectImpl.getPropertySet()的执行过程于getPropertyGet()大体一致，区别在于获取的是VelSetImpl，内置了SetExecutor，SetExecutor有三个扩展对应为MapSetExecutor（Map.key=value形式），PutExecutor（put(key, value)形式），SetPropertyExecutor（set”属性名”(value)形式）。其内部同样使用introspector.getMethod()方法构建Method，通过反射执行设置属性值。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;span style=&quot;font-size: large;&quot;&gt;三、总结&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;总的来说，作为模板语言velocity提供了可用的自省机制完成模板中对象引用及方法执行的的渲染。并在自省过程中提供了有效的缓存机制用以提升自省效率。但每次依旧需要解析AST，反射执行引用节点的方法，效率方面似乎还有优化的余地。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;span style=&quot;font-size: large;&quot;&gt;参考文档&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;《Java Introspeciton》 http://download.oracle.com/javase/tutorial/javabeans/introspection/index.html&lt;/div&gt;
&lt;div&gt;《Type Introspection》 http://en.wikipedia.org/wiki/Type_introspection&lt;/div&gt;
&lt;div&gt;《Introspection》http://en.wikipedia.org/wiki/Introspection&lt;/div&gt;
&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Velocity源码分析（一）——概述</title>
   <link href="http://jiang-bo.github.com/blog/2011/08/19/velocity_overview"/>
   <updated>2011-08-19T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2011/08/19/velocity_overview</id>
   <content type="html">&lt;p&gt;&lt;h2&gt;一、概述&lt;/h2&gt;
Velocity模板引擎处理机制分为五个基本步骤：
&lt;ol&gt;
	&lt;li&gt;引擎初始化，通过设置的引擎属性初始化引擎，包括国际化支持，ResourceLoader设置，字符编码等。&lt;/li&gt;
	&lt;li&gt;获取并解析模板文件，首先通过资源加载器（ResourceLoader）将模板文件加载到内存（转化为InputStream），然后通过AST（Abstract Syntax Tree）解析器将InputStream解析为一个AST。&lt;/li&gt;
	&lt;li&gt;创建一个Context&lt;/li&gt;
	&lt;li&gt;将模板渲染所需的参数放入context&lt;/li&gt;
	&lt;li&gt;执行模板渲染，产生输出流。渲染过程中通过遍历该模板对应的AST，调用相应节点的处理器执行渲染。&lt;/li&gt;
&lt;/ol&gt;
整个处理流程如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/images/uploads/2011/08/Velocity-process-structure.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-59&quot; title=&quot;Velocity处理流程&quot; src=&quot;/images/uploads/2011/08/Velocity-process-structure.png&quot; alt=&quot;&quot; width=&quot;619&quot; height=&quot;407&quot; /&gt;&lt;/a&gt;
&lt;h2&gt;二、详细渲染流程&lt;/h2&gt;
下面以一个简单的模板template.vm为例，详细解释渲染过程。&lt;br /&gt;
VelocityMergeTest.java
&lt;pre class=&quot;brush:java&quot;&gt;public class VelocityMergeTest {&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;public static void main(String[] args) {&lt;br /&gt;
VelocityEngine ve = new VelocityEngine();&lt;br /&gt;
ve.setProperty(Velocity.RESOURCE_LOADER, &quot;class&quot;);&lt;br /&gt;
ve.setProperty(&quot;class.resource.loader.class&quot;,&lt;br /&gt;
&quot;org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader&quot;);&lt;br /&gt;
try {&lt;br /&gt;
//引擎初始化&lt;br /&gt;
ve.init();&lt;br /&gt;
//加载解析模板&lt;br /&gt;
Template tp = ve.getTemplate(&quot;template.vm&quot;);&lt;br /&gt;
//创建context&lt;br /&gt;
Context context = new VelocityContext();&lt;br /&gt;
//设置Context中参数值&lt;br /&gt;
context.put(&quot;foo&quot;, &quot;VV&quot;);&lt;br /&gt;
StringWriter writer = new StringWriter();&lt;br /&gt;
//执行渲染&lt;br /&gt;
tp.merge(context, writer);&lt;br /&gt;
System.out.println(writer.toString());&lt;br /&gt;
} catch (Exception e) {&lt;br /&gt;
}
}&lt;br /&gt;
}
template.vm
&lt;pre class=&quot;brush:xml&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
Hello $foo world!
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/pre&gt;
&lt;h3&gt;1.引擎初始化&lt;/h3&gt;
ve.setProperty(&quot;class.resource.loader.class&quot;,&lt;br /&gt;
&quot;org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader&quot;);&lt;br /&gt;
设置引擎的资源加载使用ClasspathResourceLoader。&lt;br /&gt;
ve.init()执行引擎的初始化。
&lt;h3&gt;2.加载解析模板&lt;/h3&gt;
当执行ve.getTemplate(&quot;template.vm&quot;)时，首先通过ResourceLoader将tempalte加载为InputStream，然后通过Parser生成如下Token集合：&lt;br /&gt;
{[&amp;lt;html&amp;gt; &amp;lt;body&amp;gt; Hello], [$foo], [world! &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; ]}，&lt;br /&gt;
可以发现velocity根本不关系模板最终要渲染出来的是html还是什么的其他的东西，也就以为这所有的html标签对velocity来讲都是纯文本。&lt;br /&gt;
最终构建的AST如下&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/images/uploads/2011/08/AST.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-60&quot; title=&quot;AST&quot; src=&quot;/images/uploads/2011/08/AST.png&quot; alt=&quot;&quot; width=&quot;367&quot; height=&quot;169&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;根节点下有三个子节点：
&lt;ol&gt;
	&lt;li&gt;[&amp;lt;html&amp;gt; &amp;lt;body&amp;gt; Hello]对应的ASTText节点；&lt;/li&gt;
	&lt;li&gt;[$foo]对应的ASTReference节点；&lt;/li&gt;
	&lt;li&gt;[world! &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; ]对应的ASTText节点&lt;/li&gt;
&lt;/ol&gt;
Velocity引擎在这里有个优化策略，可以针对生成的语法树进行cache。
&lt;h3&gt;3.创建context并设置参数&lt;/h3&gt;
Context context = new VelocityContext();&lt;br /&gt;
context.put(&quot;foo&quot;, &quot;VV&quot;);&lt;br /&gt;
创建一个context，并在其中放入一个foo=VV的参数。
&lt;h3&gt;4.执行渲染&lt;/h3&gt;
当执行tp.merge(context, writer);时，模板遍历其对应的AST树，执行每个节点的渲染过程。如ASTText节点只是简单的将文本写入writer。ASTReference节点需要从context中获取引用的参数foo的值VV，将$foo替换，并写入到writer中。Velocity的AST中有多种节点，如ASTIdentitor等，有些需要反射机制处理。当整个AST遍历结束，也就意味着模板渲染结束，渲染的结果位于writer流中。
&lt;h2&gt;三、关于AST解析&lt;/h2&gt;
Velocity作为模板语言，其核心在与模板文件的解析，构建AST。Velocity的解析器是通过JavaCC构建的，JavaCC（Java Complier Complier）是一个用于生成解析器的工具，可以根据语法定义（.jj文件）生成用于校验一份文本是否符合该语法定义的java代码。JJTree是JavaCC中提供的一种根据语法定义（.jjt文件）生成构建符合该语法定义的文本的语法树的java代码的工具。&lt;br /&gt;
Velocity源码包中提供了用于构建velocity语法解析的的jjt文件，位于src/parser/Parser.jjt。可以自己手动从源码构建Velocity的解析器。步骤如下：&lt;br /&gt;
1.下载安装JavaCC，到http://javacc.java.net/下载即可，velocity的解析器需要3.2版本以上。下载后解压即可。&lt;br /&gt;
2.使用JJTree生成节点定义：&lt;br /&gt;
$ javacc-5.0/bin/jjtree Parser.jjt&lt;br /&gt;
这一过程中会生成节点定义的Java文件和Parser.jj语法定义文件&lt;br /&gt;
3.使用JavaCC生成解析器&lt;br /&gt;
$ javacc-5.0/bin/javacc Parser.jj&lt;br /&gt;
最终会生成Parser.java解析器和个节点定义。
&lt;h2&gt;参考资料&lt;/h2&gt;
《Velocity Developer Guide》&lt;a href=&quot;http://velocity.apache.org/engine/devel/developer-guide.html&quot;&gt;http://velocity.apache.org/engine/devel/developer-guide.html&lt;/a&gt;
《JavaCC》&lt;a href=&quot;http://javacc.java.net/&quot;&gt;http://javacc.java.net/&lt;/a&gt;
《Velocity源码分析》&lt;a href=&quot;http://www.khotyn.com/2011/07/22/velocity_sourcecode/&quot;&gt;http://www.khotyn.com/2011/07/22/velocity_sourcecode/&lt;/a&gt;
《Velocity的一些优化记录》&lt;a href=&quot;http://agapple.iteye.com/blog/1051724&quot;&gt;http://agapple.iteye.com/blog/1051724&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Webx3源码分析－容器结构</title>
   <link href="http://jiang-bo.github.com/blog/2011/08/17/webx3-container-structure"/>
   <updated>2011-08-17T19:32:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2011/08/17/webx3-container-structure</id>
   <content type="html">&lt;h3&gt;一、Webx 框架概述&lt;/h3&gt;

&lt;p&gt;Webx是一套基于Java Servlet API构建的通用Web框架。整个Webx框框架层次分为三层：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/webx/webx-framework-layer.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;SpringExt：提供了基于Spring的通用扩展机制&lt;/li&gt;
&lt;li&gt;WebxFramework：基于Servlet API，提供Web基础服务，如Spring初始化，日志初始化，接受请求，错误处理，开发模式等。Webx Framework只是对Servlet和spring的基础封装，并不关心Web框架中具体服务的处理，如Action处理，表单处理等。因此，可以在Webx Framework上扩展多种风格的Web框架。&lt;/li&gt;
&lt;li&gt;Webx Turbine：基于Webx Framework，提供具体的网页功能，如表单处理，Action相应处理等&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;二、Webx Framework容器结构&lt;/h3&gt;

&lt;h4&gt;1.1组件化应用结构&lt;/h4&gt;

&lt;p&gt;Webx Framework是基于组件化风格构建的，它将一个应用划分一个Webx应用包含至少一个组件组 (WebxComponents)，一个组件组由多个组件(WebxComponent)构成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/webx/webx-component.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Webx Framework中定义了WebxComponents接口和WebxComponent接口，分别表示一组组件的信息和一个组件的描述。
组件化的应用结构反应在容器上即应用中级联的父子容器的结构关系，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/webx/webx-context-structure.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Webx Framework将一个Web应用分解成多个小应用模块：app1, app2，等。每个应用模块独享一个子容器（Sub Context），共享根容器（Root Context）。子容器之间的beans无法相互注入，但是所有小应用都共享一个Root Context。根容器的bean可以被注入到子容器的bean中；反之不可以。&lt;/p&gt;

&lt;h4&gt;1.2 基于Spring的容器类扩展&lt;/h4&gt;

&lt;p&gt;为实现上述应用组件化结构，Webx Framework在在Spring容器基础上按照组件化风格进行扩展：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/webx/webx-container.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;com.alibaba.citrus.webx.context.XmlWebApplicationContext是Webx框架的从XML文件中装配的，用于Web应用环境的Application Context，扩展自Spring的org.springframework.web.context.support.XmlWebApplicationContext，主要扩展点如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;支持SpringExt的捐献(ConfigurationPoint)机制（SpringExt在后面文章中讲解）&lt;/li&gt;
&lt;li&gt;实现了ResourceLoadingExtendable接口，扩展的resource loading机制。假如ResourceLoadingExtender 被设置，则使用它来装载资源，否则使用默认的装载器。&lt;/li&gt;
&lt;li&gt;默认开启annotation config，相当于&amp;lt;context:annotation-config/&gt;。&lt;/li&gt;
&lt;li&gt;假如parentResolvableDependenciesAccessible==true，则支持从parent context中取得预先置入resolvableDependencies中的对象。默认为true。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;ResourceLoadingXmlWebApplicationContext继承自XmlWebApplicationContext，扩展了从resource loading service中装载的功能。WebxApplicationContext是用于Webx框架的application context。直接继承自ResourceLoadingXmlWebApplicationContext，扩展了取得默认Spring配置的实现，默认Root容器的配置文件位于WEB-INF/webx.xml，子容器的配置文件位于WEB-INF/webx-&lt;em&gt;.xml（&lt;/em&gt;代表component名）。由于继承关系，WebxApplicationContext继承了负累所有的特性，在原来Spring容器XmlWebApplicationContext基础之上扩展如下功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;支持SpringExt，包括configuration point和resource loading支持&lt;/li&gt;
&lt;li&gt;定义默认容器配置文件位置&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;WebxComponentsContext和WebxComponentContext直接扩展自WebxApplicationContext，分别对应为WebxComponents和WebxComponent的容器。&lt;/p&gt;

&lt;p&gt;WebxComponentsContext中内置了一个WebxComponentsLoader用于装载Webx components，并且覆写了postProcessBeanFactory()处理定制BeanFactory，以及finishRefresh()处理子容器的刷新。&lt;/p&gt;

&lt;p&gt;WebxComponentContext包含了对应的WebxComponent实例，并将其注入到容器中，即在一个WebxComponentContext中，引用的WebxComponent均是其对应的component实例。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Eclipse中debug maven jetty应用</title>
   <link href="http://jiang-bo.github.com/blog/2011/08/10/eclipse-debug-maven-jetty"/>
   <updated>2011-08-10T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2011/08/10/eclipse-debug-maven-jetty</id>
   <content type="html">&lt;p&gt;Maven和Jetty有很好的集成，可以方便的使用mvn jetty:run 启动一个web应用，但是默认的maven-jetty插件并没有开启debug模式，而日常开发中难免需要用IDE debug引用。下面描述下如何配置eclipse，使其可以进行maven-jetty项目的debug。
&lt;h2&gt; &lt;span class=&quot;Apple-style-span&quot; style=&quot;font-size: 26px; font-weight: bold;&quot;&gt;&lt;strong&gt;1.首先设置启动方式。&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
在Ecipse -&amp;gt;Run-&amp;gt;External Tools -&amp;gt;External Tool Configuration...中打开配置窗口，选中Program节点，双击新建一个新的配置。&lt;/p&gt;

&lt;p&gt;Name自定义，Main Tab下，Location设置为mvn命令的路径，Working Directory设置为需要进行debug的项目目录，Arguments设置为jetty:run&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/images/uploads/2011/08/Run.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-45&quot; title=&quot;Run&quot; src=&quot;/images/uploads/2011/08/Run.png&quot; alt=&quot;&quot; width=&quot;702&quot; height=&quot;664&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在Envriroment Tab中新建一个环境变量MAVEN_OPTS，值为&lt;/p&gt;

&lt;p&gt;-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8089,server=y,suspend=y&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/images/uploads/2011/08/MAVEN_OPTS.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-46&quot; title=&quot;MAVEN_OPTS&quot; src=&quot;/images/uploads/2011/08/MAVEN_OPTS.png&quot; alt=&quot;&quot; width=&quot;702&quot; height=&quot;664&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;点击Apply，保存配置；close，关闭窗口。
&lt;h2&gt;2.设置Debug信息&lt;/h2&gt;
打开Eclipse-&amp;gt;Run-&amp;gt;Debug Configurations窗口，在左侧列表中选择新建一个 Remote Java Application配置。在Connect Tab下，Project设置为当前需要debug的项目，Host设置为localhost，端口为8089（上面MAVEN_OPTS里的address=8089）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/images/uploads/2011/08/debug.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-47&quot; title=&quot;debug&quot; src=&quot;/images/uploads/2011/08/debug.png&quot; alt=&quot;&quot; width=&quot;719&quot; height=&quot;720&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;点击Apply，保存配置，close，关闭窗口&lt;/p&gt;

&lt;p&gt;&amp;nbsp;
&lt;h2&gt;&lt;strong&gt;3.运行应用。&lt;/strong&gt;&lt;/h2&gt;
Eclipse-&amp;gt;Run-&amp;gt;External Tools-&amp;gt;Extrernal Tools Configurations，选择第一步设置的启动配置，执行Run，启动应用。Eclipse终端中会输出&lt;/p&gt;

&lt;p&gt;Listening for transport dt_socket at address: 8089&lt;/p&gt;

&lt;p&gt;表示应用启动监听debug端口8089&lt;/p&gt;

&lt;p&gt;&amp;nbsp;
&lt;h2&gt;&lt;strong&gt;4.开启debug&lt;/strong&gt;&lt;/h2&gt;
Eclipse-&amp;gt;Run-&amp;gt;Debug Configurations选择第二步设置的debug配置，启动debug&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Mac配置docbook工具链</title>
   <link href="http://jiang-bo.github.com/blog/2011/08/09/mac-config-docbook-tool-chain"/>
   <updated>2011-08-09T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2011/08/09/mac-config-docbook-tool-chain</id>
   <content type="html">&lt;p&gt;docbook是一种在开源界极其流行的文档撰写格式，其源文件可以方便的转换为html，pdf等各种格式。
&lt;strong&gt;一、安装工具链&lt;/strong&gt;
docbook工具链包含三部分&lt;br /&gt;
1.xsltproc（mac自带）&lt;br /&gt;
2.docbook-xsl（需要下载解压 wget http://downloads.sourceforge.net/project/docbook/docbook-xsl/1.76.1/docbook-xsl-1.76.1.tar.bz2）&lt;br /&gt;
3.fop（到&lt;a href=&quot;http://www.apache.org/dyn/closer.cgi/xmlgraphics/fop&quot;&gt;http://www.apache.org/dyn/closer.cgi/xmlgraphics/fop&lt;/a&gt;下载）&lt;br /&gt;
下载解压后得到：&lt;br /&gt;
docbook-xsl-1.76.1&lt;br /&gt;
fop-1.0&lt;br /&gt;
两个目录。&lt;br /&gt;
此时可以已经可以进行docbook撰写了，不过只限英文:)
&lt;strong&gt;二、撰写docbook，并生成pdf&lt;/strong&gt;
使用文本编辑器编写如下xml，保存为webx.xml
&lt;pre class=&quot;brush:xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;!DOCTYPE book PUBLIC &quot;-//OASIS//DTD DocBook XML V4.0//EN&quot;  &quot;http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd&quot;&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;book&amp;gt;&lt;br /&gt;
&amp;lt;bookinfo&amp;gt;&lt;br /&gt;
&amp;lt;title&amp;gt;Webx Source Code&amp;lt;/title&amp;gt;&lt;br /&gt;
&amp;lt;author&amp;gt;&lt;br /&gt;
&amp;lt;firstname&amp;gt;Bo&amp;lt;/firstname&amp;gt;&lt;br /&gt;
&amp;lt;surname&amp;gt;Jiang&amp;lt;/surname&amp;gt;&lt;br /&gt;
&amp;lt;affiliation&amp;gt;&lt;br /&gt;
&amp;lt;address&amp;gt;&lt;br /&gt;
&amp;lt;email&amp;gt;jiang.bo.hit@gmail.com&amp;lt;/email&amp;gt;&lt;br /&gt;
&amp;lt;/address&amp;gt;&lt;br /&gt;
&amp;lt;/affiliation&amp;gt;&lt;br /&gt;
&amp;lt;/author&amp;gt;&lt;br /&gt;
&amp;lt;copyright&amp;gt;&lt;br /&gt;
&amp;lt;year&amp;gt;2011&amp;lt;/year&amp;gt;&lt;br /&gt;
&amp;lt;/copyright&amp;gt;&lt;br /&gt;
&amp;lt;abstract&amp;gt;&lt;br /&gt;
&amp;lt;para&amp;gt;Webx&amp;lt;/para&amp;gt;&lt;br /&gt;
&amp;lt;/abstract&amp;gt;&lt;br /&gt;
&amp;lt;/bookinfo&amp;gt;&lt;br /&gt;
&amp;lt;part&amp;gt;&lt;br /&gt;
&amp;lt;title&amp;gt;Part1&amp;lt;/title&amp;gt;&lt;br /&gt;
&amp;lt;chapter&amp;gt;&lt;br /&gt;
&amp;lt;title&amp;gt;Chapter 1 &amp;lt;/title&amp;gt;&lt;br /&gt;
&amp;lt;sect1&amp;gt;&lt;br /&gt;
&amp;lt;title&amp;gt;Part1, Chapter 1, Section1&amp;lt;/title&amp;gt;&lt;br /&gt;
&amp;lt;para&amp;gt;     Your Text &amp;lt;/para&amp;gt;&lt;br /&gt;
&amp;lt;/sect1&amp;gt;&lt;br /&gt;
&amp;lt;/chapter&amp;gt;&lt;br /&gt;
&amp;lt;chapter&amp;gt;&lt;br /&gt;
&amp;lt;title&amp;gt;Part 1, Chapter 2&amp;lt;/title&amp;gt;&lt;br /&gt;
&amp;lt;sect1&amp;gt;&lt;br /&gt;
&amp;lt;title&amp;gt;Part1, Chapter 2, Section 1&amp;lt;/title&amp;gt;&lt;br /&gt;
&amp;lt;para&amp;gt;     Your Text &amp;lt;/para&amp;gt;&lt;br /&gt;
&amp;lt;/sect1&amp;gt;&lt;br /&gt;
&amp;lt;/chapter&amp;gt;&lt;br /&gt;
&amp;lt;/part&amp;gt;&lt;br /&gt;
&amp;lt;/book&amp;gt;
使用xsltproc转换为中间文件&lt;br /&gt;
$xsltproc -o &lt;a href=&quot;http://inter.fo/&quot;&gt;inter.fo&lt;/a&gt; ~/tools/docbook-xsl-1.76.1/fo/docbook.xsl webx.xml&lt;br /&gt;
此时会生成中间文件inter.fo&lt;br /&gt;
使用fop生成pdf&lt;br /&gt;
$~/tools/fop-1.0/fop -pdf webx.pdf -fo &lt;a href=&quot;http://inter.fo/&quot;&gt;inter.fo&lt;/a&gt;
最终生成了名为webx.pdf的pdf文件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、设置FOP支持中文&lt;/strong&gt;
但是使用FOP默认的配置处理含有中文的文档是，中文都会变成### :(，原因是FOP默认不支持中文字体，需要自己配置一下。&lt;br /&gt;
找到自己系统中的字体目录，Mac下为/Library/Fonts，里面存在Microsoft/SimHei.ttf字体文件，下面一该字体为例生成一个FOP字体矩阵配置。
&lt;strong&gt;1.生成字体矩阵&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;进入到fop安装目录，执行&lt;/p&gt;

&lt;p&gt;$ java -cp build/fop.jar:`echo lib/*.jar |tr ' ' ':'` org.apache.fop.fonts.apps.TTFReader -ttcanme &quot;SimHei&quot; /Library/Fonts/Microsoft/SimHei.ttf conf/simhei.xml&lt;/p&gt;

&lt;p&gt;会在conf目录下生成simhei.xml字体矩阵文件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.修改fop配置文件conf/fop.xconf，加入如下配置&lt;/strong&gt;
&lt;pre class=&quot;brush:xml&quot;&gt;&amp;lt;renderer mime=&quot;application/pdf&quot;&amp;gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;filterList&amp;gt;&lt;/p&gt;

&lt;p&gt;……&lt;/p&gt;

&lt;p&gt;&amp;lt;/filterList&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;fonts&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;font metrics-url=&quot;file:///Users/jiangbo/tools/fop-1.0/conf/simhei.xml&quot; kerning=&quot;yes&quot; embed-url=&quot;file:///Library/Fonts/Microsoft/SimHei.ttf&quot;&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;font-triplet name=&quot;SimHei&quot; style=&quot;normal&quot; weight=&quot;bold&quot;/&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;font-triplet name=&quot;SimHei&quot; style=&quot;normal&quot; weight=&quot;bold&quot;/&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;/font&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;!--&amp;lt;directory recursive=&quot;true&quot;&amp;gt;/Library/Fonts/&amp;lt;/directory&amp;gt;--&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;!--    &amp;lt;auto-detect/&amp;gt;--&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;/fonts&amp;gt;&lt;/p&gt;

&lt;p&gt;……
&lt;strong&gt;3.撰写docbook样式表，docbook.xsl&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;默认转换时使用的是docbook-xsl-1.76.1/fo/docbook.xsl样式表，该样式表中不包括中文字体，需要自定义一个样式表docbook.xsl
&lt;pre class=&quot;brush:xml&quot;&gt;&amp;lt;?xml version='1.0'?&amp;gt;
&amp;lt;xsl:stylesheet xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;
                xmlns:exsl=&quot;http://exslt.org/common&quot;
                xmlns:fo=&quot;http://www.w3.org/1999/XSL/Format&quot;
                xmlns:ng=&quot;http://docbook.org/docbook-ng&quot;
                xmlns:db=&quot;http://docbook.org/ns/docbook&quot;
                exclude-result-prefixes=&quot;db ng exsl&quot;
                version='1.0'&amp;gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;xsl:import href=&quot;/Users/jiangbo/tools/docbook-xsl-1.76.1/fo/docbook.xsl&quot;/&amp;gt;&lt;br /&gt;
&amp;lt;xsl:param name=&quot;body.font.family&quot;&amp;gt;SimHei&amp;lt;/xsl:param&amp;gt;&lt;br /&gt;
&amp;lt;xsl:param name=&quot;monospace.font.family&quot;&amp;gt;SimHei&amp;lt;/xsl:param&amp;gt;&lt;br /&gt;
&amp;lt;xsl:param name=&quot;title.font.family&quot;&amp;gt;SimHei&amp;lt;/xsl:param&amp;gt;&lt;br /&gt;
&amp;lt;/xsl:stylesheet&amp;gt;
&lt;strong&gt;4.使用新样式表进行转换&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;$xsltproc -o &lt;a href=&quot;http://inter.fo/&quot;&gt;inter.fo&lt;/a&gt; docbook.xsl webx.xml&lt;/p&gt;

&lt;p&gt;$$ ~/tools/fop-1.0/fop -c  ~/tools/fop-1.0/conf/fop.xconf -pdf webx.pdf -fo &lt;a href=&quot;http://inter.fo/&quot;&gt;inter.fo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Mac OSX 安装memcached</title>
   <link href="http://jiang-bo.github.com/blog/2011/08/03/mac-osx-install-memcached"/>
   <updated>2011-08-03T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2011/08/03/mac-osx-install-memcached</id>
   <content type="html">&lt;p&gt;1.确保本机上已经装了Xcode，可以从随机附带的DVD中获取，或者到 Apple Developer Connection下载安装。2.从 shell script from topfunky.net (mirror) 下载安装脚本，该脚本会自动完成memcached的安装，包括相应的依赖包&lt;br /&gt;
3.执行下载的脚本，
&lt;pre class=&quot;brush:shell&quot;&gt;$ chmod +x install-memcached.sh
$ sudo ./install-memchaced.sh&lt;/pre&gt;
4.在环境变量里添加EVENT_NOKQUEUE=1&lt;br /&gt;
5.验证是否成功， $memcached -h，应该产生帮助提示
&lt;a href=&quot;/images/uploads/2011/07/Screen-shot-2011-08-03-at-11.12.50-AM.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-35&quot; title=&quot;Screen shot 2011-08-03 at 11.12.50 AM&quot; src=&quot;/images/uploads/2011/07/Screen-shot-2011-08-03-at-11.12.50-AM.png&quot; alt=&quot;&quot; width=&quot;607&quot; height=&quot;423&quot; /&gt;&lt;/a&gt;
6.启动memcached,
&lt;pre class=&quot;brush:shell&quot;&gt;$memcached -m 32 -p 11211 -d&lt;/pre&gt;
参考文档&lt;br /&gt;
http://www.lullabot.com/articles/setup-memcached-mamp-sandbox-environment&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>使用MAT进行dump文件分析</title>
   <link href="http://jiang-bo.github.com/blog/2011/08/02/use-mat-analysis-dump-file"/>
   <updated>2011-08-02T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2011/08/02/use-mat-analysis-dump-file</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;一、简介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;一个实际的应用系统难免会出现问题。JVM能够实时的记录系统发生问题时JVM内部的运行状态，并将起存储在堆转储（Heap dump）文件中，dump文件为系统分析提供了重要依据。但是原始dump文件纯文本方式，难于理解，为了降低dump文件分析的复杂度，MAT（Eclipse Memory Analyzer）应运而生。MAT时公认的、强大的、“傻瓜式”堆转储文件分析工具。详细介绍见&lt;a href=&quot;http://www.eclipse.org/mat/&quot;&gt;http://www.eclipse.org/mat/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、获取MAT&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MAT现在提供两种安装方式，Eclipse IDE插件（集成版）和Eclipse RCP（单机版）。&lt;/p&gt;

&lt;p&gt;本文采用的时Eclipse RCP版本，可到&lt;a href=&quot;http://www.eclipse.org/mat/downloads.php&quot;&gt;http://www.eclipse.org/mat/downloads.php&lt;/a&gt;下载。解压运行后如图所示&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/images/uploads/2011/07/界面.png&quot;&gt;&lt;img class=&quot;alignnone size-large wp-image-21&quot; title=&quot;界面&quot; src=&quot;/images/uploads/2011/07/界面-1024x673.png&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;420&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、获取dump文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可用通过多种方式获得dump文件，主要分为交互式和基于事件的方式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 1.交互式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1）、使用Ctrl+Break：如果在JVM运行时参数上加入
&lt;p style=&quot;text-align: center;&quot;&gt;-Xrunhprof:format=b,file=heapdump.hprof&lt;/p&gt;
参数。当java进程收到SIGQUIT信号（kill -3）时会生成一个HPROF格式的dump文件。&lt;/p&gt;

&lt;p&gt;2）、使用jmap工具：jmap是jdk自带的实用工具，在java6可以通过如下命令获得一个运行中java进程的dump文件
&lt;p style=&quot;text-align: center;&quot;&gt;jmap -dump:format=b,file=&lt;em&gt;filename pid&lt;/em&gt;&lt;/p&gt;
&lt;strong&gt; 2.基于事件的方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通常在生产环境中当出现问题时再去用交互式的方式获取dump文件为时已晚。因此实际的生产环境多用基于事件的方法。JVM支持在发生OutOfMemoryError时进行自动的堆转储，生成dump文件。需要在应用JVM启动参数中加入如下参数：
&lt;p style=&quot;text-align: center;&quot;&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/p&gt;
&lt;strong&gt;四、文件分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在MAT钟打开获取的转储文件，文件夹在完成后自动生成分析报告，如图所示&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/images/uploads/2011/08/Screen-shot-2011-07-29-at-3.23.47-PM.png&quot;&gt;&lt;img class=&quot;alignnone size-large wp-image-29&quot; title=&quot;文件分析&quot; src=&quot;/images/uploads/2011/08/Screen-shot-2011-07-29-at-3.23.47-PM-1024x640.png&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;主工作区展示文件分析的概况，可以看到主要的类占用（Biggest Objects）和可选的一些操作，Action，Reports等。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/images/uploads/2011/08/Screen-shot-2011-07-29-at-3.23.56-PM.png&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-30&quot; title=&quot;action&quot; src=&quot;/images/uploads/2011/08/Screen-shot-2011-07-29-at-3.23.56-PM.png&quot; alt=&quot;&quot; width=&quot;917&quot; height=&quot;193&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;左侧的Inspector区可以查看各个类的域信息，如图显示的是一个com.ibatis.sqlmap.engine.impl.SqlMapExecutorDelegate类实例的信息，包括其各个域的值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、一个OutOfMemoryError小例子&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 1.写一个明显会OutOfMemoryError小程序&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;import java.util.Date;&lt;/p&gt;

&lt;p&gt;import java.util.List;&lt;/p&gt;

&lt;p&gt;import java.util.ArrayList;&lt;/p&gt;

&lt;p&gt;public class Test{&lt;/p&gt;

&lt;p&gt;public static void main(String[] args){&lt;/p&gt;

&lt;p&gt;List&amp;lt;Date&amp;gt; list = new ArrayList&amp;lt;Date&amp;gt;();&lt;/p&gt;

&lt;p&gt;while(true){&lt;/p&gt;

&lt;p&gt;Date date = new Date();&lt;/p&gt;

&lt;p&gt;list.add(date);&lt;/p&gt;

&lt;p&gt;date=null;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 2.设置启动参数&lt;/strong&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;$ java -XX:+HeapDumpOnOutOfMemoryError Test&lt;/p&gt;
&lt;strong&gt; 3.如其获得异常&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/images/uploads/2011/08/Screen-shot-2011-07-29-at-3.29.07-PM.png&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-31&quot; title=&quot;Screen shot 2011-07-29 at 3.29.07 PM&quot; src=&quot;/images/uploads/2011/08/Screen-shot-2011-07-29-at-3.29.07-PM.png&quot; alt=&quot;&quot; width=&quot;534&quot; height=&quot;130&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;生成的dump文件为java_pid4931.hprof&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 4.使用MAT导入dump文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/images/uploads/2011/08/dump文件.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-32&quot; title=&quot;dump文件&quot; src=&quot;/images/uploads/2011/08/dump文件.png&quot; alt=&quot;&quot; width=&quot;1356&quot; height=&quot;858&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;从分析报告中可以明显看出有一个类Thread占用了99%的内存，该类由java.lang.ClassLoader加载。&lt;/p&gt;

&lt;p&gt;通过查看Leak Suspects报告可以看到更清晰的内存泄漏情况&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/images/uploads/2011/07/Leak-Suspects.png&quot;&gt;&lt;img class=&quot;aligncenter size-large wp-image-24&quot; title=&quot;Leak Suspects&quot; src=&quot;/images/uploads/2011/07/Leak-Suspects-1024x647.png&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;404&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;点击detail，可以查看详细信息&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/images/uploads/2011/07/详细信息.png&quot;&gt;&lt;img class=&quot;aligncenter size-large wp-image-23&quot; title=&quot;详细信息&quot; src=&quot;/images/uploads/2011/07/详细信息-1024x636.png&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;397&quot; /&gt;&lt;/a&gt; 跟集合到内存消耗点的最短路径&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/images/uploads/2011/07/最短路径.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-22&quot; title=&quot;最短路径&quot; src=&quot;/images/uploads/2011/07/最短路径.png&quot; alt=&quot;&quot; width=&quot;593&quot; height=&quot;195&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;内存消耗的对象&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/images/uploads/2011/07/内存消耗对象.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-26&quot; title=&quot;内存消耗对象&quot; src=&quot;/images/uploads/2011/07/内存消耗对象.png&quot; alt=&quot;&quot; width=&quot;553&quot; height=&quot;373&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;此时应该就可以分析出大概情况了，内存溢出主要是因为还有大量的Date对象。进而查看下线程栈&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/images/uploads/2011/07/Thread.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-25&quot; title=&quot;Thread&quot; src=&quot;/images/uploads/2011/07/Thread.png&quot; alt=&quot;&quot; width=&quot;852&quot; height=&quot;171&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;也就基本能定位问题的所在了。问题代码就是：&lt;/p&gt;

&lt;p&gt;while(true){&lt;/p&gt;

&lt;p&gt;Date date = new Date();&lt;/p&gt;

&lt;p&gt;list.add(date);&lt;/p&gt;

&lt;p&gt;date=null;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;六、总结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MAT是一个功能强大的内存分析工具，目前介绍的只是很基本的一些功能，更多信息请参考&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://memoryanalyzer.blogspot.com&quot;&gt;http://memoryanalyzer.blogspot.com&lt;/a&gt;/&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/java/j-memoryanalyzer/index.html?ca=drs-&quot;&gt;http://www.ibm.com/developerworks/cn/java/j-memoryanalyzer/index.html?ca=drs-&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.vogella.de/articles/EclipseMemoryAnalyser/article.html&quot;&gt;http://www.vogella.de/articles/EclipseMemoryAnalyser/article.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Mac OSX安装Git</title>
   <link href="http://jiang-bo.github.com/blog/2011/03/15/post"/>
   <updated>2011-03-15T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2011/03/15/post</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;一、安装Git&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s1&quot;&gt;由于mac git的地址&lt;a href=&quot;http://code.google.com/p/git-osx-installer/&quot;&gt;&lt;span class=&quot;s2&quot;&gt;http://code.google.com/p/git-osx-installer/&lt;/span&gt;&lt;/a&gt;被墙，被迫使用源码安装，源码可以从&lt;a href=&quot;http://kernel.org/pub/software/scm/git/&quot;&gt;&lt;span class=&quot;s2&quot;&gt;http://kernel.org/pub/software/scm/git/&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;s3&quot;&gt;下载，编译源码需要先安装xcode，参考&lt;a href=&quot;http://developer.apple.com/&quot;&gt;&lt;span class=&quot;s4&quot;&gt;http://developer.apple.com&lt;/span&gt;&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;编译安装&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;1.解压&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;tar xjvf git-1.7.4.1.tar.tar.bz2&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;2. 编译&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;cd git-1.7.4.1&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;./configure --prefix=/usr/local&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;make&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;3.安装&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;sudo make install&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;Ok 了，which git试一下～&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;strong&gt;二、设置SSH&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;github使用SSH链接，需要设置SSH&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;1.检查SSH key&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; cd ~/.ssh&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;2.备份已有的key，（如果有的话）&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; mkdir key_backup&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; mv id_rsa* key_backup&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;3.生成SSH key&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;$ ssh-keygen -t rsa -C &lt;a href=&quot;mailto:jiang.bo.hit@gmail.com&quot;&gt;&lt;span class=&quot;s5&quot;&gt;jiang.bo.hit@gmail.com&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;Generating public/private rsa key pair.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;Enter file in which to save the key (/Users/jiangbo/.ssh/id_rsa):&amp;nbsp;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;Enter passphrase (empty for no passphrase):&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;Enter same passphrase again:&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;Your identification has been saved in yes.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;Your public key has been saved in id_rsa.pub.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;The key fingerprint is:&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;fb:c4:b0:e0:47:fd:be:e0:fb:ea:73:ef:a8:29:d5:22 &lt;a href=&quot;mailto:jiang.bo.hit@gmail.com&quot;&gt;&lt;span class=&quot;s5&quot;&gt;jiang.bo.hit@gmail.com&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;The key's randomart image is:&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;+--[ RSA 2048]----+&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;|&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; |&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;|&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; |&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;|&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; |&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;|&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; .&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; |&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;|&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; . S ..&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; |&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;|&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; . oE=o..&amp;nbsp;&amp;nbsp;&amp;nbsp; |&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;|&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; . +o+..&amp;nbsp;&amp;nbsp;&amp;nbsp; |&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;|&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ..+.+..&amp;nbsp;&amp;nbsp; |&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;|&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; oOB=+o&amp;nbsp; |&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;+-----------------+&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;4.将SSH key添加到GitHub&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;登录到GitHub页面，Account Settings-&amp;gt;SSH Public Keys-&amp;gt;Add another key&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;将生成的key(id_rsa.pub文件）内容copy到输入框中，save。&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;&lt;img src=&quot;http://hi.csdn.net/attachment/201103/15/0_1300170843sWhI.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;5.测试链接&lt;/p&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;span class=&quot;s3&quot;&gt;$ ssh &lt;a href=&quot;mailto:git@github.com&quot;&gt;&lt;span class=&quot;s5&quot;&gt;git@github.com&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;The authenticity of host '&lt;a href=&quot;http://github.com/&quot;&gt;&lt;span class=&quot;s5&quot;&gt;github.com&lt;/span&gt;&lt;/a&gt; (207.97.227.239)' can't be established.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;Are you sure you want to continue connecting (yes/no)? yes&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;PTY allocation request failed on channel 0&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;Hi jiang-bo! You've successfully authenticated, but GitHub does not provide shell access.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Connection to &lt;a href=&quot;http://github.com/&quot;&gt;&lt;span class=&quot;s5&quot;&gt;github.com&lt;/span&gt;&lt;/a&gt; closed.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;别担心，这是正常情况。&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;strong&gt;三、设置个人信息&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;$ git config --global &lt;a href=&quot;http://user.name/&quot;&gt;&lt;span class=&quot;s5&quot;&gt;user.name&lt;/span&gt;&lt;/a&gt; &quot;Bo Jiang&quot;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;$ git config --global user.email &quot;jiang.bo.hit@gmail.com&quot;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Java基础（1）－泛型</title>
   <link href="http://jiang-bo.github.com/blog/2011/03/10/post"/>
   <updated>2011-03-10T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2011/03/10/post</id>
   <content type="html">&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;一、Basic FAQ：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. What are Java Generics?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &lt;em&gt;Java泛型是什么？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; Java Generics ara language feature that allows for definition and use of generic types and methods.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &lt;em&gt;Java泛型指的是一种允许定义通用类型和方法的语言特性。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. What is the primary purpose of Java Generics?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &lt;em&gt;Java泛型最初的目的是什么？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; Java Generics are invented primarily for implementation of generic collection.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &lt;em&gt;Java泛型最初是为了实现通用集合类设计的。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.What is the benefit of using Java generics?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &lt;em&gt;使用Java泛型的好处？？？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; Early error detection at compile time.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &lt;em&gt;能够在编译期检查类型错误。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.What does type-safe mean?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &lt;em&gt;什么叫做类型安全&lt;/em&gt;？&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; In Java, a program is considered type-safe if it compiles without errors and warnings and does not raise any unexpected ClassCastException at runtime.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 在Java里，类型安全指的是：如果一个程序编译期未发现Error或Warning，那么在运行时就不会报ClassCastException。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;奇怪的特性&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 泛型有些特性，令人困扰，如下：&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp; 子类型的泛型不能赋值给父类型的泛型，即泛型不可协变。&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp; 泛型类并没有自己独有的Class类对象。比如并不存在List&amp;lt;String&amp;gt;.class或是List&amp;lt;Integer&amp;gt;.class，而只有List.class。&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp; 静态变量是被泛型类的所有实例所共享的。对于声明为MyClass&amp;lt;T&amp;gt;的类，访问其中的静态变量的方法仍然是 MyClass.myStaticVar。不管是通过new MyClass&amp;lt;String&amp;gt;还是new MyClass&amp;lt;Integer&amp;gt;创建的对象，都是共享一个静态变量。&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp; 泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型MyException&amp;lt;String&amp;gt;和MyException&amp;lt;Integer&amp;gt;的。对于JVM来说，它们都是 MyException类型的。也就无法执行与异常对应的catch语句。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;协变（convariant）&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; Within the type system of a programming language, covariance and contravariance refers to the ordering of types from narrower to wider and their interchangeability or equivalence in certain situations (such as parameters, generics, and return types). &amp;nbsp; &amp;nbsp; &amp;mdash;&amp;mdash;Wikipedia（偶不会翻译*A*）&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 简单来说，可协变表示子类型的引用可以赋值给父类性，不可协变则表示子类型引用不能赋值给父类型。以数组和泛型为例：&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 数组是可协变的，因为Number[] a = new Integer[]()；是成立的。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 泛型是不可协变的，因为List&amp;lt;Number&amp;gt; ln = new ArrayList&amp;lt;Integer&amp;gt;()；编译会出错。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 由于数组是可协变的，而泛型不可协变，导致数组能够协变而泛型不能协变的另一个后果是，不能实例化泛型类型的数组（new List&amp;lt;String&amp;gt;[3]是不合法的），除非类型参数是一个未绑定的通配符（new List&amp;lt;?&amp;gt;[3]是合法的）。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;可是，为什么泛型不能协变呢？&amp;mdash;&amp;mdash;因为这样会破坏类型安全&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 假设可以协变，那么&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; List&amp;lt;Integer&amp;gt; li = new ArrayList&amp;lt;Integer&amp;gt;();&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; List&amp;lt;Number&amp;gt; ln = li;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; ln.add(new Float(3.14));&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 发生了什么？本来是放Integer的List里面加入了Float！。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;类型擦除&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp;Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的List&amp;lt;Object&amp;gt;和List&amp;lt;String&amp;gt;等类型，在编译之后都会变成List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。&lt;/p&gt;
&lt;h3&gt;编译器如何处理泛型？&lt;/h3&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 通常情况下，一个编译器处理泛型有两种方式：&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 1.Code specialization。在实例化一个泛型类或泛型方法时都产生一份新的目标代码（字节码or二进制代码）。例如，针对一个泛型list，可能需要针对string，integer，float产生三份目标代码。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 2.Code sharing。对每个泛型类只生成唯一的一份目标代码；该泛型类的所有实例都映射到这份目标代码上，在需要的时候执行类型检查和类型转换。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; C++中的模板（template）是典型的Code specialization实现。C++编译器会为每一个泛型类实例生成一份执行代码。执行代码中integer list和string list是两种不同的类型。这样会导致代码膨胀（code bloat），不过有经验的C＋＋程序员可以有技巧的避免代码膨胀。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; Code specialization另外一个弊端是在引用类型系统中，浪费空间，因为引用类型集合中元素本质上都是一个指针。没必要为每个类型都产生一份执行代码。而这也是Java编译器中采用Code sharing方式处理泛型的主要原因。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; Java编译器通过Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。&lt;/p&gt;
&lt;h3&gt;什么是类型擦除？&lt;/h3&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 类型擦除指的是通过类型参数合并，将泛型类型实例关联到同一份字节码上。编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 类型擦除的主要过程如下：&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 2.移除所有的类型参数。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 如&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: java&quot;&gt;interface Comparable &amp;lt;A&amp;gt; { 
  public int compareTo( A that); 
} 
final class NumericValue implements Comparable &amp;lt;NumericValue&amp;gt; { 
  priva te byte value;  
  public  NumericValue (byte value) { this.value = value; }    
  public  byte getValue() { return value; }    
  public  int compareTo( NumericValue t hat) { return this.value - that.value; } 
} 
－－－－－－－－－－－－－－－－－
class Collections {  
  public static &amp;lt;A extends Comparable&amp;lt;A&amp;gt;&amp;gt;A max(Collection &amp;lt;A&amp;gt; xs) { 
    Iterator &amp;lt;A&amp;gt; xi = xs.iterator(); 
    A w = xi.next(); 
    while (xi.hasNext()) { 
      A x = xi.next(); 
      if (w.compareTo(x) &amp;lt; 0) w = x; 
    } 
    return w; 
  } 
} 
final class Test { 
  public static void main (String[ ] args) { 
    LinkedList &amp;lt;NumericValue&amp;gt; numberList = new LinkedList &amp;lt;NumericValue&amp;gt; (); 
    numberList .add(new NumericValue((byte)0));  
    numberList .add(new NumericValue((byte)1));  
    NumericValue y = Collections.max( numberList );  
  } 
}&lt;/pre&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;经过类型擦除后的类型为&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: java&quot;&gt;     interface Comparable { 
  public int compareTo( Object that); 
} 
final class NumericValue implements Comparable { 
  priva te byte value;  
  public  NumericValue (byte value) { this.value = value; }  
  public  byte getValue() { return value; }  
  public  int compareTo( NumericValue t hat)   { return this.value - that.value; } 
  public  int compareTo(Object that) { return this.compareTo((NumericValue)that);  } } 
－－－－－－－－－－－－－
class Collections {  
  public static Comparable max(Collection xs) { 
    Iterator xi = xs.iterator(); 
    Comparable w = (Comparable) xi.next(); 
    while (xi.hasNext()) { 
      Comparable x = (Comparable) xi.next(); 
      if (w.compareTo(x) &amp;lt; 0) w = x; 
    } 
    return w; 
  } 
} 
final class Test { 
  public static void main (String[ ] args) { 
    LinkedList numberList = new LinkedList(); 
    numberList .add(new NumericValue((byte)0));  ，
    numberList .add(new NumericValue((byte)1));  
    NumericValue y = (NumericValue) Collections.max( numberList );  
  } 
}&lt;/pre&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;第一个泛型类Comparable &amp;lt;A&amp;gt;擦除后 A被替换为最左边界Object。Comparable&amp;lt;NumericValue&amp;gt;的类型参数NumericValue被擦除掉，但是这直接导致NumericValue没有实现接口Comparable的compareTo(Object that)方法，于是编译器充当好人，添加了一个桥接方法。&lt;/p&gt;
&lt;p&gt;第二个示例中限定了类型参数的边界&amp;lt;A extends Comparable&amp;lt;A&amp;gt;&amp;gt;A，A必须为Comparable&amp;lt;A&amp;gt;的子类，按照类型擦除的过程，先讲所有的类型参数ti换为最左边界Comparable&amp;lt;A&amp;gt;，然后去掉参数类型A，得到最终的擦除后结果。&lt;/p&gt;
&lt;h3&gt;类型擦除带来的问题&lt;/h3&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 正是由于类型擦除的隐蔽存在，直接导致了众多的泛型灵异问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q1.用同一泛型类的实例区分方法签名？&amp;mdash;&amp;mdash;NO！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;{code}&lt;/p&gt;
&lt;p&gt;import java.util.*;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;public class Erasure{&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;public void test(List&amp;lt;String&amp;gt; ls){&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;System.out.println(&quot;Sting&quot;);&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;}&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;public void test(List&amp;lt;Integer&amp;gt; li){&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;System.out.println(&quot;Integer&quot;);&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;{code}&lt;/p&gt;
&lt;p&gt;编译该类，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://hi.csdn.net/attachment/201103/10/0_12997506095504.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;what the f**k! 参数类型明明不一样啊，一个List&amp;lt;String&amp;gt;，一个是List&amp;lt;Integer&amp;gt;，但是，偷偷的说，type erasure之后，它就都是List了⋯⋯&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q2. 同时catch同一个泛型异常类的多个实例？&amp;mdash;&amp;mdash;NO！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同理，如果定义了一个泛型一场类GenericException&amp;lt;T&amp;gt;，千万别同时catch GenericException&amp;lt;Integer&amp;gt; 和GenericException&amp;lt;String&amp;gt;，因为他们是一样一样滴⋯⋯&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q3.泛型类的静态变量是共享的？&amp;mdash;&amp;mdash;Yes！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;猜猜这段代码的输出是什么？&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: java&quot;&gt;import java.util.*;
public class StaticTest{
    public static void main(String[] args){
        GT&amp;lt;Integer&amp;gt; gti = new GT&amp;lt;Integer&amp;gt;();
        gti.var=1;
        GT&amp;lt;String&amp;gt; gts = new GT&amp;lt;String&amp;gt;();
        gts.var=2;
        System.out.println(gti.var);
    }
}
class GT&amp;lt;T&amp;gt;{
    public static int var=0;
    public void nothing(T x){}
}&lt;/pre&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;答案是&amp;mdash;&amp;mdash;2！&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3&gt;Just remember：&lt;/h3&gt;
&lt;p&gt;1.虚拟机中没有泛型，只有普通类和普通方法&lt;/p&gt;
&lt;p&gt;2.所有泛型类的类型参数在编译时都会被擦除&lt;/p&gt;
&lt;p&gt;3.创建泛型对象时请指明类型，让编译器尽早的做参数检查（Effective Java，第23条：请不要在新代码中使用原生态类型）&lt;/p&gt;
&lt;p&gt;4.不要忽略编译器的警告信息，那意味着潜在的ClassCastException等着你。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;参考文档&lt;/h2&gt;
&lt;p&gt;《Java深度历险－泛型》http://www.infoq.com/cn/articles/cf-java-generics&lt;/p&gt;
&lt;p&gt;《Java Generics FAQ》http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html&lt;/p&gt;
&lt;p&gt;《Java Gotchas》http://www.ibm.com/developerworks/java/library/j-jtp01255.html&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>使用memcached进行并发控制</title>
   <link href="http://jiang-bo.github.com/blog/2011/02/27/post"/>
   <updated>2011-02-27T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2011/02/27/post</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;font-family: mceinline;&quot;&gt;引子&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
&lt;/p&gt;&lt;p class=&quot;p2&quot;&gt;一个使用缓存进行并发控制的讨论，让我学习到成本与收益间的平衡，以及何为真正的可用性......&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;防止并发有多种方式，本文只涉及使用缓存memcached控制。&lt;/p&gt;
&lt;p class=&quot;p1&quot; style=&quot;font-weight: bold;&quot;&gt;&lt;span style=&quot;font-family: mceinline;&quot;&gt;&lt;strong&gt;并发场景&lt;/strong&gt;&lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;strong&gt;&amp;nbsp;&amp;nbsp; &lt;/strong&gt;&amp;nbsp; 用例：SNS系统中具有高级会员资格的人发起活动。&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 业务规则：1.一个人同时只能创建一个活动。2.具有高级会员资格。&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 基本流程如下：&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p class=&quot;p1&quot; style=&quot;font-weight: bold;&quot;&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;img src=&quot;http://hi.csdn.net/attachment/201102/27/0_1298804115LLTM.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;这个流程中存在明显的并发问题，当进程A校验过会员M有资格，并且为创建过活动，但为开始执行创建操作，此时另一个进程B也进行了规则判断，顺利通过，并完成创建操作，此时A继续执行，则会产生两条M的活动。（这个并发场景很简单，很普遍）&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-family: mceinline;&quot;&gt;最初的解决方案：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 计划利用memcached的add操作的原子性来控制并发，具体方式如下：&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 1.申请锁：在校验是否创建过活动前，执行add操作key为memberId，如果add操作失败，则表示有另外的进程在并发的为该memberId创建活动，返回创建失败。否则表示无并发&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 2.执行创建活动&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 3.释放锁：创建活动完成后，执行delete操作，删除该memberId。&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-family: mceinline;&quot;&gt;问题：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;strong&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;&lt;/strong&gt; 如此实现存在一些问题：&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 1.memcached中存放的值有有效期，即过期后自动失效，如add过M1后，M1失效，可以在此add成功&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 2.即使通过配置，可以使memcached永久有效，即不设有效期，memcached有容量限制，当容量不够后会进行自动替换，即有可能add过M1后，M1被其他key值置换掉，则再次add可以成功。&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 3.此外，memcached是基于内存的，掉电后数据会全部丢失，导致重启后所有memberId均可重新add。&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-family: mceinline;&quot;&gt;应对问题：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 针对上述的几个问题，根本原因是add操作有时效性，过期，被替换，重启，都会是原来的add操作失效。解决该问题有两个方法：&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 1.采用持久化的缓存解决方法，如TT（&lt;span class=&quot;s1&quot;&gt;Tokyo Tyrant：&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;http://fallabs.com/tokyotyrant/&lt;/span&gt;）&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 2.减轻时效性的影响，使用memcached CAS（check and set）方式。&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 第一种不必解释了，很简单，原来的所有问题都是时效性惹得祸，时效性源于memcached是基于内存的，那么采用持久话存储的TT可以彻底根治这个问题。&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 第二种方式需要简单介绍下：&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; memcached中除了add操作是原子的，还有另外两个操作也是原子的：incr和decr，使用CAS模式即：&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 1.预先在memcached中设置一个key值，假设为CREATKEY＝1&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 2.每次创建活动时，在规则校验前先get出CREATEKEY＝x；&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 3.进行规则校验&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 4.执行incr CREATEKEY操作，检验返回值是否为所期望的x＋1，如果不是，则说明在此期间有另外的进程执行了incr操作，即存在并发，放弃更新。否则&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 5.执行创建活动&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 对比这两种方法，从效果上看可以发现第一种时100％可靠的，不存在问题；第二种，可能存在误判，即本来不存在并发，却被判为并发，如缓存重启，或key值失效后，incr值可能不同于期望值，导致误判。&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 但是从成本上考虑，TT是持久化的缓存解决方案，完美意味着高成本，我们必须维护持久化数据，而使用memcached的CAS方式，可以以几乎0成本的方式解决时效性问题，尽管存在一点小缺陷，但这种缺陷可以通过简单的重试即可解决。考虑实际的产出比，采用memcached的CAS方式更适合实际情况。&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; 成本与收益间的平衡，做科学与做工程的区别～&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Zero-Copy&amp;sendfile浅析</title>
   <link href="http://jiang-bo.github.com/blog/2011/01/17/post"/>
   <updated>2011-01-17T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2011/01/17/post</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;一、典型&lt;span lang=&quot;EN-US&quot;&gt;IO&lt;/span&gt;调用的问题&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;&lt;/span&gt;一个典型的&lt;span lang=&quot;EN-US&quot;&gt;web&lt;/span&gt;服务器传送静态文件（如&lt;span lang=&quot;EN-US&quot;&gt;CSS&lt;/span&gt;，&lt;span lang=&quot;EN-US&quot;&gt;JS&lt;/span&gt;，图片等）的过程如下：&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;&lt;em&gt;&lt;br /&gt;read(file, tmp_buf, len);&lt;br /&gt;write(socket, tmp_buf, len);&lt;/em&gt;&lt;br /&gt;&lt;br /&gt;&lt;/span&gt;首先调用&lt;span lang=&quot;EN-US&quot;&gt;read&lt;/span&gt;将文件从磁盘读取到&lt;span lang=&quot;EN-US&quot;&gt;tmp_buf&lt;/span&gt;，然后调用&lt;span lang=&quot;EN-US&quot;&gt;write&lt;/span&gt;将&lt;span lang=&quot;EN-US&quot;&gt;tmp_buf&lt;/span&gt;写入到&lt;span lang=&quot;EN-US&quot;&gt;socket&lt;/span&gt;，在这过程中会出现四次数据&lt;span lang=&quot;EN-US&quot;&gt; copy&lt;/span&gt;，过程如图&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;所示&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;http://hi.csdn.net/attachment/201101/17/0_12952361353NK2.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;图1&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;。当调用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;read&lt;/span&gt;&lt;span&gt;系统调用时，通过&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;DMA&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Direct Memory Access&lt;/span&gt;&lt;span&gt;）将数据&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;copy&lt;/span&gt;&lt;span&gt;到内核模式&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;&lt;span&gt;。然后由&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;CPU&lt;/span&gt;&lt;span&gt;控制将内核模式数据&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;copy&lt;/span&gt;&lt;span&gt;到用户模式下的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; buffer&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;read&lt;/span&gt;&lt;span&gt;调用完成后，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;write&lt;/span&gt;&lt;span&gt;调用首先将用户模式下&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; buffer&lt;/span&gt;&lt;span&gt;中的数据&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;copy&lt;/span&gt;&lt;span&gt;到内核模式下的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;socket buffer&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;4&lt;/span&gt;&lt;span&gt;。最后通过&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;DMA copy&lt;/span&gt;&lt;span&gt;将内核模式下的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;socket buffer&lt;/span&gt;&lt;span&gt;中的数据&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;copy&lt;/span&gt;&lt;span&gt;到网卡设备中传送。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;从上面的过程可以看出，数据白白从内核模式到用户模式走了一&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;圈，浪费了两次&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;copy&lt;/span&gt;&lt;span&gt;，而这两次&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;copy&lt;/span&gt;&lt;span&gt;都是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;CPU copy&lt;/span&gt;&lt;span&gt;，即占用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;CPU&lt;/span&gt;&lt;span&gt;资源。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;二、Zero-Copy&amp;amp;Sendfile()&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Linux 2.1&lt;/span&gt;&lt;span&gt;版本内核引入了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;sendfile&lt;/span&gt;&lt;span&gt;函数，用于将文件通过&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;socket&lt;/span&gt;&lt;span&gt;传送。&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;sendfile(socket, file, len);&lt;/span&gt;&lt;/em&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span&gt;该函数通过一次系统调用完成了文件的传送，减少了原来&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; read/write&lt;/span&gt;&lt;span&gt;方式的模式切换。此外更是减少了数据的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;copy&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;sendfile&lt;/span&gt;&lt;span&gt;的详细过程图&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;&lt;span&gt;所示：&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://hi.csdn.net/attachment/201101/17/0_1295236150Tf0Z.gif&quot; alt=&quot;&quot; /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span&gt;图2&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&lt;span&gt;&lt;span&gt;通过&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;sendfile&lt;/span&gt;&lt;span&gt;传送文件只需要一次系统调用，当调用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; sendfile&lt;/span&gt;&lt;span&gt;时：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;。首先通过&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;DMA copy&lt;/span&gt;&lt;span&gt;将数据从磁盘读取到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;kernel buffer&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;&lt;span&gt;。然后通过&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;CPU copy&lt;/span&gt;&lt;span&gt;将数据从&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;kernel buffer copy&lt;/span&gt;&lt;span&gt;到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;sokcet buffer&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;&lt;span&gt;。最终通过&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;DMA copy&lt;/span&gt;&lt;span&gt;将&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;socket buffer&lt;/span&gt;&lt;span&gt;中数据&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;copy&lt;/span&gt;&lt;span&gt;到网卡&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;buffer&lt;/span&gt;&lt;span&gt;中发送&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;sendfile&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;read/write&lt;/span&gt;&lt;span&gt;方式相比，少了&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;一次模式切换一次&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;CPU copy&lt;/span&gt;&lt;span&gt;。但是从上述过程中也可以发现从&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;kernel buffer&lt;/span&gt;&lt;span&gt;中将数据&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;copy&lt;/span&gt;&lt;span&gt;到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;socket buffer&lt;/span&gt;&lt;span&gt;是没必要的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;为此，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Linux2.4&lt;/span&gt;&lt;span&gt;内核对&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;sendfile&lt;/span&gt;&lt;span&gt;做了改进，如图&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;&lt;span&gt;所示&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://hi.csdn.net/attachment/201101/17/0_1295236158Tr8t.gif&quot; alt=&quot;&quot; /&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;图3&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;改进后的处理过程如下：&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;1&lt;/span&gt;。&lt;span lang=&quot;EN-US&quot;&gt;DMA copy&lt;/span&gt;将磁盘数据&lt;span lang=&quot;EN-US&quot;&gt;copy&lt;/span&gt;到&lt;span lang=&quot;EN-US&quot;&gt;kernel buffer&lt;/span&gt;中&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;2&lt;/span&gt;。向&lt;span lang=&quot;EN-US&quot;&gt;socket buffer&lt;/span&gt;中追加当前要发送的数据在&lt;span lang=&quot;EN-US&quot;&gt;kernel buffer&lt;/span&gt;中的位置和偏移量&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;3&lt;/span&gt;。&lt;span lang=&quot;EN-US&quot;&gt;DMA gather copy&lt;/span&gt;根据&lt;span lang=&quot;EN-US&quot;&gt;socket buffer&lt;/span&gt;中的位置和偏移量直接将&lt;span lang=&quot;EN-US&quot;&gt;kernel buffer&lt;/span&gt;中的数据&lt;span lang=&quot;EN-US&quot;&gt;copy&lt;/span&gt;到网卡上。&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;&lt;/span&gt;经过上述过程，数据只经过了&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;次&lt;span lang=&quot;EN-US&quot;&gt;copy&lt;/span&gt;就从磁盘传送出去了。&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;&lt;/span&gt;（可能有人要纠结&lt;span lang=&quot;EN-US&quot;&gt;&amp;ldquo;&lt;/span&gt;不是说&lt;span lang=&quot;EN-US&quot;&gt;Zero&lt;/span&gt;－&lt;span lang=&quot;EN-US&quot;&gt;Copy&lt;/span&gt;么？怎么还有两次&lt;span lang=&quot;EN-US&quot;&gt;copy&lt;/span&gt;啊&lt;span lang=&quot;EN-US&quot;&gt;&amp;rdquo;&lt;/span&gt;，事实上这个&lt;span lang=&quot;EN-US&quot;&gt;Zero copy&lt;/span&gt;是针对内核来讲的，数据在内核模式下是&lt;span lang=&quot;EN-US&quot;&gt;Zero&lt;/span&gt;－&lt;span lang=&quot;EN-US&quot;&gt;copy&lt;/span&gt;的。话说回来，文件本身在瓷盘上要真是完全&lt;span lang=&quot;EN-US&quot;&gt;Zero&lt;/span&gt;－&lt;span lang=&quot;EN-US&quot;&gt;copy&lt;/span&gt;就能传送，那才见鬼了 呢）。&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;&lt;/span&gt;当前许多高性能&lt;span lang=&quot;EN-US&quot;&gt;http server&lt;/span&gt;都引入了&lt;span lang=&quot;EN-US&quot;&gt;sendfile&lt;/span&gt;机制，如&lt;span lang=&quot;EN-US&quot;&gt;nginx&lt;/span&gt;，&lt;span lang=&quot;EN-US&quot;&gt;lighttpd&lt;/span&gt;等。&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;三、Java NIO&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;中的&lt;span lang=&quot;EN-US&quot;&gt;transferTo()&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;Java NIO&lt;/span&gt;中&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;&lt;em&gt;FileChannel.transferTo(long position, long count, WriteableByteChannel target)&lt;/em&gt;&lt;br /&gt;&lt;/span&gt;方法将当前通道中的数据传送到目标通道&lt;span lang=&quot;EN-US&quot;&gt;target&lt;/span&gt;中，在支持&lt;span lang=&quot;EN-US&quot;&gt;Zero-Copy&lt;/span&gt;的&lt;span lang=&quot;EN-US&quot;&gt;linux&lt;/span&gt;系统中，&lt;span lang=&quot;EN-US&quot;&gt;transferTo()&lt;/span&gt;的实现依赖于&lt;span lang=&quot;EN-US&quot;&gt; sendfile()&lt;/span&gt;调用。&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;四、参考文档&lt;span lang=&quot;EN-US&quot;&gt;&lt;br /&gt;&lt;/span&gt;《&lt;span lang=&quot;EN-US&quot;&gt;Zero Copy I: User-Mode Perspective&lt;/span&gt;》&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://www.linuxjournal.com/article/6345?page=0,0&quot;&gt;http://www.linuxjournal.com/article/6345?page=0,0&lt;/a&gt;&lt;br /&gt;&lt;/span&gt;《&lt;span lang=&quot;EN-US&quot;&gt;Efficient data transfer through zero copy&lt;/span&gt;》&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/linux/library/j-zerocopy&quot;&gt;http://www.ibm.com/developerworks/linux/library/j-zerocopy&lt;/a&gt;&lt;br /&gt;&lt;/span&gt;《&lt;span lang=&quot;EN-US&quot;&gt;The C10K problem&lt;/span&gt;》&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://www.kegel.com/c10k.html&quot;&gt;http://www.kegel.com/c10k.html&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>AWK学习笔记</title>
   <link href="http://jiang-bo.github.com/blog/2010/12/13/post"/>
   <updated>2010-12-13T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2010/12/13/post</id>
   <content type="html">&lt;p&gt;
&lt;/p&gt;&lt;p&gt;&lt;em&gt;by BoBo&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;br /&gt;&lt;strong&gt;&lt;span&gt;一点历史&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; AWK上世纪70年代诞生于传奇的Bell实验室，名字取于它的三位发明人，Alfred Aho, Peter Weinberger和 Brian Kernighan名字的首字母。发音类似《The AWK Programing Language》封面上的海雀（一种海鸟）的英文发音(auck[ɔ:k])。AWK最早出现在Unix V7中，Linux诞生后，AWK被LSB纳入其中，这意味者所有的Linux发行版都会提供awk的实现。目前linux上广发使用的是GNU实现的gawk，此外还有nawk，mawk，pgawk等版本。这些实现在AWK的语言规范基础上，扩展了一些其他功能，本文只关心最基础最通用的AWK规范，不探究相关实现的具体实现区别，欲知详情，请查看相关实现的手册。&lt;br /&gt;以下是其中一位创始人Alfred V.Aho对AWK的描述。&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;AWK is a language for processing files of text. A file is treated as a sequence of records, and by default each line is a record. Each line is broken up into a sequence of fields, so we can think of the first word in a line as the first field, the second word as the second field, and so on. An AWK program is of a sequence of pattern-action statements. AWK reads the input a line at a time. A line is scanned for each pattern in the program, and for each pattern that matches, the associated action is executed.&amp;amp;quot; - Alfred V.Aho&lt;/em&gt;&lt;br /&gt;尊重原文，不翻译。&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;&lt;span&gt;瞟一眼&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;准备一份数据文件datafile&lt;br /&gt;&lt;br /&gt;Nike	green	X	10	10.00&lt;br /&gt;Nike	blue	XL	10	10.00&lt;br /&gt;Nike	red	 L	10	12.00&lt;br /&gt;Adiddas	yellow	L	10	10.00&lt;br /&gt;Adiddas	brown	M	10	10.00&lt;br /&gt;Adiddas	gray	M	20	8.00&lt;br /&gt;&lt;br /&gt;打开终端，执行&lt;br /&gt;&lt;br /&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;awk '/Nike/ {print $2}' datafile&lt;/strong&gt;&lt;br /&gt;&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;输出&lt;br /&gt;&lt;br /&gt;green&lt;br /&gt;blue&lt;br /&gt;red&lt;br /&gt;&lt;br /&gt;解释下:&lt;br /&gt;awk表示AWK解析器命令&lt;br /&gt;两个'之间的部分表示这次执行的命令行脚本,其中/Nike/叫模式pattern,{print $2}叫操作action，print表示打印，$2表示每一记录中的第2个域。&lt;br /&gt;datafile表示输入文件。&lt;br /&gt;整个命令的意思表示：&lt;br /&gt;对datafile中所有匹配Nike的行，执行print $2操作，打印含有Nike行中的第二个被空白符隔开的字段。&lt;br /&gt;晕了么？来看点概念的解释吧:)&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;&lt;span&gt;一些枯燥的概念&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;&lt;strong&gt;输入文件：&lt;/strong&gt;待处理的数据文件datafile，每个输入文件为多个记录的集合&lt;br /&gt;&lt;strong&gt;记录分割符：&lt;/strong&gt;将输入文件划分为多个记录的符号，默认为'/n'&lt;br /&gt;&lt;strong&gt;记录：&lt;/strong&gt;默认数据文件中的每一行，如&amp;amp;quot;Nike&amp;nbsp;&amp;nbsp;&amp;nbsp; green&amp;nbsp;&amp;nbsp; X&amp;nbsp;&amp;nbsp; 10&amp;nbsp; 10.00&amp;amp;quot;，每个记录是多个域的集合&lt;br /&gt;&lt;strong&gt;域分隔符：&lt;/strong&gt;将每个记录划分为多个域的符号，默认为空白符&lt;br /&gt;&lt;strong&gt;域：&lt;/strong&gt;记录被域分割符划分后的单元，每个输入文件中的最小处理单元。如Nike， green，X，10，10.00分别为第一个记录的第1，2，3，4，5个域（注意，这里不是从0开始计数的）&lt;br /&gt;&lt;strong&gt;Buffer：&lt;/strong&gt;AWK中支持两种Buffer，域buffer和记录buffer&lt;br /&gt;record buffer:表示整条记录，可以通过$0获取&lt;br /&gt;field buffer:当前记录中的每一个field，可以通过$1,$2,$3获取。&lt;br /&gt;&lt;strong&gt;内置变量：&lt;/strong&gt;&lt;br /&gt;FS:Field separator，域分隔符，默认为空白符&lt;br /&gt;RS:Record Separator，记录分隔符，默认为换行符&lt;br /&gt;NF:Number of Fields in current record，当前记录中的域数&lt;br /&gt;NR:Number of the current Record，当前的记录数&lt;br /&gt;OFS:Output Field Separator，输出域分隔符，默认为空白符&lt;br /&gt;ORS:Output Record Separator，输出记录分隔符，默认为换行符&lt;br /&gt;FILENAME: Current filename，当前输入文件名&lt;br /&gt;&lt;br /&gt;针对一个awk命令行&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;awk 'pattern {action}' datafile&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;awk的执行流程：&lt;br /&gt;1.读取：awk会按行读取输入文件(Line by Line)&lt;br /&gt;2.切分：将输入行划分为多个域&lt;br /&gt;3.匹配：根据pattern匹配&lt;br /&gt;4.执行：对匹配的行执行action&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;&lt;span&gt;命令行&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;AWK的命令行语法有两种形式&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;awk [options] -f program-file file...&lt;br /&gt;awk [options] 'program-text' file...&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;前者通过-f参数指定使用后面的名为program-file的文件作为AWK脚本处理输入文件file&lt;br /&gt;后者表示 program-text是一段AWK命令行脚本，用于处理输入文件file.&lt;br /&gt;options表示参数可选项，具体参数列表请参考相关手册。&lt;br /&gt;基本语法：&lt;br /&gt;当通过awk [options] 'program-text' file...方式执行awk时，program-text表示一段脚本。AWK的命令行脚本由模式和操作两部分组成：&lt;br /&gt;pattern {action}，表示对输入文件中所有匹配pattern的行，执行action操作。&lt;br /&gt;缺少pattern时，默认对输入文件中所有行执行action&lt;br /&gt;缺少action时，默认向标准输出打印所有匹配pattern的行&lt;br /&gt;两者都没有时，不进行任何操作。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;strong&gt;&lt;span&gt;例子：&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;awk '/for/ {print $1}'&lt;strong&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;&lt;/strong&gt;datafile 表示打印datafile中所有匹配含有for的行的第一个域（关于域，请看下文）&lt;br /&gt;awk '/for/' &amp;nbsp; &amp;nbsp;datafile 表示打印datafile中所有包含for的行&lt;br /&gt;awk '{print}' &amp;nbsp; &amp;nbsp;datafile 表示打印datafile中所有行&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;&lt;span&gt;模式pattern:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;pattern分为Simple pattern和Range pattern两大类。&lt;br /&gt;&lt;strong&gt;&lt;span&gt;Simple Pattern&lt;/span&gt;&lt;/strong&gt;包括：&lt;br /&gt;a.BEGIN:标示对输入文件进行处理之前&lt;br /&gt;b.END:标示对输入文件完成处理之后&lt;br /&gt;c.EXPRESSION:表达式，包括正则表达式，算数表达式，逻辑表达式&lt;br /&gt;d.NOTHING:什么都没有，表示无pattern，默认匹配所有行&lt;br /&gt;&lt;strong&gt;Expression Pattern：&lt;/strong&gt;&lt;br /&gt;正则表达式/regx/：&lt;br /&gt;通过两个/标记的pattern为正则表达式，如/^bi/匹配所有以bi开始的记录，正则表达式语法与grep语法类似，不再赘述，请查看相关手册。&lt;br /&gt;需要注意的是 ~/regx/表示不匹配，如~/^bi/表示不是以bi开始的所有记录。&lt;br /&gt;算数表达式：&lt;br /&gt;模式$3*$4&amp;amp;gt;100 表示匹配所有$3与$4的积大于100的记录，类似的算数操作符还包括：&lt;br /&gt;逻辑表达式：&lt;br /&gt;模式 $NR&amp;amp;gt;2 &amp;amp;amp;&amp;amp;amp; /^bi/ 表示匹配所有行数大于2以bi开头的的行， &amp;amp;amp;&amp;amp;amp;表示逻辑与&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;&lt;span&gt;Range Pattern&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;Range Pattern用于匹配输入行中一个连续的区域，其语法由两个Simple Pattern构成：&lt;br /&gt;pattern1, pattern2 {action}&lt;br /&gt;pattern1表示从第一个匹配pattern1的行开始，执行action操作。&lt;br /&gt;pattern2表示从第一个匹配pattern2的行开始，停止执行action操作。&lt;br /&gt;&lt;strong&gt;&lt;span&gt;例子：&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;&lt;span&gt;awk '/blue/,/yellow/ {print}' datafile&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;表示从datafile中第一匹配blue的行开始执行print操作，打印整行，到第一个匹配yellow的行为止，停止打印。&lt;br /&gt;&lt;br /&gt;&lt;span&gt;awk '$NR==2, $NR==10 {print}' datafile&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;表示打印datafile中的第2～10行。&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;&lt;span&gt;操作Action&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;Action语句分为：表达式，输出，判断，循环，和控制语句。&lt;br /&gt;&lt;strong&gt;&lt;span&gt;表达式&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;作为一门编程语言，AWK与其他语言一样，有变量，运算符，可以进行表达式计算。&lt;br /&gt;&lt;strong&gt;&lt;span&gt;变量&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;AWK是弱类型的，变量无须声明，且第一次引用后就一直存在。所有的变量都被初始化为空字符串。变量名必须以字母开头，可以包含字母，数字和下划线。AWK支持三类变量，数字，字符串，数组。&lt;br /&gt;需要特殊说明的是数组，数组只支持一维，且索引可以是数字也可以是字符串（因此我更倾向于它是个map）。可以通过&lt;br /&gt;&lt;br /&gt;delete arr[index]&lt;br /&gt;&lt;br /&gt;删除数组arr中index元素&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;&lt;span&gt;赋值操作符&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;=	 assign result of right-hand-side expression to left-hand-side variable&lt;br /&gt;++	Add 1 to variable&lt;br /&gt;--	 Subtract 1 from variable&lt;br /&gt;+=	Assign result of addition&lt;br /&gt;-=	 Assign result of subtraction&lt;br /&gt;*=	 Assign result of multiplication&lt;br /&gt;/=	 Assign result of division&lt;br /&gt;%=	Assign result of modulo&lt;br /&gt;^=	 Assign result of exponentiation&lt;br /&gt;&lt;strong&gt;&lt;span&gt;输出语句&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;AWK中有三种用于输出的内置函数：&lt;br /&gt;print	 直接输出到终端&lt;br /&gt;printf	 格式化输出到终端（与C中的printf类似）&lt;br /&gt;sprintf	 格式化字符串（与C中不同的是，通过返回值方式返回新的字符串）&lt;br /&gt;可以通过输出重定向将输出打印到其他地方：&lt;br /&gt;&amp;amp;gt; &amp;amp;quot;file&amp;amp;quot;	清空file，并打印输出到file&lt;br /&gt;&amp;amp;gt;&amp;amp;gt; &amp;amp;quot;file&amp;amp;quot;	将输出追加到file末尾&lt;br /&gt;| &amp;amp;quot;command&amp;amp;quot;	管道符，将输出作为command命令的输入。&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;&lt;span&gt;条件判断&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;&lt;strong&gt;if-else语法：&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;if (条件语句)&lt;br /&gt;执行语句1&lt;br /&gt;else&lt;br /&gt;执行语句2&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;例子:&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;&lt;span&gt;if(NR&amp;lt;3)&lt;br /&gt;print $2&lt;br /&gt;else&lt;br /&gt;print $3&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span&gt;循环&lt;/span&gt;&lt;br /&gt;&lt;strong&gt;&lt;span&gt;for循环&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;&lt;strong&gt;语法&lt;br /&gt;&lt;/strong&gt;&lt;br /&gt;for(初始条件;限制条件;条件更新)&lt;br /&gt;执行语句&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;例子&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;&lt;span&gt;for(i=1; i&amp;lt;NR; i++)&lt;br /&gt;{&lt;br /&gt;total +=$i;&lt;br /&gt;count++&lt;br /&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span&gt;&lt;strong&gt;do-while循环&lt;/strong&gt;&lt;/span&gt;&lt;br /&gt;&lt;strong&gt;语法&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;do&lt;br /&gt;执行语句&lt;br /&gt;while(条件)&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;例子&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;&lt;span&gt;i=1&lt;br /&gt;do {&lt;br /&gt;print $0&lt;br /&gt;i++&lt;br /&gt;} while (i&amp;lt;=10)&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;AWK同样支持break,continue两个循环控制语句。&lt;br /&gt;&lt;br /&gt;&lt;span&gt;&lt;strong&gt;脚本编程&lt;/strong&gt;&lt;/span&gt;&lt;br /&gt;上文主要讲述了命令行下，AWK可以进行操作的基本知识，事实上，AWK作为一种编程语言，可以独立写成脚本文件，采用&lt;br /&gt;&lt;br /&gt;&lt;span&gt;awk [options] -f script-file inputfile...&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;的方式执行。&lt;br /&gt;通常一个awk包含三段式基本结构&lt;br /&gt;&lt;br /&gt;--------BEGIN区----------&lt;br /&gt;|	BEGIN {初始化操作 } |&lt;br /&gt;--------命令执行----------&lt;br /&gt;|	pattern	{action} &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br /&gt;|	...&lt;br /&gt;|	pattern	{action} &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br /&gt;---------END区-----------&lt;br /&gt;|	EDN &amp;nbsp;{结尾操作} &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br /&gt;----------------------------&lt;br /&gt;BEGIN语句进行文件处理前的初始化操作，如定义FS，定义变量值等。该语句在一次文件处理过程中只在处理前执行一次&lt;br /&gt;中间的命令执行是对每一个输入记录都进行的操作，语法与上述的基础语法一样&lt;br /&gt;END区只在文件处理完成后执行一次。&lt;br /&gt;例子&lt;br /&gt;&lt;br /&gt;&lt;span&gt;&lt;span&gt;BEGIN { FS=: }&lt;br /&gt;/for/ {print $2}&lt;br /&gt;END {print &quot;this is end!&quot; }&lt;/span&gt;&lt;br /&gt;&lt;/span&gt;&lt;br /&gt;先定义域分隔符为&quot;:&quot;，然后对所有匹配for的记录，打印第2个域，文件处理完后打印&quot;this is end!&quot;&lt;br /&gt;&lt;br /&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;内置函数&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;AWK提供一些内置函数。&lt;br /&gt;字符串内置函数：&lt;br /&gt;sub (regex, substr), 使用substr替换匹配自左向右做大匹配regex的部分。&lt;br /&gt;gsub (regex,substr), 与sub类似，只是在全文中进行替换&lt;br /&gt;length(string), 获取string字符串的长度&lt;br /&gt;toupper(string), 将string转换为大写&lt;br /&gt;tolower(string), 将string转换为小写&lt;br /&gt;split(string, array, field separator), 将string以field separator为分隔符分割为数组存储到array中。&lt;br /&gt;以上只是常用的一些内置函数，其他请参考相关手册&lt;br /&gt;&lt;br /&gt;&lt;span&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/span&gt;&lt;br /&gt;分析日志，现有一份日志pic.log，格式如下，需要提取出其中的url链接&lt;br /&gt;&lt;br /&gt;INFO 10/18/2010 00:00:05--offerId=[836952303]. url=[http://f7.images22.51img1.com/6000/hw3255311/7205a450f1ea2751f31aa8c3ad1dd2be.jpg].&lt;br /&gt;INFO 10/18/2010 00:00:05--offerId=[836952303]. url=[http://fb.images22.51img1.com/6000/hw3255311/bfe077567231f7d8efae4a1ac1b19477.jpg].&lt;br /&gt;INFO 10/18/2010 00:00:05--offerId=[836952303]. url=[http://f6.images22.51img1.com/6000/hw3255311/6106d6366351d32c68e3f8a332b52da9.jpg].&lt;br /&gt;INFO 10/18/2010 00:00:05--offerId=[836952303]. url=[http://f6.images22.51img1.com/6000/hw3255311/6106d6366351d32c68e3f8a332b52da9.jpg].&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;&lt;span&gt;脚本&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;&lt;span&gt;awk -F &quot;[&quot; '{split($3, url, &quot;]&quot;);print url[1]}' pic.log&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;通过 -F &quot;:&quot;定义域分隔符为&quot;[&quot;,这样每行数据会被划分为三个域&lt;br /&gt;&lt;br /&gt;INFO 10/18/2010 00:00:05--offerId=	--[-- 836952303]. url=	--[-- http://f7.images22.51img1.com/6000/hw3255311/7205a450f1ea2751f31aa8c3ad1dd2be.jpg].&lt;br /&gt;&lt;br /&gt;所需要提取的url位于第三个域中，通过内置函数&lt;br /&gt;&lt;br /&gt;&lt;span&gt;split($3, url, &quot;]&quot;)&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;将第三个域以&quot;]&quot;分割，存储到url数组中，url数组为[&quot;http://f7.images22.51img1.com/6000/hw3255311/7205a450f1ea2751f31aa8c3ad1dd2be.jpg&quot;, &quot;.&quot;]&lt;br /&gt;url[1]即为所需的url&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;a. man awk&lt;br /&gt;b. AWK wiki，http://en.wikipedia.org/wiki/AWK&lt;br /&gt;c.《AWK学习笔记》http://man.lupaworld.com/content/manage/ringkee/awk.htm&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Linux启动过程分析</title>
   <link href="http://jiang-bo.github.com/blog/2010/10/26/post"/>
   <updated>2010-10-26T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2010/10/26/post</id>
   <content type="html">&lt;h3&gt;史前时代：BIOS-计算机的启动过程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;加电&lt;/strong&gt;
 
电源加电，主板芯片组像CPU发粗RESET信号，使CPU恢复到初始状态。当芯片组检测到电源开始稳定供电时会撤去RESET信号（松开重启建类似），
这是CPU从0xfff0除开始执行指令。该地址位于BIOS寻址范围内。BIOS厂商通常在该地址放一条跳转指令，跳到真正BIOS启动代码除。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自检&lt;/strong&gt;
 BIOS启动代码首先进行POST（Power-On Self 
Test，上电自检），POST的主要任务是检测系统中一些关键设备是否存在和能否正常工作， 
例如内存和显卡等。如果系统BIOS在POST过程中发现致命错误，如未找到内存或内存有问题（640K内的常规内存），系统会直接控制喇叭报告错误，声
音的长短和次数代表错误的类型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设备初始化&lt;/strong&gt;
 
POST完成后BIOS会查找显卡的BIOS，存放显卡BIOS的ROM芯片的起始地址通常设在0xC0000处，找到显卡BIOS后，调用其初始代码，
由显卡BIOS来初始化显卡， 
此时多数显卡会在屏幕上显示出一些初始化信息，介绍生产厂商，图形芯片等内容。类似地，BIOS会查找其它设备的BIOS程序，调用这些BIOS内部的初
始化代码来初始化相关设备。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试设备&lt;/strong&gt;
 
查找完所遇其它设备的BIOS之后，系统BIOS将显示自己的启动画面，其中包括系统BIOS类型，序列号和版本号等内容。接着BIOS将检测和显示
CPU的类型和工作频率，然后开始测试所有的RAM，并同时在屏幕上显示内存测试的进度。 
内存测试通过后，系统BIOS将开始检测系统中安装的一些标准硬件设备，包括硬盘，光驱，串口，并口，软驱等，另外绝大多数较新版本的BIOS在这一过程
中回自动检测和设置内存的定时参数，硬盘参数和配置系统中安装的即插即用设备，没找到一个设备之后，BIOS会在屏幕上显示出设备的名称和型号等信息，同
时为该设备分配中断，DMA通道和I/O端口。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更新ESCD&lt;/strong&gt;
 
所有硬件检测配置完毕后，多数BIOS会重新清屏，并在屏幕上方显示出一个表格，其中概略的列出系统中安装的各种标准硬件设备，以及他们使用的资源和一些
相关工作参数。接下来系统BIOS将更新ESCE（Extended System Configration Data， 
扩展系统配置数据）。ESCD是系统BIOS用来与操作系统交换硬件配置信息的一种手段，这些数据被存放在CMOS（Complementary 
metal oxide Semiconductor,互补金属氧化物半导体）之中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;启动操作系统&lt;/strong&gt;
 
ESCD更新完毕后，系统BIOS的启动代码将进行他的最后一项工作，即根据用户指定的启动顺序从软盘，硬盘或光驱启动操作系统。系统BIOS将启动盘的
第一个扇区读入到内存的0x7C00除，并检查0x7dfe地址的内存，如果其内容是0xaa55，跳转到0x7c00处执行MBR（Master 
Boot 
Record，主引导记录），MBR从分区表中找到第一个活动分区，按照类似方式读取并执行这个活动分区的引导扇区，该引导扇区负责读取并执行
bootloader（windows下C盘中的NTLDR），由bootloader加载系统内核&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;a name=&quot;Linux启动过程-远古时代：Bootloader&quot;&gt;&lt;/a&gt;
远古时代：Bootloader&lt;/h3&gt;
&lt;p&gt;	引导装入程序（Bootloader）是BIOS将操作系统内核映像装载到RAM中执行的第一个程序。&lt;br /&gt;
	软盘启动与磁盘启动过程稍有不同，软盘启动时，BIOS将启动软盘的第一扇区指令装载到RAM中，由于通常现代内核都大于一个扇区大小(512B)，因此第一扇区的指令通常是将包含内核映像的扇区加载到RAM中。&lt;br /&gt;
	从硬盘启动时，硬盘的第一个扇区MBR中包含分区表和一小段程序，这段小程序用来装载被启动的操作系统所在分区的第一个扇区。Win98采用MBR中的小程序加载操作系统内核，而Linux在用一种更灵活的加载方式，bootloader。&lt;br /&gt;
	Linux2.4及以前的版本，在第一个512字节有一个最小的引导程序，因此在第一扇区拷贝一个内核镜像就可以使软盘启动，但在2.6内核中不再有该引导程序，要想在软盘中启动，必须采用与磁盘类似的方式，在第一个扇区中装入一个引导程序。&lt;br /&gt;
	
Bootloader通常被安装在MBR上代替上面负责引导的小程序。Bootloader通常由于大于一个扇区，会被分为两部分，在BIOS将
Bootloader的第一部分加载到RAM的0x00007c00处开始执行，bootloader自己加载到0x00096a00，建立实模式站
(0x00098000~0x000969ff),并将bootloader的第二部分装入到0x00096c00开始的RAM中。&lt;br /&gt;
	第二部分一次从此版读取操作系统映射表，提示给用户，用户可以选择要启动的系统，引动程序将相应分区的引导扇区拷贝到RAM中并执行，或直接将内核拷贝到RAM中。&lt;br /&gt;
	Bootloader的主要执行过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用BIOS输出&amp;quot;Loading...&amp;quot;&lt;/li&gt;
&lt;li&gt;调用BIOS从磁盘装入内核映像的第一个扇区(512B)，从0x00090000装入RAM，并将setup()函数的代码从0x00090200开始装入RAM。&lt;/li&gt;
&lt;li&gt;调用一个BIOS从磁盘装入其余内核映像，并把内核映像放入从0x00010000(低装载，适用于make zImage的小内核映像）或0x00100000(高装载，make bzImage的大内核映像）&lt;/li&gt;
&lt;li&gt;跳转执行setup()&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;a name=&quot;Linux启动过程-奴隶社会：setup()&quot;&gt;&lt;/a&gt;
奴隶社会：setup()&lt;/h3&gt;
&lt;p&gt;	setup()函数有汇编实现放在内核映像文件的偏移量0x200处，bootloader将其装载到0x00090200开始的RAM中。&lt;br /&gt;
	setup()函数的主要工作是初始化计算机中的硬件设备，并为内核程序的执行建立环境。尽管BIOS已经完成大部分设备的初始化，但是Linux并不依赖与BIOS，而已自己的方式重新初始化设备，以增强可移植性和健壮性。&lt;br /&gt;
	@TO-DO setup()过程&lt;/p&gt;
&lt;h3&gt;&lt;a name=&quot;Linux启动过程-封建社会：startup32()&quot;&gt;&lt;/a&gt;
封建社会：startup_32()&lt;/h3&gt;
&lt;p&gt;	
存在两个startup_32函数，setup()的最后是跳转执行的是arch/i386/boot/compressed/head.S中的
startup_32()，此时startup_32已经被移动到0x00100000或0x00001000，对应于高装载或低装载。该函数的主要工作
是解压内核。&lt;br /&gt;
	解压完的内核映像从arch/i386/kernel/head.S开始执行。该文件中包含另一个startup_32函数。改startup_32为Linux的第一个进程(pid=0)建立执行环境。&lt;br /&gt;
	@TO-DO startup_32()过程&lt;/p&gt;
&lt;h3&gt;&lt;a name=&quot;Linux启动过程-民国时代：startkernel()&quot;&gt;&lt;/a&gt;
民国时代：start_kernel()&lt;/h3&gt;
&lt;p&gt;	startup_32函数最后回跳转执行start_kernel()，start_kernel完成内核初始化工作。start_kernel开始执行后会显示&amp;quot;Linux version 2.6.11...&amp;quot;&lt;br /&gt;
	该函数中最主要的一个步骤是调用kernel_thread()为进程1创建内核线程。这个线程回创建其它线程并执行/sbin/init程序。该程序会在控制台输出初始化信息，直至最后出现登录提示符，或X登录窗口。通知用户内核已启动，正在运行。&lt;/p&gt;
&lt;h3&gt;&lt;a name=&quot;Linux启动过程-新中国：启动脚本&quot;&gt;&lt;/a&gt;
新中国：启动脚本&lt;/h3&gt;
&lt;p&gt;(该部分只适用Redhat系，如RHEL，CentOS，Fedora等，Debian/Ubuntu启动过程与此不同，后期会有分析)&lt;/p&gt;
&lt;h5&gt;&lt;a name=&quot;Linux启动过程-inittab&quot;&gt;&lt;/a&gt;
inittab&lt;/h5&gt;
&lt;p&gt;	/sbin/init（进程1）会利用/etc/inittab获取运行级，并根据不同运行级的配置启动不同的服务项目。&lt;br /&gt;
	inittab配置文件格式&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;
&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;[设置项目]:[run level]:[init的操作行为]:[命令项目]&lt;br /&gt;
设置项目:最多4个字符，表示init的主要目的，就是一个名字&lt;br /&gt;
run level:该条目的运行级别&lt;br /&gt;
init操作行为:&lt;br /&gt;
	主要可选值如下：&lt;br /&gt;
		initdefault:表示默认的运行级别值&lt;br /&gt;
		sysinit:系统初始化操作项目&lt;br /&gt;
		ctrlaltdel:表示[ctrl+alt+del&lt;br /&gt;
		wait:表示必须等待后面的命令执行完才可以执行后续操作&lt;br /&gt;
		respawn:表示后面的操作会重新启动&lt;br /&gt;
命令项目:执行该项目的命令，通常为一个脚本命令&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h5&gt;&lt;a name=&quot;Linux启动过程-系统初始化(rc.sysinit)&quot;&gt;&lt;/a&gt;
系统初始化(rc.sysinit)&lt;/h5&gt;
&lt;p&gt;	inittab中的有个条目是&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;
&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;si::sysinit:/etc/rc.d/rc.sysinit&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;按上述条目解释，系统初始化时会执行/etc/rc.d/rc.sysinit脚本，该脚本的主要功能如下:&lt;br /&gt;
1.获取网络环境与主机名&lt;br /&gt;
2.测试与载入内存设备/proc以及USB设备/sys&lt;br /&gt;
3.决定是否启动SELinux&lt;br /&gt;
4.检测接口设备与即插即用设备参数&lt;br /&gt;
5.用户自定义模块加载&lt;br /&gt;
6.加载核心的相关设置&lt;br /&gt;
7.设置系统时间&lt;br /&gt;
8.设置终端控制台字体&lt;br /&gt;
9.设置RAID与LVM等硬盘功能&lt;br /&gt;
10.fsck检查磁盘文件系统&lt;br /&gt;
11.进行磁盘配额quota的转换&lt;br /&gt;
12.重新怡可读取模式载入系统磁盘&lt;br /&gt;
13.启动quota功能&lt;br /&gt;
14.启动系统随机设备（产生随机数）&lt;br /&gt;
15.清除启动过程的临时文件&lt;br /&gt;
16.将启动相关信息加载到/var/log/dmesg文件中&lt;/p&gt;
&lt;h5&gt;&lt;a name=&quot;Linux启动过程-启动相关运行级服务&quot;&gt;&lt;/a&gt;
启动相关运行级服务&lt;/h5&gt;
&lt;p&gt;	inittab中包含&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;
&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;id:3:initdefault:&lt;br /&gt;
&lt;br /&gt;
l3:3:wait:/etc/rc.d/rc 3&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;	第一行表示默认运行级为3，第二行表示第3级运行时以wait方式执行/etc/rc.d/rc 参数为3。&lt;br /&gt;
	rc脚本的主要功能是调用相应运行级X的配置脚本目录/etc/rcX.d/下的脚本。例如3级时对应的脚本目录是/etc/rc3.d/目录。&lt;br /&gt;
	脚本目录下的脚本名分为两类：一类是以K开头的，用于kill相应服务；另一类是以S开头的，用于开启相应服务。文件中还包含一个两位数字和服务名。rc脚本负责按照数字有小到大先kill所有服务然后开启所有服务的顺序执行。&lt;br /&gt;
	每个rcX.d的目录下的脚本都是链接到init.d目录下的脚本的软连接。并且均包含一个S99local-&amp;gt;../rc.local，该脚本表示最后执行../rc.local脚本。&lt;br /&gt;
	rc.local即用户自定义的启动项配置脚本。可以在其中添加想开机启动的命令。比如想自动挂载一个windows下的分区，可以在rc.local中添加&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;
&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;mount -ntfs /dev/sda5 /media/disk5&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h5&gt;&lt;a name=&quot;Linux启动过程-启动终端&quot;&gt;&lt;/a&gt;
启动终端&lt;/h5&gt;
&lt;p&gt;	根据inittab中的配置，需要等待/etc/rc 3 运行完成。rc.local时期最后一个脚本。在rc.local执行完之后，继续按照inittab执行&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;
&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;# Run gettys in standard runlevels&lt;br /&gt;
1:2345:respawn:/sbin/mingetty tty1&lt;br /&gt;
2:2345:respawn:/sbin/mingetty tty2&lt;br /&gt;
3:2345:respawn:/sbin/mingetty tty3&lt;br /&gt;
4:2345:respawn:/sbin/mingetty tty4&lt;br /&gt;
5:2345:respawn:/sbin/mingetty tty5&lt;br /&gt;
6:2345:respawn:/sbin/mingetty tty6&lt;br /&gt;
&lt;br /&gt;
# Run xdm in runlevel 5&lt;br /&gt;
x:5:respawn:/etc/X11/prefdm -nodaemon&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;该段配置表示在2,3,4,5运行级下执行/sbin/mingetty开启终端，并且执行六次，由此可知为何会有6个纯文本终端。最后的x:5:respawn:/etc/X11/prefdm -nodaemon表示在运行级5时开启X Window。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>在Spring中使用Quartz</title>
   <link href="http://jiang-bo.github.com/blog/2010/10/18/post"/>
   <updated>2010-10-18T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2010/10/18/post</id>
   <content type="html">&lt;p&gt;	Spring 提供了几个帮助类用于在应用中做调度，包括JDK Timer类和OpenSymphony Quartz Scheduler两种.&lt;/p&gt;
&lt;h3&gt;&lt;a name=&quot;在Spring中使用Quartz-Quartz基础&quot;&gt;&lt;/a&gt;

Quartz基础	&lt;/h3&gt;
&lt;p&gt;	Quartz包括五种主要结构用于实现调度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Job接口&lt;/li&gt;
&lt;li&gt;JobDetail类&lt;/li&gt;
&lt;li&gt;Trigger 抽象类&lt;/li&gt;
&lt;li&gt;Scheduler接口&lt;/li&gt;
&lt;li&gt;SchedulerFactory 接口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;	Job接口表示一个作业(job)。一个作业专注做一件事。它的API非常简洁。只有一个execute方法，该方法在作业被执行时有Quartz调度。该方法有一个JobExecuteContext参数，可以通过该参数给execute()方法传递有用信息。&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: java&quot;&gt;public interface Job{
    void execute(JobExecuteContext ctx);
}&lt;/pre&gt;
&lt;/p&gt;
&lt;p&gt;一些数据可以通过JobDataMap传递给作业。如果一个JobDataMap被注册到JobDetail中，就能够在作业中通过
JobExecuteContext来访问。JobDetail用来描述一个特定Job的信息。Job通过触发器（Trigger）触发。Quartz提
供了集中Trigger的实现，如SimpleTrigger和CronTrigger。SimpleTrigger类似一个简单时钟，你可以定义开始是
建，结束时间，重复次数，重复周期。CronTrigger类似Linux系统中的cron。CronTrigger的设置可以非常详细，如在每个月最后
一个周五的上午10:15执行作业。需要注意的是Trigger和Job是具名的，可以被赋值给一个组，在同一组内不能出现同名。你可以对一个组创建一个
触发器，在该组内的所有Job都将会执行。&lt;br /&gt;

	SchedulerFactory 用于获得Scheduler实例，可以用于注册作业和触发器。&lt;br /&gt;

	实现一个简单的实例：每十秒钟打印一次欢迎。&lt;br /&gt;

	首先实现一个作业：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: java&quot;&gt;public class SimpleJob implements Job {
	@Override
	public void execute(JobExecutionContext arg0)
	throws JobExecutionException {
		System.out.println(&amp;quot;[JOB] Welcome to Quartz!&amp;quot;);
	}
}&lt;/pre&gt;
&lt;/p&gt;
&lt;p&gt;定义一个Scheduler，注册触发器和作业:&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: java&quot;&gt;public class SimpleSchedule {
	public static void main(String[] args) {
		SchedulerFactory factory=new StdSchedulerFactory();
		try {
			Scheduler scheduler = factory.getScheduler();
			scheduler.start();
										            
			JobDetail jobDetail = new JobDetail(&amp;quot;SimpleJob&amp;quot;,null, SimpleJob.class);
			Trigger simplerTrigger = TriggerUtils.makeSecondlyTrigger(10);
			simplerTrigger.setName(&amp;quot;SimpleTrigger&amp;quot;);
										            
			scheduler.scheduleJob(jobDetail, simplerTrigger);
		}catch (SchedulerException e) {
		    // TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}&lt;/pre&gt;
&lt;/p&gt;
&lt;p&gt;执行过后，每十秒输出&lt;span class=&quot;nobr&quot;&gt;[JOB]&lt;/span&gt;

Welcome to Quartz!&lt;/p&gt;
&lt;h3&gt;Spring中的Quartz&lt;/h3&gt;
&lt;p&gt;	Spring中的Quartz API位于org.springframework.scheduling.quartz包中。主要类结构包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;QuartzJobBean 抽象类&lt;/li&gt;
&lt;li&gt;JobDetailBean&lt;/li&gt;
&lt;li&gt;SimpleTriggerBean&lt;/li&gt;
&lt;li&gt;CronTriggerBean&lt;/li&gt;
&lt;li&gt;SchedulerFactoryBean&lt;/li&gt;
&lt;li&gt;MethodInvokingDetailFactoryBean
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
很明显对应实现Quartz中相应的接口。QuartzJob实现Job，JobDetailBean继承JobDetail。
SimpleTriggerBean和CronTriggerBean继承自相应的Trigger。
MethodInvokingJobDetailFactoryBean用于在类中调用任何对象的方法。&lt;br /&gt;
&lt;strong&gt;声明Job
&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;JobDetailBean用于声明作业。可以为其设置作业名，以及需要的数据。&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: xhtml&quot;&gt;&amp;lt;bean name=&amp;quot;simpleJob&amp;quot; class=&amp;quot;org.springframework.scheduling.quartz.JobDetailBean&amp;quot;&amp;gt;
	&amp;lt;property name=&amp;quot;jobClass&amp;quot; value=&amp;quot;com.alibaba.jiang.learn.quartz.SimpleJob&amp;quot; /&amp;gt;
	&amp;lt;property name=&amp;quot;jobDataAsMap&amp;quot;&amp;gt;
		&amp;lt;map&amp;gt;
			&amp;lt;entry key=&amp;quot;message&amp;quot; value=&amp;quot;Welcome to Quartz&amp;quot; /&amp;gt;
		&amp;lt;/map&amp;gt;
	&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/pre&gt;
&lt;/p&gt;
&lt;p&gt;实现Job类：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: java&quot;&gt;public class SimpleJob extends QuartzJobBean {
	@Override
	protected void executeInternal(JobExecutionContext ctx) throws JobExecutionException {
		String message = ctx.getJobDetail().getJobDataMap().getString(&amp;quot;message&amp;quot;);
		System.out.println(message);
	}
}&lt;/pre&gt;
&lt;/p&gt;
&lt;p&gt;还可以通过setter注入的方式注入message。&lt;br /&gt;
声明触发器：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: xhtml&quot;&gt;&amp;lt;bean name=&amp;quot;simpleTrigger&amp;quot; class=&amp;quot;org.springframework.scheduling.quartz.SimpleTriggerBean&amp;quot;&amp;gt;
	&amp;lt;property name=&amp;quot;jobDetail&amp;quot; ref=&amp;quot;simpleJob&amp;quot;/&amp;gt;
	&amp;lt;property name=&amp;quot;startDelay&amp;quot; value=&amp;quot;0&amp;quot;/&amp;gt;
	&amp;lt;property name=&amp;quot;repeatInterval&amp;quot; value=&amp;quot;10000&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/pre&gt;
&lt;/p&gt;
&lt;p&gt;声明调度器,设置Job和Trigger：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: xhtml&quot;&gt;&amp;lt;bean name=&amp;quot;schedulerFactory&amp;quot; class=&amp;quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&amp;quot;&amp;gt;
	&amp;lt;property name=&amp;quot;triggers&amp;quot;&amp;gt;
		&amp;lt;list&amp;gt;
			&amp;lt;ref bean=&amp;quot;simpleTrigger&amp;quot;/&amp;gt;
		&amp;lt;/list&amp;gt;
	&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/pre&gt;
&lt;/p&gt;
&lt;p&gt;所有都设置好后，可以通过加载Context，调度器将自动执行：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: java&quot;&gt;public class SimpleSpringQuartz {
	public static void main(String[] args) {
		ApplicationContext ctx = new ClassPathXmlApplicationContext(&amp;quot;beans.xml&amp;quot;);
	}
}&lt;/pre&gt;
&lt;/p&gt;
&lt;h4&gt;使用MethodInvokingJobFactoryBean&lt;/h4&gt;
&lt;p&gt;上面的范例使用的是Quartz Job，事实上在Spring中可以使用自定义Pojo Bean，无须继承自QuartzJobBean。&lt;br /&gt;
首先声明一个PojoBean&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: xhtml&quot;&gt;&amp;lt;bean name=&amp;quot;welcomeBean&amp;quot; class=&amp;quot;com.alibaba.jiang.learn.quartz.WelcomeBean&amp;quot;&amp;gt;
	&amp;lt;property name=&amp;quot;message&amp;quot; value=&amp;quot;Welcome to Quartz Method&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/pre&gt;
&lt;/p&gt;
&lt;p&gt;对应的Pojo Bean：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: java&quot;&gt;public class WelcomeBean {
    private String message;
	public void setMessage(String message) {
		this.message = message;
	}
	public void welcome(){
		System.out.println(message);
	}
}&lt;/pre&gt;
&lt;/p&gt;
&lt;p&gt;声明MethodInvokingJobDetailFactoryBean:&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: xhtml&quot;&gt;&amp;lt;bean name=&amp;quot;methodInvokingJob&amp;quot; class=&amp;quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&amp;quot;&amp;gt;
	&amp;lt;property name=&amp;quot;targetObject&amp;quot; ref=&amp;quot;welcomeBean&amp;quot;/&amp;gt;
	&amp;lt;property name=&amp;quot;targetMethod&amp;quot; value=&amp;quot;welcome&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean name=&amp;quot;methodTrigger&amp;quot; class=&amp;quot;org.springframework.scheduling.quartz.SimpleTriggerBean&amp;quot;&amp;gt;
	&amp;lt;property name=&amp;quot;jobDetail&amp;quot; ref=&amp;quot;methodInvokingJob&amp;quot; /&amp;gt;
	&amp;lt;property name=&amp;quot;startDelay&amp;quot; value=&amp;quot;0&amp;quot;/&amp;gt;
	&amp;lt;property name=&amp;quot;repeatInterval&amp;quot; value=&amp;quot;10000&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/pre&gt;
&lt;/p&gt;
&lt;h4&gt;注意&lt;/h4&gt;
&lt;p&gt;一个触发器只能触发一个Job，不过一个Job可以有多个Trigger触发，这回带来并发问题。在Quartz中，如果你不想并发执行一个同一个
Job，你可以实现StatefulJob，而不是Job。在Spring中如果使用
MethodInvokingJobDetailFactoryBean，可以通过设置concurrent=&amp;quot;false&amp;quot;属性来实现。&lt;/p&gt;
&lt;h3&gt;&lt;a name=&quot;在Spring中使用Quartz-尾注&quot;&gt;&lt;/a&gt;
尾注&lt;/h3&gt;
&lt;p&gt;在Spring中使用Quartz而不是单独的一个应用的好处包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将所有的任务调度设置放在同一个地方，是任务易于维护。&lt;/li&gt;
&lt;li&gt;只对Job编码，Trigger和Scheduler可以通过配置设置&lt;/li&gt;
&lt;li&gt;可以使用Pojo Java Bean执行job，而无需实现Job接口&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>DBunit入门</title>
   <link href="http://jiang-bo.github.com/blog/2010/09/06/post"/>
   <updated>2010-09-06T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2010/09/06/post</id>
   <content type="html">&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a name=&quot;createtest&quot;&gt;使用DBTestCase子类设置数据库&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a name=&quot;createtest&quot;&gt;&lt;/a&gt; &lt;a name=&quot;createdataset&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;a name=&quot;createdataset&quot;&gt;第1步：创建你的数据集文件&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a name=&quot;createdataset&quot;&gt; &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你的测试需要一些数据来辅助。也就是说你必须创建一个数据集。在大多数情况下你会使用XML数据集。你可以手动从头创建一个&lt;a href=&quot;http://www.dbunit.org/components.html#FlatXmlDataSet&quot;&gt;flat XML数据集&lt;/a&gt;或从你的数据库中&lt;a href=&quot;http://www.dbunit.org/components.html#FlatXmlDataSet&quot;&gt;导出&lt;/a&gt;一些数据。&lt;/p&gt;
&lt;h4&gt;第2步：扩展类的DBTestCase&lt;/h4&gt;
&lt;p&gt;现在您需要创建一个测试类。最简单的使用DBUnit的方法是是你的测试类继承DBTestCase。DBTestCase扩展了JUnit TestCase类。一个getDataSet()模板方法必须被实现，该方法返回步骤1中创建的数据集。&lt;a class=&quot;code&quot;&gt;DBTestCase依赖IDatabaseTester来完成工作，默认配置使用PropertiesBasedJdbcDatabaseTester，它通过系统属性来定位DriverManager的配置。&lt;/a&gt;&lt;a class=&quot;code&quot;&gt;最简单的配置方法是通过测试类的构造函数来配置。&lt;/a&gt;&lt;a class=&quot;code&quot;&gt;你可以通过使用你自己的或其他3个系统提供的IDatabaseTester实现重载getDatabaseTester()来改变该行为。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你还可以使用如下所述其他的DBTestCase子类：&lt;/p&gt;
&lt;table class=&quot;bodyTable&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr class=&quot;a&quot;&gt;
&lt;td&gt;&lt;a class=&quot;code&quot;&gt;JdbcBasedDBTestCase&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;使用一个DriverManager创建连接（在JdbcDatabaseTester的辅助之下）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;b&quot;&gt;
&lt;td&gt;&lt;a class=&quot;code&quot;&gt;DataSourceBasedDBTestCase&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;使用javax.sql.DataSource创建连接（在DataSourceDatabaseTester的辅助之下）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;a&quot;&gt;
&lt;td&gt;&lt;a class=&quot;code&quot;&gt;JndiBasedDBTestCase&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;使用javax.sql.DataSource通过JNDI定位（在JndiDatabaseTester的辅助之下）。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;以下是一个示例实现，返回一个Hypersonic数据库连接和一个XML数据集：&lt;/p&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;pre&gt;&lt;pre class=&quot;brush: java&quot;&gt;public class SampleTest extends DBTestCase
{
    public SampleTest(String name)
    {
        super( name );
        System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_DRIVER_CLASS, &quot;org.hsqldb.jdbcDriver&quot; );
        System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_CONNECTION_URL, &quot;jdbc:hsqldb:sample&quot; );
        System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_USERNAME, &quot;sa&quot; );
        System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_PASSWORD, &quot;&quot; );
	// System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_SCHEMA, &quot;&quot; );
    }

    protected IDataSet getDataSet() throws Exception
    {
        return new FlatXmlDataSetBuilder().build(new FileInputStream(&quot;dataset.xml&quot;));
    }
}&lt;/pre&gt; &lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4&gt;第3步：（可选）实现getSetUpOperation（）和getTearDownOperation（）方法&lt;/h4&gt;
&lt;p&gt;默认情况下，DBUnit的执行每个测试之前回进行&lt;a href=&quot;http://www.dbunit.org/components.html#cleanInsert&quot;&gt;CLEAN_INSERT&lt;/a&gt;操作并且在之后没有清除操作。你可以通过重载getSetUpOperation（）和getTearDownOperation（）来改变这一行为。&lt;/p&gt;
&lt;p&gt;下面的示例展现了你可以很简单的重载测试前后的操作&lt;/p&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;pre&gt;&lt;pre class=&quot;brush: java&quot;&gt;public class SampleTest extends DBTestCase
{
    ...
    protected DatabaseOperation getSetUpOperation() throws Exception
    {
        return DatabaseOperation.REFRESH;
    }

    protected DatabaseOperation getTearDownOperation() throws Exception
    {
        return DatabaseOperation.NONE;
    }
    ...
}&lt;/pre&gt; &lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4&gt;第4步：（可选）重载方法setUpDatabaseConfig(DatabaseConfig congfig)&lt;/h4&gt;
&lt;p&gt;使用如下方法来改变DBUnit的DatabaseConfi中g某些配置设置。&lt;/p&gt;
&lt;p&gt;下面的示例演示如何你可以轻松地重写此方法：&lt;/p&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;pre&gt;&lt;pre class=&quot;brush: java&quot;&gt;public class SampleTest extends DBTestCase
{
    ...
    /**
     * Override method to set custom properties/features
     */
    protected void setUpDatabaseConfig(DatabaseConfig config) {
        config.setProperty(DatabaseConfig.PROPERTY_BATCH_SIZE, new Integer(97));
        config.setFeature(DatabaseConfig.FEATURE_BATCHED_STATEMENTS, true);
    }
    ...
}&lt;/pre&gt; &lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4&gt;第5步：实现你的testXXX（）方法&lt;/h4&gt;
&lt;p&gt;像正常使用JUnit一样实现你的测试方法。现在你的数据库将按照你之前几步所做设置那样在每个测试方法之前进行初始化并在之后进行清除操作。&lt;/p&gt;
&lt;p&gt; &lt;a name=&quot;noextend&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a name=&quot;noextend&quot;&gt;用你自己的TestCase子类来是设置数据库&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a name=&quot;noextend&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用Dbunit并不严格要求继承DBTestCase。你可以重写标准的JUnit的setUp()方法并在数据库上执行所需的操作。如果您需要执行清理还可以做一些类似tearDwon()的操作。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;pre&gt;&lt;pre class=&quot;brush: c-sharp&quot;&gt;public class SampleTest extends TestCase
{
    public SampleTest(String name)
    {
        super(name);
    }

    protected void setUp() throws Exception
    {
        super.setUp();

        // initialize your database connection here
        IDatabaseConnection connection = null;
        // ...

        // initialize your dataset here
        IDataSet dataSet = null;
        // ...

        try1
        {
            DatabaseOperation.CLEAN_INSERT.execute(connection, dataSet);
        }
        finally
        {
            connection.close();
        }
    }
    ...
}
&lt;/pre&gt; 


&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;自2.2版你可以使用新的IDatabaseTester来完成相同的壮举。如前所述，DBTestCase使用IDatabaseTester在内部进行工作，你的测试类也可以使用此方法来操纵数据集。目前有4个已有的实现：&lt;br /&gt;
&lt;table class=&quot;bodyTable&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr class=&quot;b&quot;&gt;
&lt;td&gt;&lt;a class=&quot;code&quot;&gt;JdbcDatabaseTester&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;使用一个DriverManager来创建连接。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;a&quot;&gt;
&lt;td&gt;&lt;a class=&quot;code&quot;&gt;PropertiesBasedJdbcDatabaseTester&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;同样使用DriverManager，但配置是采取从系统性能。&lt;br /&gt;DBTestCase的默认实现。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;b&quot;&gt;
&lt;td&gt;&lt;a class=&quot;code&quot;&gt;DataSourceDatabaseTester&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;使用javax.sql.DataSource创建连接。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;a&quot;&gt;
&lt;td&gt;&lt;a class=&quot;code&quot;&gt;JndiDatabaseTester&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;使用javax.sql.DataSource通过JNDI定位的。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br /&gt;你也可以自己实现IDatabaseTester接口。建议以AbstractDatabaseTester作为出发点。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;pre&gt;&lt;pre class=&quot;brush: java&quot;&gt;public class SampleTest extends TestCase
{
    private IDatabaseTester databaseTester;

    public SampleTest(String name)
    {
        super(name);
    }

    protected void setUp() throws Exception
    {
        databaseTester = new JdbcDatabaseTester(&quot;org.hsqldb.jdbcDriver&quot;,
            &quot;jdbc:hsqldb:sample&quot;, &quot;sa&quot;, &quot;&quot;);

        // initialize your dataset here
        IDataSet dataSet = null;
        // ...

        databaseTester.setDataSet( dataSet );
	// will call default setUpOperation
        databaseTester.onSetUp();
    }

    protected void tearDown() throws Exception
    {
	// will call default tearDownOperation
        databaseTester.onTearDown();
    }
    ...
}
&lt;/pre&gt; 



&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt; &lt;a name=&quot;assertdata&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a name=&quot;assertdata&quot;&gt;数据库数据检查&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a name=&quot;assertdata&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;DBUnit支持校验两个表或者数据集中包含的数据是否相同。以下两种方法可以用来验证在测试用例执行期间你的数据库是否包含预期的数据。&lt;/p&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;pre&gt;&lt;pre class=&quot;brush: java&quot;&gt;public class Assertion
{
    public static void assertEquals(ITable expected, ITable actual)
    public static void assertEquals(IDataSet expected, IDataSet actual)
}&lt;/pre&gt; &lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h4&gt;示例&lt;/h4&gt;
&lt;p&gt;下面的示例，说明如何对数据库表的快照和XML数据表进行比较&lt;/p&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;pre&gt;&lt;pre class=&quot;brush: java&quot;&gt;public class SampleTest extends DBTestCase
{
    public SampleTest(String name)
    {
        super(name);
    }

    // Implements required setup methods here
    ...

    public void testMe() throws Exception
    {
        // Execute the tested code that modify the database here
        ...


        // Fetch database data after executing your code
        IDataSet databaseDataSet = getConnection().createDataSet();
        ITable actualTable = databaseDataSet.getTable(&quot;TABLE_NAME&quot;);

        // Load expected data from an XML dataset
        IDataSet expectedDataSet = new FlatXmlDataSetBuilder().build(new File(&quot;expectedDataSet.xml&quot;));
        ITable expectedTable = expectedDataSet.getTable(&quot;TABLE_NAME&quot;);

        // Assert actual database table match expected table
        Assertion.assertEquals(expectedTable, actualTable);
    }
}
&lt;/pre&gt; 



&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;实际数据集是一个你要与预期的数据集进行比较的数据库快照。正如其名称表明，预期数据集包含的期望数据值。&lt;/p&gt;
&lt;p&gt;预期的数据集必须与你用来设置你的数据库的数据集不同。因此，你需要两个数据集，一在测试之前设置数据库，另一个是在测试过程中提供预期的数据。&lt;/p&gt;
&lt;p&gt; &lt;a name=&quot;assertquery&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;a name=&quot;assertquery&quot;&gt;使用查询获取数据库快照&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a name=&quot;assertquery&quot;&gt; &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你也可以验证一个查询的结果是否与预期的数据集相等。查询可以用来查询单个表的一个子集或多个表的级联查询。&lt;/p&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;pre&gt;ITable actualJoinData = getConnection().createQueryTable(&quot;RESULT_NAME&quot;,
                &quot;SELECT * FROM TABLE1, TABLE2 WHERE ...&quot;); ;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt; &lt;a name=&quot;compareignorecolumns&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;a name=&quot;compareignorecolumns&quot;&gt;在比较中忽略一些列&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a name=&quot;compareignorecolumns&quot;&gt; &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有时需要忽略一些列来进行比较;特别是主键，日期或时间值等根据测试代码生成的字段。一个解决方法是在期望的数据表中声明不需要的字段。然后，您可以筛选实际的数据库表只暴露预期的字段。&lt;br /&gt;下面的代码片断显示了如何筛选实际的数据表。为了能够运行，实际的表必须至少包含所有预期表中的字段列。实际表中可以包含期望表中没有的额外字段。&lt;/p&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;pre&gt;        
&lt;pre class=&quot;brush: java&quot;&gt;ITable filteredTable = DefaultColumnFilter.includedColumnsTable(actual, 
            expected.getTableMetaData().getColumns());
    Assertion.assertEquals(expected, filteredTable); &lt;/pre&gt; &lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;该技术的一个主要限制是你不能使用你的预期持平的XML数据集的DTD。有了你需要过滤的DTD列从预期的和实际的表。参见常见问题解答有关&lt;a href=&quot;http://www.dbunit.org/faq.html#columnfilter&quot;&gt;在运行时不包括一些表列&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt; &lt;a name=&quot;roworder&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;a name=&quot;roworder&quot;&gt;排序&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a name=&quot;roworder&quot;&gt; &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，DBUnit是按照主键排序来对获取数据库表的快照的。如果表没有主键或主键是数据库自动生成的，行的顺序是无法预测的，此时&lt;code&gt;assertEquals&lt;/code&gt;将失败。&lt;/p&gt;
&lt;p&gt;必须通过使用ORDER BY条件手动设置IDatabaseConnection.createQueryTable来获取排序的数据库表快照或者可以使用&lt;code&gt;SortedTable&lt;/code&gt;装饰类：&lt;/p&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;pre&gt;Assertion.assertEquals(new SortedTable(expected),
                new SortedTable(actual, expected.getTableMetaData()));      &lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;请注意，默认情况下SortedTable使用每一列的字符串值来排序因此，如果排序的是数字类型，排列顺序应该是如&lt;em&gt;1，10，11，12，2，3，4。&lt;/em&gt;如果您想使用列的数据类型进行排序，如&lt;em&gt;1，2，3，4，10，12），&lt;/em&gt;，可以如下操作：&lt;/p&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;pre&gt;&lt;pre class=&quot;brush: c-sharp&quot;&gt;SortedTable sortedTable1 = new SortedTable(table1, new String[]{&quot;COLUMN1&quot;});
          sortedTable1.setUseComparable(true); // must be invoked immediately after the constructor
          SortedTable sortedTable2 = new SortedTable(table2, new String[]{&quot;COLUMN1&quot;});
          sortedTable2.setUseComparable(true); // must be invoked immediately after the constructor
          Assertion.assertEquals(sortedTable1, sortedTable2);&lt;/pre&gt; 
      &lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;参数目前不放在构造方法中原因是这样会使SortedTable的构造方法由4个变为8个，太多了。&lt;em&gt;未来还需不断探索如何能更好地实现该功能&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt; &lt;a name=&quot;assert-collect-diff&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;a name=&quot;assert-collect-diff&quot;&gt;断言和收集差异&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a name=&quot;assert-collect-diff&quot;&gt; &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，DBUnit发现第一个不一致数据时立即失败从DBunit2.4开始，可以通过注册一个定制的FailHandler来指定什么样的异常会被抛出，以及发现数据不一致时如何处理。使用&lt;a href=&quot;http://www.dbunit.org/apidocs/org/dbunit/assertion/DiffCollectingFailureHandler.html&quot;&gt;DiffCollectingFailureHandler&lt;/a&gt;可以避免数据不匹配是抛出异常，使你可以在事后比对所有的结果集。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;pre&gt;&lt;pre class=&quot;brush: java&quot;&gt;IDataSet dataSet = getDataSet();
DiffCollectingFailureHandler myHandler = new DiffCollectingFailureHandler();
//invoke the assertion with the custom handler
assertion.assertEquals(dataSet.getTable(&quot;TEST_TABLE&quot;),
                       dataSet.getTable(&quot;TEST_TABLE_WITH_WRONG_VALUE&quot;),
                       myHandler);
// Evaluate the results and throw an failure if you wish
List diffList = myHandler.getDiffList();
Difference diff = (Difference)diffList.get(0);&lt;/pre&gt; &lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Linux批量转换文件名编码</title>
   <link href="http://jiang-bo.github.com/blog/2010/08/01/post"/>
   <updated>2010-08-01T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2010/08/01/post</id>
   <content type="html">&lt;p&gt;今天从网上用wget下了很多的电子书，不过文件名的编码都是GBK，系统默认为UTF-8，可以用convmv来转换文件名编码，例如将GBK编码的文件filename重命名为UTF-8：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: ruby:nogutter&quot;&gt;convmv -f gbk -t utf-8 filename --notest&lt;/pre&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;由于需要转换的文件比较多，写了个脚本来实现，主要就是一个文件目录的递归遍历：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: python:nogutter&quot;&gt;list_dir(){
for file in $1/*
do
if [ -d $file ]; then
echo &quot;$file is dirctory&quot;
list_dir $file
elif [ -f $file ]; then
echo &quot;convert $file...&quot;
convmv -f gbk -t utf-8 $file --notest
fi
done
}
if [ $# -gt 0 ]; then
list_dir &quot;$1&quot;
else
list_dir &quot;.&quot;
fi
&lt;/pre&gt;&amp;nbsp;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>linux批量重命名方法</title>
   <link href="http://jiang-bo.github.com/blog/2010/06/28/post"/>
   <updated>2010-06-28T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2010/06/28/post</id>
   <content type="html">&lt;p&gt;经常会遇到需要批量重命名文件的情况，用鼠标太夸张了，简单总结两种比较简单的方法：&lt;/p&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;p&gt;存在大量html文件，需要重命名为htm文件&lt;/p&gt;
&lt;p&gt;1.rename&lt;/p&gt;
&lt;p&gt;通常重命名的命令是mv，Larry Wall写的rename具有更强大的功能。能够用perl的正则语法结构进行文件重命名。&lt;pre class=&quot;brush: css:nogutter&quot;&gt;NAME
       rename - renames multiple files
SYNOPSIS
       rename [ -v ] [ -n ] [ -f ] perlexpr [ files ]
DESCRIPTION
       &amp;quot;rename&amp;quot; renames the filenames supplied according to the rule specified
       as the first argument.  The perlexpr argument is a Perl expression
       which is expected to modify the $_ string in Perl for at least some of
       the filenames specified.  If a given filename is not modified by the
       expression, it will not be renamed.  If no filenames are given on the
       command line, filenames will be read via standard input.
       For example, to rename all files matching &amp;quot;*.bak&amp;quot; to strip the
       extension, you might say
               rename 's//.bak$//' *.bak
       To translate uppercase names to lower, you'd use
               rename 'y/A-Z/a-z/' *&amp;nbsp;&lt;/pre&gt;
&lt;/p&gt;
&lt;p&gt;上面是rename的man手册，针对上面重命名html文件的问题，解决如下：&lt;/p&gt;
&lt;p&gt;rename 's/.html$/.htm/' *.html&lt;/p&gt;
&lt;p&gt;简单来说就是重命名所有html文件（*.html），将文件名结尾处.html替换为.htm('s/.html$/.htm/')，其实更简单的表达式可以为's/l$//'&lt;/p&gt;
&lt;p&gt;2.printf&lt;/p&gt;
&lt;p&gt;使用shell命令中的prinf打印出需要的文件名，然后在使用mv重命名&lt;/p&gt;
&lt;p&gt;for i in *.html&lt;/p&gt;
&lt;p&gt;do&lt;/p&gt;
&lt;p&gt;newname=&amp;quot;`printf &amp;quot;%s&amp;quot; ${i/html}`&amp;quot;htm&lt;/p&gt;
&lt;p&gt;mv $i $newname&lt;/p&gt;
&lt;p&gt;done&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>查询外网IP并发送邮件的脚本</title>
   <link href="http://jiang-bo.github.com/blog/2010/06/21/post"/>
   <updated>2010-06-21T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2010/06/21/post</id>
   <content type="html">&lt;p&gt;泡论坛时发现的小问题，自己做了下，记录如下：&lt;/p&gt;
&lt;p&gt;问题：如何查询服务器的外网IP并发送到指定邮箱？&lt;/p&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: c-sharp&quot;&gt;  1 #!/bin/sh
  2 
  3 
  4 ip=`curl -s 'http://checkip.dyndns.org' | sed 's/.*Current IP Address: /([0-    9/.]*/).*//1/g'`
  5 echo &amp;quot;Sending ip $ip...&amp;quot;
  6 
  7 to=&amp;quot;yourmail@yourdomain.com&amp;quot;
  8 subject=&amp;quot;IP&amp;quot;
  9 message=&amp;quot;IP is $ip&amp;quot;
 10 headers=&amp;quot;From:server@serverdomain&amp;quot;
 11 echo $message | mail -s $subject $to -- -f $headers
 12 echo &amp;quot;Send OK!&amp;quot;
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;大概思路：&lt;/p&gt;
&lt;p&gt;首先通过查询&amp;nbsp; http://checkip.dyndns.org获取外网IP，得到一个HTML页，sed过滤道多余的HTML标签，获得准确的IP&lt;/p&gt;
&lt;p&gt;然后通过sendmail发送邮件到指定邮箱&lt;/p&gt;
&lt;p&gt;需要安装curl和sendmail&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: c-sharp:nogutter&quot;&gt;sudo apt-get install curl
sudo apt-get install sendmail&lt;/pre&gt;
&lt;/p&gt;
&lt;p&gt;sendmail的配置比较复杂，不过可以使用默认的配置也能够发送邮件。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>maven报错Requested org.apache.maven.archetypes:maven-archetype-quickstart:jar</title>
   <link href="http://jiang-bo.github.com/blog/2010/04/24/post"/>
   <updated>2010-04-24T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2010/04/24/post</id>
   <content type="html">&lt;p&gt;今天重新安装maven，打包创建项目，mvn archetype:create -DgroupId=org.sonatype.mavenbook.ch03 /&lt;/p&gt;
&lt;p&gt;-DartifactId=simple /&lt;/p&gt;
&lt;p&gt;-DpackageName=org.sonatype.mavenbook&lt;/p&gt;
&lt;p&gt;结果报错Build Error：&lt;/p&gt;
&lt;p&gt;Requested org.apache.maven.archetypes:maven-archetype-quickstart:jar&lt;/p&gt;
&lt;p&gt;查了半天也不知道为什么，明明存在archetypes插件，却说找不到，最后决定把本地库全部都删除，然后重新创建项目，没问题了&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;神奇~&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Error: no &#39;server&#39; JVM at &#39;C:/Program Files/Java/jre6/bin/server/jvm.dll&#39;</title>
   <link href="http://jiang-bo.github.com/blog/2010/04/07/post"/>
   <updated>2010-04-07T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2010/04/07/post</id>
   <content type="html">&lt;p&gt;今天第一次使用JBoss，解压运行时出现了如下错误：&lt;/p&gt;
&lt;p&gt;Error: no 'server' JVM at 'C:/Program Files/Java/jre6/bin/server/jvm.dll'&lt;/p&gt;
&lt;p&gt;原因是JAVA_HOME设置的不对&lt;/p&gt;
&lt;p&gt;临时解决办法是重新设置下JAVA_HOME，set JAVA_HOME=&quot;C:/Program Files/Java/jdk1.6.0_19&quot;就行了，最好是在环境变量里添加一个。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Python简单CGI服务器os.execve(scriptfile,args,os.environ)权限错误</title>
   <link href="http://jiang-bo.github.com/blog/2010/01/01/post"/>
   <updated>2010-01-01T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2010/01/01/post</id>
   <content type="html">&lt;p&gt;这段时间在学Python，今天开始进入到CGI编程，示例中有个简单CGI Server的例子，代码如下：&lt;/p&gt;
&lt;p&gt;webserver.py:&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: python&quot;&gt;webdir = &amp;quot;.&amp;quot;    #html files directory
port = 8000    ＃server port
import os, sys
from BaseHTTPServer import HTTPServer
from CGIHTTPServer import CGIHTTPRequestHandler
if sys.platform[:3] == &amp;quot;win&amp;quot;:
    CGIHTTPRequestHandler.have_popen2 = False
    CGIHTTPRequestHandler.have_popen3 = False
os.chdir(webdir)
srvraddr = (&amp;quot;&amp;quot;, port)
srvrobj = HTTPServer(srvraddr, CGIHTTPRequestHandler)
srvrobj.serve_forever()&amp;nbsp;&lt;/pre&gt;
&lt;/p&gt;
&lt;p&gt;页面CGI为cgi101.py:&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: python&quot;&gt;#!/usr/bin/python
import cgi
form = cgi.FieldStorage()
print &amp;quot;Content-type: text/html/n&amp;quot;
print &amp;quot;&amp;lt;title&amp;gt;Reply Page&amp;lt;/title&amp;gt;&amp;quot;
if not form.has_key(&amp;quot;username&amp;quot;):
    print &amp;quot;&amp;lt;h1&amp;gt;Who are you?&amp;lt;/h1&amp;gt;&amp;quot;
else:
    print &amp;quot;&amp;lt;h1&amp;gt;Hello &amp;lt;i&amp;gt;%s&amp;lt;/i&amp;gt;!&amp;lt;/h1&amp;gt;&amp;quot; % cgi.escape(form['username'].value)
&lt;/pre&gt;
&lt;/p&gt;
&lt;p&gt;HTML页面为：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: xhtml&quot;&gt;&amp;lt;html&amp;gt;
    &amp;lt;title&amp;gt;Interactive Page&amp;lt;/title&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;form method=&amp;quot;post&amp;quot; action=&amp;quot;cgi-bin/cgi101.py&amp;quot;&amp;gt;
            &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Enter your name:&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;
            &amp;lt;p&amp;gt;Username:&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot;/&amp;gt;&amp;lt;/p&amp;gt;
            &amp;lt;p&amp;gt;Password:&amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;pwd&amp;quot;/&amp;gt;&amp;lt;/p&amp;gt;
            &amp;lt;input type=&amp;quot;submit&amp;quot; name=&amp;quot;submit&amp;quot; text=&amp;quot;submit&amp;quot;/&amp;gt;
        &amp;lt;/form&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;
&lt;/p&gt;
&lt;p&gt;先运行webserver.py（我是在Ubuntu上，用sudo python webserver.py)启动了server，然后在Firefox中访问：http://localhost:8000/cgi101.html&lt;/p&gt;
&lt;p&gt;结果Firefox中弹出下载cgi101.py脚本的对话框，而不是运行cgi返回结果，server终端中显示：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: python&quot;&gt;localhost - - [01/Jan/2010 17:05:32] &amp;quot;GET /cgi-bin/cgi101.py?username=Jone HTTP/1.1&amp;quot; 200 -
Traceback (most recent call last):
  File &amp;quot;/usr/lib/python2.6/CGIHTTPServer.py&amp;quot;, line 255, in run_cgi
    os.execve(scriptfile, args, os.environ)
OSError: [Errno 13] Permission denied
&lt;/pre&gt;
&lt;/p&gt;
&lt;p&gt;说明os.execve权限出问题了，解决方法如下，将cgi101.py的权限设为777，如果还是不行的话，要将整个cgi目录的权限设为777(例如，本例中使用命令chmod -R 777 cgi-bin)&lt;/p&gt;
&lt;p&gt;然后就可以了。&lt;/p&gt;
&lt;p&gt;Good Luck!&lt;/p&gt;
&lt;p&gt;PS: Happy New Year !&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>linux锐捷上网-mentohust</title>
   <link href="http://jiang-bo.github.com/blog/2009/11/24/post"/>
   <updated>2009-11-24T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/11/24/post</id>
   <content type="html">&lt;p&gt;今天终于能用linux上网了，自从换了校园网，用上那个该死的锐捷，已经告别可爱的Ubuntu很久了，差了很多资料，一直无法上，无论是锐捷官方客户端xrgsu，还是xsuppclient,或者ruijieclient，都是有错误，最后找到了一个很好用的mentohust(http://code.google.com/p/mentohust/)华科的牛人开发的锐捷客户端，更新的比较及时，很不错，赞一个，而且安装非常简单，我是Ubuntu，直接下载了deb包，安装完成后，修改/etc/mentohust.conf:&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; ;(U)用户名，长度不超过64&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Username=&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;(P)密码，长度不超过64&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Password=&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;(N)网卡&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Nic=&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;(I)静态IP用户可以使用非本机IP&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IP=&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;(G)网关，无关紧要&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Gateway=&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;(S)DNS服务器，无关紧要&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DNS=&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;(F)认证数据包，如果需要校验客户端，就需要正确设置，否则不必自找麻烦&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Package=/etc/mentohust/3_50.mpf&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;(T)每次发包超时时间（秒）&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Timeout=3&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;(E)发送Echo包的间隔（秒）&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; EchoInterval=30&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;(R)定时重连间隔（分）（如果学校支持使用私有地址认证，就可以把自动重连间隔设短一点，因为这种情况除非掉线才真正开始重连，否则建议设为0）&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; AutoReconnect=&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;(A)寻找服务器时的组播地址类型 0标准 1私有&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; StartAddress=1&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;(D)DHCP方式 0(不使用) 1(二次认证) 2(认证后) 3(认证前)&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DhcpMode=0&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ;(C)进行DHCP的脚本（可以为dhclient eth0等）&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; DhcpScript=dhclient&lt;br /&gt;
将里面的选项都配置成和你学校配置相同就可以了，具体使用请参考官方wiki(http://code.google.com/p/mentohust/wiki/FAQ)&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Android文档（三）-数据存储</title>
   <link href="http://jiang-bo.github.com/blog/2009/11/22/post"/>
   <updated>2009-11-22T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/11/22/post</id>
   <content type="html">&lt;p class=&quot;p0&quot; style=&quot;margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: 'Times New Roman';&quot;&gt;通常的&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OS&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;是采用一个文件系统来存储文件数据，是文件可以被几个文件共同访问。&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Android&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;中采用了不同的数据共享方法。在&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Android&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;中，每个应用的数据文件是私有的，&lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: 'Times New Roman';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: 'Times New Roman';&quot;&gt;也就是只有自己能够访问，但是&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Android&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;同时提供了一种机制，使得应用可以将自己的私有文件暴露给外部的其他应用程序，从而实现文件数据的共享。这种机制即&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Content&amp;nbsp;Providers&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;。&lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: 'Times New Roman';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: 'Times New Roman';&quot;&gt; &lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: 'Times New Roman';&quot;&gt;Content&amp;nbsp;Providers&lt;span style=&quot;font-family: 宋体;&quot;&gt;是一个应用的可选组件，它提供了对数据进行修改的标准接口。&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Android&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;为一些类型数据提供了&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;content&amp;nbsp;Provides&lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;，&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: 'Times New Roman';&quot;&gt;例如，&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Image&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，&amp;nbsp;&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;audio&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，&amp;nbsp;&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;video&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，以及&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;personal&amp;nbsp;contact&amp;nbsp;informations&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;。&lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: 'Times New Roman';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: 'Times New Roman';&quot;&gt; &lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: 'Times New Roman';&quot;&gt;无论如何将数据暴露给其他应用，都需要将数据存储起来。&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Android&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;提供了四种方法存储和检索数据：&lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: 'Times New Roman';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: 'Times New Roman';&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;	&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: 'Times New Roman';&quot;&gt;1.Preferences&lt;span style=&quot;font-family: 宋体;&quot;&gt;：&lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: 'Times New Roman';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: 'Times New Roman';&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;	&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: 'Times New Roman';&quot;&gt; &lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: 'Times New Roman';&quot;&gt;preferences&lt;span style=&quot;font-family: 宋体;&quot;&gt;是一种轻量级的存储机制，采用原始数据类型的&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;key-values&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;对来进行存储和检索。通常用来存储应用的&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;preferences&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，例如开机界面或者一个电话欢迎界面。通过&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Context.getSharedPreferences()&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;方法读取和写入数据。&lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;为你想要给同一个应用中的其他组件共享的数据集合起一个名字，或者通过&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Activity.getPreferences()&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;直接访问&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;preferences&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;数据集。注意：&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;preferences&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;数据不能够用在不同应用间共享。&lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;2.&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;Files&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-left: 21pt; text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt; text-align: justify;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;可以直接在设备上或者移动存储设备上存储文件，但是默认条件下，这些文件对其他应用是不可访问的。&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-left: 21pt; text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt; text-align: justify;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;可以通过调用&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Context.openFileInput()&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;方法，并向其传递文件名和路径来读取文件。返回一个标准&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Java&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;的&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;FileInputStream&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;对象。写入文件是，调用&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Context.opernFileOutput()&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，返回一个标准&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Java&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;的&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;FileOutputStream&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;对象。但是文件访问只能针对本地文件，如果调用文件操作方法去操作其他应用中的文件是不可以的。&lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-left: 21pt; text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt; text-align: justify;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;另外一种文件访问方法是，如果文件在编译时是静态的，可以通过将文件存储在&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;res/raw/myDataFile&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，调用&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Resources.openRawResources(R.raw.myDataFile)&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;方法来访问，该方法返回一个&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;InputFileStream&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;对象。&lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt; text-align: justify;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;3.&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;Databases&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-left: 21pt; text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt; text-align: justify;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;Android&amp;nbsp;API&lt;span style=&quot;font-family: 宋体;&quot;&gt;中包含了&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;SQLite&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;的&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;API&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，用于创建和使用&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;SQLite&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;数据库。每个数据库只对创建它的那个应用是开放的，对其他应用都是私有的。&lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-left: 21pt; text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt; text-align: justify;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;一个&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;SQLiteDatabase&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;对象表示一个数据库，并具有可以与之交互的方法。可以调用&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;SQLiteDatabase.create()&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;方法创建一个数据库。&lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-left: 21pt; text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt; text-align: justify;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;Android&lt;span style=&quot;font-family: 宋体;&quot;&gt;同样提供了数据库管理函数用于操作存储封装成对象的复杂数据集合。例如，&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Android&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;中定义了一个联系人信息&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;(contact&amp;nbsp;information)&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;的类型，其中包含了姓名（&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;string)&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，地址&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;(String)&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，照片&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;(bitmap)&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;的多种描述人的信息数据。&lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-left: 21pt; text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt; text-align: justify;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;所有的数据库，&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;SQLite&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;以及其它的，都被存储在设备上的&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;/data/data/package_name/databases&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;中。&lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt; text-align: justify;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;4.&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;Network&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;Android&lt;span style=&quot;font-family: 宋体;&quot;&gt;可以通过网络来检索和存储数据，当然，前提是可以联网。&lt;/span&gt;
&lt;/span&gt;
&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>IAR开发环境中添加头文件</title>
   <link href="http://jiang-bo.github.com/blog/2009/11/16/post"/>
   <updated>2009-11-16T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/11/16/post</id>
   <content type="html">&amp;nbsp;
&lt;p class=&quot;p0&quot; style=&quot;margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;今天在添加&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;uart&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;驱动时，需要向现有的&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;uC/OS&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;工程文件中添加头文件。&lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;1.&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;直接在工程目录下新建一个目录，将&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;uart.c&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;和&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;uart.h&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;添加到该目录下，&lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;2.&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;在工程项目上右键&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;-&amp;gt;add-&amp;gt;add&amp;nbsp;group&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，添加一个组&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;uC-UART&lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;3.&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;在该组上继续右键&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;-&amp;gt;add-&amp;gt;add&amp;nbsp;file&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，添加&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;uart.c&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;和&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;uart.h&lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-bottom: 0pt; margin-top: 0pt; text-align: center;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;4.&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;修改&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;includes.h&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，添加&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;#include&amp;nbsp;&amp;lt;uart.h&amp;gt;&lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;5.&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;此时直接编译会报错说无法找到&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;&amp;lt;uart.h&amp;gt;&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，还需要将上述目录添加到编译路径中，右键工程&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;-&amp;gt;option-&amp;gt;C/C++&amp;nbsp;Compiler-&amp;gt;preprocessor&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，将&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;uart.h&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;所在路径添加到&lt;/span&gt;
&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;include&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;路径中&lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: 'Times New Roman';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-bottom: 0pt; margin-top: 0pt; text-align: center;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: 'Times New Roman';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p0&quot; style=&quot;margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;6.&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: '宋体';&quot;&gt;重新编译，就没有错误了。&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: 'Times New Roman';&quot;&gt;&lt;/span&gt;
&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Android示例HelloGallery中R.styleable unresolved的解决办法</title>
   <link href="http://jiang-bo.github.com/blog/2009/11/15/post"/>
   <updated>2009-11-15T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/11/15/post</id>
   <content type="html">&lt;p&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp; 今天尝试编译Android SDK中APIDemos中的程序，调试到HelloGallery的时候，在下面这段代码中：&lt;pre class=&quot;brush: java&quot;&gt;public ImageAdapter(Context c) {
        mContext = c;
        TypedArray a = obtainStyledAttributes(android.R.styleable.Theme);
        mGalleryItemBackground = a.getResourceId(
                android.R.styleable.Theme_galleryItemBackground, 0);
        a.recycle();
    }&lt;/pre&gt;
&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 编译出错，提示说android.R.styleable unresolved，在网上查了下，说R.styleable在SDK1.5中已经不再支持，所以会出现这个错误。解决方法如下：&lt;/p&gt;
&lt;p&gt;1.在res/values目录下新建attrs.xml，在其中添加如下内容：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: xhtml&quot;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;resources&amp;gt;
	&amp;lt;declare-styleable name=&amp;quot;Gallery&amp;quot;&amp;gt;
        &amp;lt;attr name=&amp;quot;android:galleryItemBackground&amp;quot;&amp;gt;
        &amp;lt;/attr&amp;gt;
    &amp;lt;/declare-styleable&amp;gt;
&amp;lt;/resources&amp;gt;&lt;/pre&gt;
&lt;/p&gt;
&lt;p&gt;2.修改HelloGallery.java，将出错的那段代码：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: java&quot;&gt;public ImageAdapter(Context c) {
        mContext = c;
        TypedArray a = obtainStyledAttributes(android.R.styleable.Theme);
        mGalleryItemBackground = a.getResourceId(
                android.R.styleable.Theme_galleryItemBackground, 0);
        a.recycle();
    }&lt;/pre&gt;
&lt;/p&gt;
&lt;p&gt;修改为：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;brush: java&quot;&gt;public ImageAdapter(Context c) {
        	mContext = c;
            TypedArray a = obtainStyledAttributes(R.styleable.Gallery);
            mGalleryItemBackground = a.getResourceId(
                    R.styleable.Gallery_android_galleryItemBackground, 0);
            a.recycle();
        }&lt;/pre&gt;
&lt;/p&gt;
&lt;p&gt;3.重新运行就可以了&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;问题解决</title>
   <link href="http://jiang-bo.github.com/blog/2009/10/03/post"/>
   <updated>2009-10-03T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/10/03/post</id>
   <content type="html">&lt;p&gt;今天初次学习Hibernate，按照指导做的时候，出现如下错误：&lt;/p&gt; &lt;p&gt;SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.   &lt;br /&gt;SLF4J: See &lt;a href=&quot;http://www.slf4j.org/codes.html#StaticLoggerBinder&quot;&gt;http://www.slf4j.org/codes.html#StaticLoggerBinder&lt;/a&gt; for further details.    &lt;br /&gt;Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org/slf4j/impl/StaticLoggerBinder    &lt;br /&gt;    at org.slf4j.LoggerFactory.getSingleton(LoggerFactory.java:223)    &lt;br /&gt;    at org.slf4j.LoggerFactory.bind(LoggerFactory.java:120)    &lt;br /&gt;    at org.slf4j.LoggerFactory.performInitialization(LoggerFactory.java:111)    &lt;br /&gt;    at org.slf4j.LoggerFactory.getILoggerFactory(LoggerFactory.java:269)    &lt;br /&gt;    at org.slf4j.LoggerFactory.getLogger(LoggerFactory.java:242)    &lt;br /&gt;    at org.slf4j.LoggerFactory.getLogger(LoggerFactory.java:255)    &lt;br /&gt;    at org.hibernate.cfg.Configuration.&lt;clinit&gt;(Configuration.java:152)    &lt;br /&gt;    at com.jiang.hibernate.Base.main(Base.java:25)&lt;/clinit&gt;&lt;/p&gt; &lt;p&gt;问题的原因是无法找到org.slf4j.impl.StaticLoggerBinder，我找了一下，确实没有该类，网上搜了一下下面是官方的解答&lt;a title=&quot;http://www.slf4j.org/codes.html#StaticLoggerBinder&quot; href=&quot;http://www.slf4j.org/codes.html#StaticLoggerBinder&quot;&gt;http://www.slf4j.org/codes.html#StaticLoggerBinder&lt;/a&gt;：&lt;/p&gt; &lt;p&gt;This error is reported when the &lt;code&gt;org.slf4j.impl.StaticLoggerBinder&lt;/code&gt; class could not be loaded into memory. This happens when no appropriate SLF4J binding could be found on the class path. Placing one (and only one) of &lt;em&gt;slf4j-nop.jar&lt;/em&gt;, &lt;em&gt;slf4j-simple.jar&lt;/em&gt;, &lt;em&gt;slf4j-log4j12.jar&lt;/em&gt;, &lt;em&gt;slf4j-jdk14.jar&lt;/em&gt; or &lt;em&gt;logback-classic.jar&lt;/em&gt; on the class path should solve the problem. &lt;/p&gt; &lt;p&gt;You can download SLF4J bindings from the project &lt;a href=&quot;http://www.slf4j.org/download.html&quot;&gt;download page&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;大意是&lt;code&gt;org.slf4j.impl.StaticLoggerBinder&lt;/code&gt; 无法载入到内存，原因是没有找到合适的绑定SLF4J，需要添加所列举的包中的某一个。&lt;/p&gt; &lt;p&gt;解决方法如下：&lt;/p&gt; &lt;p&gt;下载slf4j-nop.jar，添加到路径中，就解决问题了&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>[转贴]提问的智慧</title>
   <link href="http://jiang-bo.github.com/blog/2009/09/24/post"/>
   <updated>2009-09-24T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/09/24/post</id>
   <content type="html">&lt;h2&gt;提问的&lt;span style=&quot;color: #ff0000;&quot;&gt;智慧&lt;/span&gt;
&lt;/h2&gt;
&lt;p align=&quot;right&quot;&gt;D.H.Grand[nOBODY/Ginux]　2001&lt;/p&gt;
&lt;p&gt;在黑客世界里，当提出一个技术问题时，你能得到怎样的回答？这取决于挖出答案的难度，同样取决于你提问的方法。本指南旨在帮助你提高发问技巧，以获取你最想要的答案。
&lt;/p&gt;
&lt;p&gt;　　首先你必须明白，黑客们只偏爱艰巨的任务，或者能激发他们思维的好问题。
如若不然，我们还来干吗？如果你有值得我们反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼，可以提高我们的理解力，而且通常会暴露我
们以前从没意识到或者思考过的问题。对黑客而言，&amp;ldquo;问得好！&amp;rdquo;是发自内心的大力称赞。
&lt;/p&gt;
&lt;p&gt;　　尽管黑客们有蔑视简单问题和不友善的坏名声，有时看起来似乎我们对新手，对知识贫乏者怀有敌意，但其实不是那样的。 &lt;/p&gt;
&lt;p&gt;　　我们不想掩饰对这样一些人的蔑视--他们不愿思考，或者在发问前不去完成他们应该做的事。这种人只会谋杀时间--他们只愿索取，从不付出，无端消耗我们的时间，而我们本可以把时间用在更有趣的问题或者更值得回答的人身上。
  我们称这样的人为&amp;ldquo;失败者&amp;rdquo;（由于历史原因，我们有时把它拼作&amp;ldquo;lusers&amp;rdquo;）。 &lt;/p&gt;
&lt;p&gt;　　我们在很大程度上属于志愿者，从繁忙的生活中抽出时间来解惑答疑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是抛弃那些看起来象失败者的家伙，以便更高效的利用时间来回答胜利者的问题。
&lt;/p&gt;
&lt;p&gt;　　如果你觉得我们过于傲慢的态度让你不爽，让你委屈，不妨设身处地想想。我们并没有要求你向我们屈服--事实上，我们中的大多数人最喜欢公平交易
不过了，只要你付出小小努力来满足最起码的要求，我们就会欢迎你加入到我们的文化中来。但让我们帮助那些不愿意帮助自己的人是没有
意义的。如果你不能接受这种&amp;ldquo;歧视&amp;rdquo;，我们建议你花点钱找家商业公司签个技术支持协议得了，别向黑客乞求帮助。 &lt;/p&gt;
&lt;p&gt;　　如果你决定向我们求助，当然不希望被视为失败者，更不愿成为失败者中的一员。立刻得到有效答案的最好方法，就是象胜利者那样提问 &amp;mdash;&amp;mdash; 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。
&lt;/p&gt;
&lt;p&gt; 　　（欢迎对本指南提出改进意见。任何建议请E-mail至&lt;a href=&quot;mailto:esr@thyrsus.com&quot;&gt;esr@thyrsus.com&lt;/a&gt;
，然而
  请注意，本文并非网络礼节的通用指南，我通常会拒绝无助于在技术论坛得到有用答案的建议。） （当然，如果你写中文，最好还是寄&lt;a href=&quot;mailto:DHGrand@hotmail.com&quot;&gt;DHGrand@hotmail.com&lt;/a&gt;
;-）
&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #009900;&quot;&gt;&lt;strong&gt;&lt;br /&gt;
  = 提问之前 = &lt;/strong&gt;
&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;　　在通过电邮、新闻组或者聊天室提出技术问题前，检查你有没有做到： &lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;1. 通读手册，试着自己找答案。 &lt;br /&gt;
      2. 在FAQ里找答案（一份维护得好的FAQ可以包罗万象:）。 &lt;br /&gt;
      3. 在网上搜索（个人推荐google~~~）。 &lt;br /&gt;
      4. 向你身边精于此道的朋友打听。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　当你提出问题的时候，首先要说明在此之前你干了些什么；这将有助于树立你的形象：你不是一个妄图不劳而获的乞讨者，不愿浪费别人的时间。如果提问者能从答案中学到东西，我们更乐于回答他的问题。
&lt;/p&gt;
&lt;p&gt;　　周全的思考，准备好你的问题，草率的发问只能得到草率的回答，或者根本得不到任何答案。越表现出在寻求帮助前为解决问题付出的努力，你越能得到实质性的帮助。
&lt;/p&gt;
&lt;p&gt;　　小心别问错了问题。如果你的问题基于错误的假设，普通黑客（J. Random Hacker）通常会用无意义的字面解释来答复你，心里想着&amp;ldquo;蠢问题...&amp;rdquo;，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。
&lt;/p&gt;
&lt;p&gt;　　决不要自以为够资格得到答案，你没这种资格。毕竟你没有为这种服务支付任何报酬。你要自己去&amp;ldquo;挣&amp;rdquo;回一个答案，靠提出一个有内涵的，有趣的，有思维激励作用的问题--一个对社区的经验有潜在贡献的问题，而不仅仅是被动的从他人处索要知识--去挣到这个答案。
&lt;/p&gt;
&lt;p&gt;　　另一方面，表明你愿意在找答案的过程中做点什么，是一个非常好的开端。&amp;ldquo;谁能给点提示？&amp;rdquo;、&amp;ldquo;我这个例子里缺了什么？&amp;rdquo;以及&amp;ldquo;我应该检查什么地方？&amp;rdquo;比&amp;ldquo;请把确切的过程贴出来&amp;rdquo;更容易得到答复。因为你显得只要有人指点正确的方向，你就有完成它的能力和决心。
&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;span style=&quot;color: #009900;&quot;&gt;&lt;strong&gt;= 怎样提问 = &lt;/strong&gt;
&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;- 谨慎选择论坛 &lt;/strong&gt;
&lt;br /&gt;
  　　小心选择提问的场合。如果象下面描述的那样，你很可能被忽略掉或者被看作失败者： &lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;1. 在风马牛不相及的论坛贴出你的问题 &lt;br /&gt;
      2. 在探讨高级技巧的论坛张贴非常初级的问题；反之亦然 &lt;br /&gt;
      3. 在太多的不同新闻组交叉张贴 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;- 用辞贴切，语法正确，拼写无误&lt;/strong&gt;
&lt;br /&gt;
  　　我们从经验中发现，粗心的写作者通常也是马虎的思考者（我敢打包票）。 回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。 &lt;/p&gt;
&lt;p&gt;　　正确的拼写，标点符号和大小写很重要。 &lt;br /&gt;
  　　更一般的说，如果你的提问写得象个半文盲，你很有可能被忽视。 &lt;/p&gt;
&lt;p&gt;　　如果你在使用非母语的论坛提问，你可以犯点拼写和语法上的小错--但决不能在思考上马虎（没错，我们能弄清两者的分别） &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;- 使用含义丰富，描述准确的标题 &lt;/strong&gt;
&lt;br /&gt;
  　　在邮件列表或者新闻组中，大约50字以内的主题标题是抓住资深专家注意力 的黄金时机。别用喋喋不休的&amp;ldquo;帮帮忙&amp;rdquo;（更别说&amp;ldquo;救命啊！！！！！&amp;rdquo;这 样让人反感的话）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，
  别用空格代替问题的描述，哪怕是极其简短的描述。 &lt;/p&gt;
&lt;p&gt;　　蠢问题： 救命啊！我的膝上机不能正常显示了！ &lt;br /&gt;
  　　聪明问题： XFree86 4.1下鼠标光标变形，Fooware MV1005的显示芯片。 &lt;/p&gt;
&lt;p&gt;　　如果你在回复中提出问题，记得要修改内容标题，表明里面有一个问题。一个看起来象&amp;ldquo;Re：测试&amp;rdquo;或者&amp;ldquo;Re：新bug&amp;rdquo;的问题很难引起足够重视。另外，引用并删减前文的内容，给新来的读者留下线索。
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;- 精确描述，信息量大&lt;/strong&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1. 谨慎明确的描述症状。 &lt;br /&gt;
    2. 提供问题发生的环境（机器配置、操作系统、应用程序以及别的什么）。 &lt;br /&gt;
    3. 说明你在提问前是怎样去研究和理解这个问题的。 &lt;br /&gt;
    4. 说明你在提问前采取了什么步骤去解决它。 &lt;br /&gt;
    5. 罗列最近做过什么可能有影响的硬件、软件变更。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　尽量想象一个黑客会怎样反问你，在提问的时候预先给他答案。 &lt;/p&gt;
&lt;p&gt;　　Simon Tatham写过一篇名为《如何有效的报告Bug》的出色短文。强力推荐你也读一读。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;- 话不在多&lt;/strong&gt;
&lt;br /&gt;
  　　你需要提供精确有效的信息。这并不是要求你简单的把成吨的出错代码或者数据完全转储摘录到你的提问中。如果你有庞大而复杂的测试条件，尽量把它剪裁得越小越好。
&lt;/p&gt;
&lt;p&gt;　　这样做的用处至少有三点。第一，表现出你为简化问题付出了努力，这可以使你得 到回答的机会增加；第二，简化问题使你得到有用答案的机会增加；第三，在提炼
  你的bug报告的过程中，也许你自己就能找出问题所在或作出更正。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;- 只说症状，不说猜想&lt;/strong&gt;
&lt;br /&gt;
  　　告诉黑客们你认为问题是怎样引起的没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，不要加进你自己的理解和推论。让黑客们来诊断吧。
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;蠢问题： 我在内核编译中一次又一次遇到SIG11错误，我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？ &lt;br /&gt;
    聪明问题： 我自制的一套K6/233系统，主板是FIC-PA2007 （VIA Apollo VP2芯片组），256MB Corsair PC133
    SDRAM，在内核编译中频频产生SIG11错误，从开机20分钟以后就有这种情况，开机 前20分钟内从没发生过。重启也没有用，但是关机一晚上就又能工作20分钟。所有
    内存都换过了，没有效果。相关部分的典型编译记录如下...。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;- 按时间顺序列出症状&lt;/strong&gt;
&lt;br /&gt;
  　　对找出问题最有帮助的线索，往往就是问题发生前的一系列操作，因此，你的说明 应该包含操作步骤，以及电脑的反应，直到问题产生。 &lt;/p&gt;
&lt;p&gt;　　如果你的说明很长（超过四个段落），在开头简述问题会有所帮助，接下来按时间顺序详述。这样黑客们就知道该在你的说明中找什么。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;- 明白你想问什么&lt;/strong&gt;
&lt;br /&gt;
  　　漫无边际的提问近乎无休无止的时间黑洞。最能给你有用答案的人也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞不太感冒，因此也可以说他们对漫无边际的提问不大感冒。
&lt;/p&gt;
&lt;p&gt;　　如果你明确表述需要回答者做什么（提供建议，发送一段代码，检查你的补丁或是别的），就最有可能得到有用的答案。这会定出一个时间和精力的上
限，便于回答者集中精力来帮你，这很凑效。要理解专家们生活的世界，要把专业技能想象为充裕的资源，而回复的时间则是贫乏的资源。解决你的问题需要的时间
越少，越能从忙碌的专家口中掏出答案。
&lt;/p&gt;
&lt;p&gt;　　因此，优化问题的结构，尽量减少专家们解决它所需要的时间，会有很大的帮助--这通常和简化问题有所区别。因此，问&amp;ldquo;我想更好的理解X，能给点
提示吗？&amp;rdquo;通常比问&amp;ldquo;你能解释一下X吗？&amp;rdquo;更好。如果你的代码不能工作，问问它有什么地方不对，比要求别人替你修改要明智得多。
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;- 别问应该自己解决的问题&lt;/strong&gt;
&lt;br /&gt;
  　　黑客们总是善于分辨哪些问题应该由你自己解决；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由你来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;- 去除无意义的疑问&lt;/strong&gt;
&lt;br /&gt;
  　　别用无意义的话结束提问，例如&amp;ldquo;有人能帮我吗？&amp;rdquo;或者&amp;ldquo;有答案吗？&amp;rdquo;。 首先：如果你对问题的描述不很合适，这样问更是画蛇添足。其次：由于这 样问是画蛇添足，黑客们会很厌烦你--而且通常会用逻辑上正确的回答来表
  示他们的蔑视，例如：&amp;ldquo;没错，有人能帮你&amp;rdquo;或者&amp;ldquo;不，没答案&amp;rdquo;。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;- 谦逊绝没有害处，而且常帮大忙&lt;/strong&gt;
&lt;br /&gt;
  彬　　彬有礼，多用&amp;ldquo;请&amp;rdquo;和&amp;ldquo;先道个谢了&amp;rdquo;。让大家都知道你对他们花费时间义务提供帮助心存感激。然而，如果你有很多问题无法解决，礼貌将会增加你得到有用答案的机会。
&lt;/p&gt;
&lt;p&gt;　　（我们注意到，自从本指南发布后，从资深黑客处得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得&amp;ldquo;先谢了&amp;rdquo;的言外之意是过后就不会再感谢任何人了。我们的建议是：都道谢。）
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;- 问题解决后，加个简短说明&lt;/strong&gt;
&lt;br /&gt;
　　问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应
该在那里贴一个补充说明。补充说明不必很长或是很深入；简单的一句&amp;ldquo;你好，原来是网线出了问题！谢谢大家--Bill&amp;rdquo;比什么也不说要强。事实上，除非结
论真的很有技术含量，否则简短可爱的小结比长篇学术论文更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。除了表示礼貌和反馈信息以外，
这种补充有助于他人在邮件列表/新闻组/论坛中搜索对你有过帮助的完整解决方案，这可能对他们也很有用。最后（至少？），这种补充有助于所有提供过帮助的
人从中得到满足感。如果你自己不是老手或者黑客，那就相信我们，这种感觉对于那些你向他们求助的导师或者专家而言，是非常重要的。问题久拖未决会让人灰
心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次贴出新问题时尝到甜头。
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;- 还是不懂&lt;/strong&gt;
&lt;br /&gt;
　　如果你不是很理解答案，别立刻要求对方解释。象你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），去理解它。如果你真的需要对方
解释，记得表现出你已经学到了点什么。比方说，如果我回答你：&amp;ldquo;看来似乎是zEntry被阻塞了；你应该先清除它。&amp;rdquo;，然后：一个很糟的后续问
题：&amp;ldquo;zEntry是什么？&amp;rdquo;
聪明的问法应该是这样：&amp;ldquo;哦~~~我看过帮助了但是只有-z和-p两个参数中提到了zEntry而且还都没有清楚的解释:&amp;lt;你是指这两个中的哪一个
吗？还是我看漏了什么？&amp;rdquo;
&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;span style=&quot;color: #009900;&quot;&gt;&lt;strong&gt;= 三思而后问 = &lt;/strong&gt;
&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;以下是几个经典蠢问题，以及黑客在拒绝回答时的心中所想： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;问题：我能在哪找到X程序？ &lt;br /&gt;
    问题：我的程序/配置/SQL申明没有用 &lt;br /&gt;
    问题：我的Windows有问题，你能帮我吗？ &lt;br /&gt;
    问题：我在安装Linux（或者X）时有问题，你能帮我吗？ &lt;br /&gt;
    问题：我怎么才能破解root帐号/窃取OP特权/读别人的邮件呢？ &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提问：我能在哪找到X程序？ &lt;br /&gt;
  回答：就在我找到它的地方啊蠢货--搜索引擎的那一头。天呐！还有人不会用Google吗？ &lt;/p&gt;
&lt;p&gt;提问：我的程序（配置、SQL申明）没有用 &lt;br /&gt;
  回答：这不算是问题吧，我对找出你的真正问题没兴趣--如果要我问你二十个问题才找得出来的话--我有更有意思的事要做呢。 &lt;/p&gt;
&lt;p&gt;在看到这类问题的时候，我的反应通常不外如下三种： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1. 你还有什么要补充的吗？ &lt;br /&gt;
    2. 真糟糕，希望你能搞定。 &lt;br /&gt;
    3. 这跟我有什么鸟相关？ &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提问：我的Windows有问题，你能帮我吗？ &lt;br /&gt;
  回答：能啊，扔掉萎软的垃圾，换Linux吧。 &lt;/p&gt;
&lt;p&gt;提问：我在安装Linux（或者X）时有问题，你能帮我吗？ &lt;br /&gt;
  回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的Linux用户组寻求手把手的指导吧（你能在这儿找到用户组的清单）。 &lt;/p&gt;
&lt;p&gt;提问：我怎么才能破解root帐号/窃取OP特权/读别人的邮件呢？ &lt;br /&gt;
  回答：想要这样做，说明你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！ &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #009900;&quot;&gt;&lt;br /&gt;
  = 好问题，坏问题 = &lt;/span&gt;
&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;　　最后，我举一些例子来说明，怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。 &lt;/p&gt;
&lt;p&gt;蠢问题：我可以在哪儿找到关于Foonly Flurbamatic的资料？ &lt;br /&gt;
  // 这种问法无非想得到&amp;ldquo;STFW&amp;rdquo;这样的回答。 &lt;/p&gt;
&lt;p&gt;聪明问题：我用Google搜索过&amp;ldquo;Foonly Flurbamatic 2600&amp;rdquo;，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？ &lt;br /&gt;
  // 这个问题已经STFW过了，看起来他真的遇到了麻烦。 &lt;/p&gt;
&lt;p&gt;蠢问题：我从FOO项目找来的源码没法编译。它怎么这么烂？ &lt;br /&gt;
  // 他觉得都是别人的错，这个傲慢自大的家伙 &lt;/p&gt;
&lt;p&gt;聪明问题：FOO项目代码在Nulix 6.2版下无法编译通过。我读过了FAQ，但里面没有提到跟Nulix有关的问题。这是我编译过程的记录，我有什么做得不对的地方吗？
  &lt;br /&gt;
  // 他讲明了环境，也读过了FAQ，还指明了错误，并且他没有把问题的责任推到别人头上，这个家伙值得留意。 &lt;/p&gt;
&lt;p&gt;蠢问题：我的主板有问题了，谁来帮我？ &lt;br /&gt;
  // 普通黑客对这类问题的回答通常是：&amp;ldquo;好的，还要帮你拍拍背和换尿布吗？&amp;rdquo; ，然后按下删除键。 &lt;/p&gt;
&lt;p&gt;聪明问题：我在S2464主板上试过了X、Y和Z，但没什么作用，我又试了A、B和C。请注意当我尝试C时的奇怪现象。显然边带传输中出现了收缩，但结果出人意料。在多处理器主板上引起边带泄漏的通常原因是什么？谁有好主意接下来我该做些什么测试才能找出问题？
  &lt;br /&gt;
  // 这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。 &lt;/p&gt;
&lt;p&gt;　　在最后一个问题中，注意&amp;ldquo;告诉我答案&amp;rdquo;和&amp;ldquo;给我启示，指出我还应该做什么诊断工作&amp;rdquo;之间微妙而又重要的区别。事实上，后一个问题源自于2001年8月在Linux内核邮件列表上的一个真实的提问。我（Eric）就是那个提出问题的人。我在Tyan
  S2464主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决那一问题的重要信息。 &lt;/p&gt;
&lt;p&gt;　　通过我的提问方法，我给了大家值得玩味的东西；我让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，邀请他们与我共同探讨。
我告诉他们我所走过的弯路，以避免他们再浪费时间，这是一种对他人时间价值的尊重。后来，当我向每个人表示感谢，并且赞赏这套程序（指邮件列表中的讨论
--译者注）运作得非常出色的时候，一个Linux内核邮件列（lkml）成员表示，问题得到解决并非由于我是这个列表中的&amp;ldquo;名人&amp;rdquo;，而是因为我用了正确
的方式来提问。我们黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我象个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者
被他们忽视。他建议我记下这件事，给编写这个指南的人一些指导。
&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;span style=&quot;color: #009900;&quot;&gt;&lt;strong&gt; = 找不到答案怎么办 = &lt;/strong&gt;
&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;　　如果仍得不到答案，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。 &lt;/p&gt;
&lt;p&gt;　　总的说来，简单的重复张贴问题是个很糟的想法。这将被视为无意义的喧闹。 &lt;/p&gt;
&lt;p&gt;　　你可以通过其它渠道获得帮助，这些渠道通常更适合初学者的需要。有许多网上的以及本地的用户组，由狂热的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。
&lt;/p&gt;
&lt;p&gt;　　另外，你可以向很多商业公司寻求帮助，不论公司大还是小（Red Hat 和LinuxCare
就是两个最常见的例子）。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了--完全可能如此--你还得把它送到修车铺，并且
为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。
&lt;/p&gt;
&lt;p&gt;　　对大众化的软件，就象Linux之类而言，每个开发者至少会有上万名用户。根本不可能由一个人来处理来自上万名用户的求助电话。要知道，即使你
要为帮助付费，同你必须购买同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开放源代码软件要高得多，且内容也不那么丰
富）。
&lt;/p&gt;
&lt;p&gt;
Copyright (C) 2001 by Eric S. Raymond &lt;br /&gt;
  中文版 Copyleft 2001 by D.H.Grand(nOBODY/Ginux) &lt;br /&gt;
  英文版：&lt;a href=&quot;http://www.tuxedo.org/%7Eesr/faqs/smart-questions.html&quot;&gt;http://www.tuxedo.org/~esr/faqs/smart-questions.html&lt;/a&gt;
&lt;br /&gt;
  感谢 Eric 的耐心指点和同意，本文才得以完成并发布， &lt;br /&gt;
  本指南 英文版版权为 Eric Steven Raymond 所有， &lt;br /&gt;
  中文版版权由 D.H.Grand[nOBODY/Ginux] 所有&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>浅谈Java垃圾收集</title>
   <link href="http://jiang-bo.github.com/blog/2009/09/23/post"/>
   <updated>2009-09-23T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/09/23/post</id>
   <content type="html">&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- [if gte mso 9]&amp;gt;&amp;lt;xml&amp;gt;
 &amp;lt;w:WordDocument&amp;gt;
  &amp;lt;w:View&amp;gt;Normal&amp;lt;/w:View&amp;gt;
  &amp;lt;w:Zoom&amp;gt;0&amp;lt;/w:Zoom&amp;gt;
  &amp;lt;w:TrackMoves /&amp;gt;
  &amp;lt;w:TrackFormatting /&amp;gt;
  &amp;lt;w:PunctuationKerning /&amp;gt;
  &amp;lt;w:DrawingGridVerticalSpacing&amp;gt;7.8 磅&amp;lt;/w:DrawingGridVerticalSpacing&amp;gt;
  &amp;lt;w:DisplayHorizontalDrawingGridEvery&amp;gt;0&amp;lt;/w:DisplayHorizontalDrawingGridEvery&amp;gt;
  &amp;lt;w:DisplayVerticalDrawingGridEvery&amp;gt;2&amp;lt;/w:DisplayVerticalDrawingGridEvery&amp;gt;
  &amp;lt;w:ValidateAgainstSchemas /&amp;gt;
  &amp;lt;w:SaveIfXMLInvalid&amp;gt;false&amp;lt;/w:SaveIfXMLInvalid&amp;gt;
  &amp;lt;w:IgnoreMixedContent&amp;gt;false&amp;lt;/w:IgnoreMixedContent&amp;gt;
  &amp;lt;w:AlwaysShowPlaceholderText&amp;gt;false&amp;lt;/w:AlwaysShowPlaceholderText&amp;gt;
  &amp;lt;w:DoNotPromoteQF /&amp;gt;
  &amp;lt;w:LidThemeOther&amp;gt;EN-US&amp;lt;/w:LidThemeOther&amp;gt;
  &amp;lt;w:LidThemeAsian&amp;gt;ZH-CN&amp;lt;/w:LidThemeAsian&amp;gt;
  &amp;lt;w:LidThemeComplexScript&amp;gt;X-NONE&amp;lt;/w:LidThemeComplexScript&amp;gt;
  &amp;lt;w:Compatibility&amp;gt;
   &amp;lt;w:SpaceForUL /&amp;gt;
   &amp;lt;w:BalanceSingleByteDoubleByteWidth /&amp;gt;
   &amp;lt;w:DoNotLeaveBackslashAlone /&amp;gt;
   &amp;lt;w:ULTrailSpace /&amp;gt;
   &amp;lt;w:DoNotExpandShiftReturn /&amp;gt;
   &amp;lt;w:AdjustLineHeightInTable /&amp;gt;
   &amp;lt;w:BreakWrappedTables /&amp;gt;
   &amp;lt;w:SnapToGridInCell /&amp;gt;
   &amp;lt;w:WrapTextWithPunct /&amp;gt;
   &amp;lt;w:UseAsianBreakRules /&amp;gt;
   &amp;lt;w:DontGrowAutofit /&amp;gt;
   &amp;lt;w:SplitPgBreakAndParaMark /&amp;gt;
   &amp;lt;w:DontVertAlignCellWithSp /&amp;gt;
   &amp;lt;w:DontBreakConstrainedForcedTables /&amp;gt;
   &amp;lt;w:DontVertAlignInTxbx /&amp;gt;
   &amp;lt;w:Word11KerningPairs /&amp;gt;
   &amp;lt;w:CachedColBalance /&amp;gt;
   &amp;lt;w:UseFELayout /&amp;gt;
  &amp;lt;/w:Compatibility&amp;gt;
  &amp;lt;w:BrowserLevel&amp;gt;MicrosoftInternetExplorer4&amp;lt;/w:BrowserLevel&amp;gt;
  &amp;lt;m:mathPr&amp;gt;
   &amp;lt;m:mathFont m:val=&quot;Cambria Math&quot; /&amp;gt;
   &amp;lt;m:brkBin m:val=&quot;before&quot; /&amp;gt;
   &amp;lt;m:brkBinSub m:val=&quot;&amp;#45;-&quot; /&amp;gt;
   &amp;lt;m:smallFrac m:val=&quot;off&quot; /&amp;gt;
   &amp;lt;m:dispDef /&amp;gt;
   &amp;lt;m:lMargin m:val=&quot;0&quot; /&amp;gt;
   &amp;lt;m:rMargin m:val=&quot;0&quot; /&amp;gt;
   &amp;lt;m:defJc m:val=&quot;centerGroup&quot; /&amp;gt;
   &amp;lt;m:wrapIndent m:val=&quot;1440&quot; /&amp;gt;
   &amp;lt;m:intLim m:val=&quot;subSup&quot; /&amp;gt;
   &amp;lt;m:naryLim m:val=&quot;undOvr&quot; /&amp;gt;
  &amp;lt;/m:mathPr&amp;gt;&amp;lt;/w:WordDocument&amp;gt;
&amp;lt;/xml&amp;gt;&amp;lt;![endif]--&gt;&lt;!-- [if gte mso 9]&amp;gt;&amp;lt;xml&amp;gt;
 &amp;lt;w:LatentStyles DefLockedState=&quot;false&quot; DefUnhideWhenUsed=&quot;true&quot;
  DefSemiHidden=&quot;true&quot; DefQFormat=&quot;false&quot; DefPriority=&quot;99&quot;
  LatentStyleCount=&quot;267&quot;&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;0&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Normal&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;heading 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 7&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 8&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 9&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 7&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 8&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 9&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;35&quot; QFormat=&quot;true&quot; Name=&quot;caption&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;10&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Title&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;1&quot; Name=&quot;Default Paragraph Font&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;11&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Subtitle&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;22&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Strong&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;20&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Emphasis&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;59&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Table Grid&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; UnhideWhenUsed=&quot;false&quot; Name=&quot;Placeholder Text&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;1&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;No Spacing&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; UnhideWhenUsed=&quot;false&quot; Name=&quot;Revision&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;34&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;List Paragraph&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;29&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Quote&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;30&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Intense Quote&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;19&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Subtle Emphasis&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;21&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Intense Emphasis&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;31&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Subtle Reference&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;32&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Intense Reference&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;33&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Book Title&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;37&quot; Name=&quot;Bibliography&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; QFormat=&quot;true&quot; Name=&quot;TOC Heading&quot; /&amp;gt;
 &amp;lt;/w:LatentStyles&amp;gt;
&amp;lt;/xml&amp;gt;&amp;lt;![endif]--&gt;
&lt;p&gt;&lt;!-- 
 /* Font Definitions */
 @font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;
	mso-font-alt:SimSun;
	mso-font-charset:134;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:3 135135232 16 0 262145 0;}
@font-face
	{font-family:&quot;Cambria Math&quot;;
	panose-1:2 4 5 3 5 4 6 3 2 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:-1610611985 1107304683 0 0 159 0;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:-1610611985 1073750139 0 0 159 0;}
@font-face
	{font-family:&quot;/@宋体&quot;;
	panose-1:2 1 6 0 3 1 1 1 1 1;
	mso-font-charset:134;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:3 135135232 16 0 262145 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-unhide:no;
	mso-style-qformat:yes;
	mso-style-parent:&quot;&quot;;
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	mso-pagination:none;
	font-size:10.5pt;
	mso-bidi-font-size:11.0pt;
	font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;
	mso-fareast-font-family:宋体;
	mso-bidi-font-family:&quot;Times New Roman&quot;;
	mso-font-kerning:1.0pt;}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{mso-style-priority:34;
	mso-style-unhide:no;
	mso-style-qformat:yes;
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:21.0pt;
	mso-char-indent-count:2.0;
	mso-pagination:none;
	font-size:10.5pt;
	mso-bidi-font-size:11.0pt;
	font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;
	mso-fareast-font-family:宋体;
	mso-bidi-font-family:&quot;Times New Roman&quot;;
	mso-font-kerning:1.0pt;}
.MsoChpDefault
	{mso-style-type:export-only;
	mso-default-props:yes;
	font-size:10.0pt;
	mso-ansi-font-size:10.0pt;
	mso-bidi-font-size:10.0pt;
	mso-ascii-font-family:Calibri;
	mso-fareast-font-family:宋体;
	mso-hansi-font-family:Calibri;
	mso-font-kerning:0pt;}
 /* Page Definitions */
 @page
	{mso-page-border-surround-header:no;
	mso-page-border-surround-footer:no;}
@page Section1
	{size:612.0pt 792.0pt;
	margin:72.0pt 90.0pt 72.0pt 90.0pt;
	mso-header-margin:36.0pt;
	mso-footer-margin:36.0pt;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 @list l0
	{mso-list-id:170995965;
	mso-list-type:hybrid;
	mso-list-template-ids:-1083421606 1103162782 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l0:level1
	{mso-level-number-format:japanese-counting;
	mso-level-text:%1．;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	margin-left:22.5pt;
	text-indent:-22.5pt;}
@list l1
	{mso-list-id:1147746093;
	mso-list-type:hybrid;
	mso-list-template-ids:901176736 -1117124388 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l1:level1
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	margin-left:39.0pt;
	text-indent:-18.0pt;}
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
--&gt;&lt;/p&gt;
&lt;!-- [if gte mso 10]&amp;gt;
&amp;lt;mce:style&amp;gt;&amp;lt;!--
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:普通表格;
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-priority:99;
	mso-style-qformat:yes;
	mso-style-parent:&quot;&quot;;
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}
--&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- [endif]--&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;尽管这是一个被大家说烂了的话题，但是，还是写一写，主要是为了理清自己的思路而已&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;~&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;内存管理是很多程序的关键因素，以前写&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;C&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;的时候，无数的&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;malloc&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;free&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，老师强调了无数遍，有一个&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;malloc&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;就应该对应一个&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;free&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，否则，内存泄漏就会像噩梦一样缠绕着你。后来写&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;C++&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，换成了&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;new&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;和&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;delete&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，最后学&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;的时候，老师讲了，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;做的比较好，不用程序员去管内存的申请和释放。因为&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;里内置了一个&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;GC&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;（&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Garbage Collector&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，垃圾收集器），他会负责所有&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;的内存管理。但是，当时不太明白&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;GC&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;的原理是什么，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;中有个&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;new&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，但是没见到有&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;delete&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;free&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，或者&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;remove&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;之类的表示释放内存的啊。后来自己研究了一下，下面是一些研究心得，有错误轻拍啊&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;~&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 22.5pt; text-indent: -22.5pt;&quot;&gt;&lt;!-- [if !supportLists]--&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;一．&lt;/span&gt;
&lt;/span&gt;
&lt;/strong&gt;
&lt;!-- [endif]--&gt;&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;什么是&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;GC&lt;/span&gt;
&lt;/strong&gt;
&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;？&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;
&lt;/strong&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 21pt;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;首先说，什么是&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;GC&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;？在这之前，先搞清楚什么是堆，什么是栈，学过编译原理的可会能比较清楚些。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 21pt;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;C&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;语言中，内存主要划分为数据段，代码段，堆，以及栈，数据段，代码段比较容易理解，数据段就是保存全局变量或常量，或者静态变量的地方，代码段顾名思义就是保存程序代码的，这两个区域在程序加载执行后是固定不变的，而内存的动态管理主要涉及堆，以及栈。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 21pt;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;栈中通常保存的是局部变量，以及函数调用，比如&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;函数中声明了一个局部变量，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;varA&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，这个变量就存在栈中，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;函数调用了&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;B&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;函数，那么，就会将&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;函数的运行状态入栈，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;B&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;函数入栈，栈顶是&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;B&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，执行&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;B&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 21pt;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;堆中保存的就是动态申请的内存，在&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;C&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;中就是通过&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;malloc&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;获得的内存区域，使用完毕后需要&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;free&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;掉，通常所说的内存管理也是管理这部分内存，因为栈中通过函数调用，变量的生存期等自动的申请释放了。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 21pt;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;上面所说的是&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;C&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;中的内存分配，那么在&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;中会是什么样呢？&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 21pt;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;中：&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 21pt;&quot;&gt;&lt;em&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;实例变量和对象驻留在堆上。&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;
&lt;/em&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 21pt;&quot;&gt;&lt;em&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;局部变量驻留在栈上。&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;
&lt;/em&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 21pt;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;这只是书上说的，但是好像还是不是很清楚，要想搞清楚，我们必须知道当我们在执行一句&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 21pt;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;AnObject anObj = new AnObject();&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 21pt;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的时候，到底发生了什么。事实上，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;anObj&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;只是一个类似于&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;C&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;中指针（注意，只是类似，不完全一样）的变量，他实际上只是一个地址值（或者其它的什么，看&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;JVM&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;了），指向&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;AnObject&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;（）在内存中的实际位置&amp;mdash;&amp;mdash;堆中的某个位置。而所谓的局部变量驻留在栈上，指的是&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;anObj&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;这个类似于指针的值是保存在栈上的。可以这么说，所有的对象都是驻留在堆上，栈中保存的只是局部变量对堆上某个对象的引用。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 21pt;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;不过有一点要注意，对象的实例变量也是保存在堆中的（不会有人不知道实例变量是什么吧）。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 21pt;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;简单的说了堆和栈，回归正题，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;GC&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;GC&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;的主要任务就是在&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;new&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;时，申请一份空间，当该对象没用时（一会说什么时候叫做&amp;ldquo;没用&amp;rdquo;）删除它，为其他对象腾地方。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 21pt;&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;GC&lt;/span&gt;
&lt;/strong&gt;
&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的工作原理：&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;
&lt;/strong&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 21pt;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;好像有一种说法，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;GC&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;使用一种叫做标记和清除的算法，对于某种&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;的实现，可能是这样，但是，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;规范中并没有规定任何特定的实现（我理解，就是说，你怎么实现都行，只要能够实现申请和释放的功能就行）。我没有更深入的研究它的实现，因为我没想过要实现一个&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;JVM&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，有兴趣的可以尝试一下。对于&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;应用开发，需要知道什么时候一个对象到达被收集的标准了（也就是&amp;ldquo;没用了&amp;rdquo;），就可以了。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 22.5pt; text-indent: -22.5pt;&quot;&gt;&lt;!-- [if !supportLists]--&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;二．&lt;/span&gt;
&lt;/span&gt;
&lt;/strong&gt;
&lt;!-- [endif]--&gt;&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;收集条件&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;
&lt;/strong&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;下面就来说一下比较重要的什么时候满足收集条件？&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;每个&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;程序都会有一到多个线程，每个线程都具有自己的线程栈。通常，在一个&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;程序中，至少会运行一个线程（也就是位于栈低的&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;main()&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;）。每个线程都有自己的生命期，（不太清楚线程的最好还是看看&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;OS&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;的书，或这比较好的&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;书对线程也有介绍）。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;收集条件就是：&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;
&lt;/span&gt;
&lt;em&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;没有任何活的线程能够访问一个对象时，该对象就符合垃圾收集条件。&lt;/span&gt;
&lt;/em&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;根据这一定义，当&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;GC&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;发现一个对象不能被任何活线程访问时，就会认为该对象符合收集条件，在某一时刻将其删除（不确定的某个时刻，一会说什么时候&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;GC&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;执行）。什么叫做一个对象被线程访问呢，就是说，该线程中有一个引用变量指向的是该对象在堆中的位置。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;这也就涉及到一个问题，一直以为&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;中不会出现内存耗尽，因为有&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;GC&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;在，不会出现内存泄漏，事实上不是这样的，内存耗尽是可能的，例如你创建并保持访问太多的对象，就会出现内存耗尽。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;
&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;可能通过上面的解释还是不能够具体的理解什么时候满足收集条件，下面举几个具体的例子：&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 39pt; text-indent: -18pt;&quot;&gt;&lt;!-- [if !supportLists]--&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;1.&lt;span style='font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal; -x-system-font: none;'&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;
&lt;/span&gt;
&lt;/span&gt;
&lt;/strong&gt;
&lt;!-- [endif]--&gt;&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;空引用&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;
&lt;/strong&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 39pt; text-indent: 0cm;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;这是最简单的一种满足收集条件的情况：&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 39pt; text-indent: 0cm;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;StringBuffer sb = new StringBuffer(&amp;ldquo;GC&amp;rdquo;);&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 39pt; text-indent: 0cm;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;//&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;其它操作&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 39pt; text-indent: 0cm;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Sb = null;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 39pt; text-indent: 0cm;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;//&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;此时如果没有其它对象引用&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;StringBuffer(&amp;ldquo;GC&amp;rdquo;)&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;（也就是没有进行过类似&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;xx=sb;&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;操作），那么&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;StringBuffer(&amp;ldquo;GC&amp;rdquo;)&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;在堆中的对象就满足收集条件。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 39pt; text-indent: -18pt;&quot;&gt;&lt;!-- [if !supportLists]--&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;2.&lt;span style='font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal; -x-system-font: none;'&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;
&lt;/span&gt;
&lt;/span&gt;
&lt;/strong&gt;
&lt;!-- [endif]--&gt;&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;重新为引用变量赋值&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;
&lt;/strong&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 39pt; text-indent: 0cm;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;StringBuffer sb = new StringBuffer(&amp;ldquo;GC&amp;rdquo;);&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 39pt; text-indent: 0cm;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;StringBuffer sbx = new StringBuffer(&amp;ldquo;Another&amp;rdquo;);&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 39pt; text-indent: 0cm;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;//&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;其它操作&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 39pt; text-indent: 0cm;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Sb = sbx;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 39pt; text-indent: 0cm;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;//&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;此时，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;sb&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;指向了&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;sbx&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;所指向的&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Another&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;对象，没有引用变量再指向&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;GC&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;对象，那么该对象也满足收集条件。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 39pt; text-indent: -18pt;&quot;&gt;&lt;!-- [if !supportLists]--&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;3.&lt;span style='font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal; -x-system-font: none;'&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/span&gt;
&lt;/span&gt;
&lt;/span&gt;
&lt;/strong&gt;
&lt;!-- [endif]--&gt;&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;隔离引用&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;
&lt;/strong&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 39pt; text-indent: 0cm;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;这一条可能是比较难理解的，简单说，就是尽管某个对象被其他人引用，但是引用者也在堆上，没有堆外的引用，那么引用者与被引用者都满足收集条件。&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: 宋体;&quot;&gt;上面说过，对象的实例变量也保存在堆上，如果某个对象&lt;/span&gt;
&lt;span style='font-size: 10.5pt; font-family: &quot;Calibri&quot;,&quot;sans-serif&quot;;' lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: 宋体;&quot;&gt;的实例变量&lt;/span&gt;
&lt;span style='font-size: 10.5pt; font-family: &quot;Calibri&quot;,&quot;sans-serif&quot;;' lang=&quot;EN-US&quot;&gt;i&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: 宋体;&quot;&gt;引用另外一个对象&lt;/span&gt;
&lt;span style='font-size: 10.5pt; font-family: &quot;Calibri&quot;,&quot;sans-serif&quot;;' lang=&quot;EN-US&quot;&gt;B&lt;/span&gt;
&lt;span style=&quot;font-size: 10.5pt; font-family: 宋体;&quot;&gt;，但是除此之外没有其他人引用他们中的任何一个，那么他们两个都符合收集条件。示例如下：&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 10.5pt; font-family: 宋体;&quot;&gt;&lt;pre class=&quot;brush: java&quot;&gt;public class A  
{
	A i;
	public static void main(String[] args) 
	{
		A  a1 = new A();
		A  a2 = new A();
		A  a3 = new A();
		a1.i = a2;
		a2.i = a3;
		a3.i = a1;
		a1 = null;
		a2 = null;
		a3 = null;
		//此时尽管有对堆上对象的引用，但是引用者也在堆上
	}
}
&lt;/pre&gt;
&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;&lt;!-- [if gte mso 9]&amp;gt;&amp;lt;xml&amp;gt;
 &amp;lt;w:WordDocument&amp;gt;
  &amp;lt;w:View&amp;gt;Normal&amp;lt;/w:View&amp;gt;
  &amp;lt;w:Zoom&amp;gt;0&amp;lt;/w:Zoom&amp;gt;
  &amp;lt;w:TrackMoves /&amp;gt;
  &amp;lt;w:TrackFormatting /&amp;gt;
  &amp;lt;w:PunctuationKerning /&amp;gt;
  &amp;lt;w:DrawingGridVerticalSpacing&amp;gt;7.8 磅&amp;lt;/w:DrawingGridVerticalSpacing&amp;gt;
  &amp;lt;w:DisplayHorizontalDrawingGridEvery&amp;gt;0&amp;lt;/w:DisplayHorizontalDrawingGridEvery&amp;gt;
  &amp;lt;w:DisplayVerticalDrawingGridEvery&amp;gt;2&amp;lt;/w:DisplayVerticalDrawingGridEvery&amp;gt;
  &amp;lt;w:ValidateAgainstSchemas /&amp;gt;
  &amp;lt;w:SaveIfXMLInvalid&amp;gt;false&amp;lt;/w:SaveIfXMLInvalid&amp;gt;
  &amp;lt;w:IgnoreMixedContent&amp;gt;false&amp;lt;/w:IgnoreMixedContent&amp;gt;
  &amp;lt;w:AlwaysShowPlaceholderText&amp;gt;false&amp;lt;/w:AlwaysShowPlaceholderText&amp;gt;
  &amp;lt;w:DoNotPromoteQF /&amp;gt;
  &amp;lt;w:LidThemeOther&amp;gt;EN-US&amp;lt;/w:LidThemeOther&amp;gt;
  &amp;lt;w:LidThemeAsian&amp;gt;ZH-CN&amp;lt;/w:LidThemeAsian&amp;gt;
  &amp;lt;w:LidThemeComplexScript&amp;gt;X-NONE&amp;lt;/w:LidThemeComplexScript&amp;gt;
  &amp;lt;w:Compatibility&amp;gt;
   &amp;lt;w:SpaceForUL /&amp;gt;
   &amp;lt;w:BalanceSingleByteDoubleByteWidth /&amp;gt;
   &amp;lt;w:DoNotLeaveBackslashAlone /&amp;gt;
   &amp;lt;w:ULTrailSpace /&amp;gt;
   &amp;lt;w:DoNotExpandShiftReturn /&amp;gt;
   &amp;lt;w:AdjustLineHeightInTable /&amp;gt;
   &amp;lt;w:BreakWrappedTables /&amp;gt;
   &amp;lt;w:SnapToGridInCell /&amp;gt;
   &amp;lt;w:WrapTextWithPunct /&amp;gt;
   &amp;lt;w:UseAsianBreakRules /&amp;gt;
   &amp;lt;w:DontGrowAutofit /&amp;gt;
   &amp;lt;w:SplitPgBreakAndParaMark /&amp;gt;
   &amp;lt;w:DontVertAlignCellWithSp /&amp;gt;
   &amp;lt;w:DontBreakConstrainedForcedTables /&amp;gt;
   &amp;lt;w:DontVertAlignInTxbx /&amp;gt;
   &amp;lt;w:Word11KerningPairs /&amp;gt;
   &amp;lt;w:CachedColBalance /&amp;gt;
   &amp;lt;w:UseFELayout /&amp;gt;
  &amp;lt;/w:Compatibility&amp;gt;
  &amp;lt;w:BrowserLevel&amp;gt;MicrosoftInternetExplorer4&amp;lt;/w:BrowserLevel&amp;gt;
  &amp;lt;m:mathPr&amp;gt;
   &amp;lt;m:mathFont m:val=&quot;Cambria Math&quot; /&amp;gt;
   &amp;lt;m:brkBin m:val=&quot;before&quot; /&amp;gt;
   &amp;lt;m:brkBinSub m:val=&quot;&amp;#45;-&quot; /&amp;gt;
   &amp;lt;m:smallFrac m:val=&quot;off&quot; /&amp;gt;
   &amp;lt;m:dispDef /&amp;gt;
   &amp;lt;m:lMargin m:val=&quot;0&quot; /&amp;gt;
   &amp;lt;m:rMargin m:val=&quot;0&quot; /&amp;gt;
   &amp;lt;m:defJc m:val=&quot;centerGroup&quot; /&amp;gt;
   &amp;lt;m:wrapIndent m:val=&quot;1440&quot; /&amp;gt;
   &amp;lt;m:intLim m:val=&quot;subSup&quot; /&amp;gt;
   &amp;lt;m:naryLim m:val=&quot;undOvr&quot; /&amp;gt;
  &amp;lt;/m:mathPr&amp;gt;&amp;lt;/w:WordDocument&amp;gt;
&amp;lt;/xml&amp;gt;&amp;lt;![endif]--&gt;&lt;!-- [if gte mso 9]&amp;gt;&amp;lt;xml&amp;gt;
 &amp;lt;w:LatentStyles DefLockedState=&quot;false&quot; DefUnhideWhenUsed=&quot;true&quot;
  DefSemiHidden=&quot;true&quot; DefQFormat=&quot;false&quot; DefPriority=&quot;99&quot;
  LatentStyleCount=&quot;267&quot;&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;0&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Normal&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;heading 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 7&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 8&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 9&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 7&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 8&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 9&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;35&quot; QFormat=&quot;true&quot; Name=&quot;caption&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;10&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Title&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;1&quot; Name=&quot;Default Paragraph Font&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;11&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Subtitle&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;22&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Strong&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;20&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Emphasis&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;59&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Table Grid&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; UnhideWhenUsed=&quot;false&quot; Name=&quot;Placeholder Text&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;1&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;No Spacing&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; UnhideWhenUsed=&quot;false&quot; Name=&quot;Revision&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;34&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;List Paragraph&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;29&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Quote&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;30&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Intense Quote&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;19&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Subtle Emphasis&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;21&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Intense Emphasis&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;31&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Subtle Reference&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;32&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Intense Reference&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;33&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Book Title&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;37&quot; Name=&quot;Bibliography&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; QFormat=&quot;true&quot; Name=&quot;TOC Heading&quot; /&amp;gt;
 &amp;lt;/w:LatentStyles&amp;gt;
&amp;lt;/xml&amp;gt;&amp;lt;![endif]--&gt;&lt;!-- 
 /* Font Definitions */
 @font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;
	mso-font-alt:SimSun;
	mso-font-charset:134;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:3 135135232 16 0 262145 0;}
@font-face
	{font-family:&quot;Cambria Math&quot;;
	panose-1:2 4 5 3 5 4 6 3 2 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:-1610611985 1107304683 0 0 159 0;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:-1610611985 1073750139 0 0 159 0;}
@font-face
	{font-family:&quot;/@宋体&quot;;
	panose-1:2 1 6 0 3 1 1 1 1 1;
	mso-font-charset:134;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:3 135135232 16 0 262145 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-unhide:no;
	mso-style-qformat:yes;
	mso-style-parent:&quot;&quot;;
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	mso-pagination:none;
	font-size:10.5pt;
	mso-bidi-font-size:11.0pt;
	font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;
	mso-fareast-font-family:宋体;
	mso-bidi-font-family:&quot;Times New Roman&quot;;
	mso-font-kerning:1.0pt;}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{mso-style-priority:34;
	mso-style-unhide:no;
	mso-style-qformat:yes;
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:21.0pt;
	mso-char-indent-count:2.0;
	mso-pagination:none;
	font-size:10.5pt;
	mso-bidi-font-size:11.0pt;
	font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;
	mso-fareast-font-family:宋体;
	mso-bidi-font-family:&quot;Times New Roman&quot;;
	mso-font-kerning:1.0pt;}
.MsoChpDefault
	{mso-style-type:export-only;
	mso-default-props:yes;
	font-size:10.0pt;
	mso-ansi-font-size:10.0pt;
	mso-bidi-font-size:10.0pt;
	mso-ascii-font-family:Calibri;
	mso-fareast-font-family:宋体;
	mso-hansi-font-family:Calibri;
	mso-font-kerning:0pt;}
 /* Page Definitions */
 @page
	{mso-page-border-surround-header:no;
	mso-page-border-surround-footer:no;}
@page Section1
	{size:612.0pt 792.0pt;
	margin:72.0pt 90.0pt 72.0pt 90.0pt;
	mso-header-margin:36.0pt;
	mso-footer-margin:36.0pt;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 @list l0
	{mso-list-id:170995965;
	mso-list-type:hybrid;
	mso-list-template-ids:-1083421606 1103162782 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l0:level1
	{mso-level-number-format:japanese-counting;
	mso-level-text:%1．;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	margin-left:22.5pt;
	text-indent:-22.5pt;}
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
--&gt;&lt;!-- [if gte mso 10]&amp;gt;
&amp;lt;mce:style&amp;gt;&amp;lt;!--
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:普通表格;
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-priority:99;
	mso-style-qformat:yes;
	mso-style-parent:&quot;&quot;;
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}
--&gt;
&lt;!-- [endif]--&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 22.5pt; text-indent: -22.5pt;&quot;&gt;&lt;!-- [if !supportLists]--&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;三．&lt;/span&gt;
&lt;/span&gt;
&lt;/strong&gt;
&lt;!-- [endif]--&gt;&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;什么时候执行&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;GC&lt;/span&gt;
&lt;/strong&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 22.5pt; text-indent: 0cm;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;下面来说一下什么时候&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;GC&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;会执行？&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 22.5pt; text-indent: 0cm;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;GC&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;受&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;JVM&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;控制，由&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;JVM&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;决定什么时候运行&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;GC&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;。但是&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;规范并没有规定什么时侯执行&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;GC&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，尽管我们可以请求执行&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;GC&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，但是只是提建议，最终执行与否，完全看&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;JVM&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，人家心情好，说不定会立即相应你，心情不好时，那你就等着吧。因此，绝对不能依赖于&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;JVM&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;请求&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;GC&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;来完成某种行为。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 22.5pt; text-indent: 0cm;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;下面写个简单的请求&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;GC&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;的例子：&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 22.5pt; text-indent: 0cm;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;&lt;pre class=&quot;brush: java&quot;&gt;public static void main(String[] args) {
		// TODO Auto-generated method stub
		Runtime rt = Runtime.getRuntime();//获得Runtime
		System.out.println(rt.totalMemory());//全部内存
		System.out.println(rt.freeMemory());//空余内存
		Date[] sa = new Date[100000];
		for(int i=0; i&amp;lt;100000; i++){
			sa[i] = new Date();
		}
		System.out.println(rt.freeMemory());
		for(int i=0; i&amp;lt;100000; i++){
			sa[i] = null;
		}
		sa = null;
		System.out.println(rt.freeMemory());
		System.gc();//请求GC
		System.out.println(rt.freeMemory());
	}
&lt;/pre&gt;
&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 22.5pt; text-indent: 0cm;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 22.5pt; text-indent: 0cm;&quot;&gt;&lt;!-- [if gte mso 9]&amp;gt;&amp;lt;xml&amp;gt;
 &amp;lt;w:WordDocument&amp;gt;
  &amp;lt;w:View&amp;gt;Normal&amp;lt;/w:View&amp;gt;
  &amp;lt;w:Zoom&amp;gt;0&amp;lt;/w:Zoom&amp;gt;
  &amp;lt;w:TrackMoves /&amp;gt;
  &amp;lt;w:TrackFormatting /&amp;gt;
  &amp;lt;w:PunctuationKerning /&amp;gt;
  &amp;lt;w:DrawingGridVerticalSpacing&amp;gt;7.8 磅&amp;lt;/w:DrawingGridVerticalSpacing&amp;gt;
  &amp;lt;w:DisplayHorizontalDrawingGridEvery&amp;gt;0&amp;lt;/w:DisplayHorizontalDrawingGridEvery&amp;gt;
  &amp;lt;w:DisplayVerticalDrawingGridEvery&amp;gt;2&amp;lt;/w:DisplayVerticalDrawingGridEvery&amp;gt;
  &amp;lt;w:ValidateAgainstSchemas /&amp;gt;
  &amp;lt;w:SaveIfXMLInvalid&amp;gt;false&amp;lt;/w:SaveIfXMLInvalid&amp;gt;
  &amp;lt;w:IgnoreMixedContent&amp;gt;false&amp;lt;/w:IgnoreMixedContent&amp;gt;
  &amp;lt;w:AlwaysShowPlaceholderText&amp;gt;false&amp;lt;/w:AlwaysShowPlaceholderText&amp;gt;
  &amp;lt;w:DoNotPromoteQF /&amp;gt;
  &amp;lt;w:LidThemeOther&amp;gt;EN-US&amp;lt;/w:LidThemeOther&amp;gt;
  &amp;lt;w:LidThemeAsian&amp;gt;ZH-CN&amp;lt;/w:LidThemeAsian&amp;gt;
  &amp;lt;w:LidThemeComplexScript&amp;gt;X-NONE&amp;lt;/w:LidThemeComplexScript&amp;gt;
  &amp;lt;w:Compatibility&amp;gt;
   &amp;lt;w:SpaceForUL /&amp;gt;
   &amp;lt;w:BalanceSingleByteDoubleByteWidth /&amp;gt;
   &amp;lt;w:DoNotLeaveBackslashAlone /&amp;gt;
   &amp;lt;w:ULTrailSpace /&amp;gt;
   &amp;lt;w:DoNotExpandShiftReturn /&amp;gt;
   &amp;lt;w:AdjustLineHeightInTable /&amp;gt;
   &amp;lt;w:BreakWrappedTables /&amp;gt;
   &amp;lt;w:SnapToGridInCell /&amp;gt;
   &amp;lt;w:WrapTextWithPunct /&amp;gt;
   &amp;lt;w:UseAsianBreakRules /&amp;gt;
   &amp;lt;w:DontGrowAutofit /&amp;gt;
   &amp;lt;w:SplitPgBreakAndParaMark /&amp;gt;
   &amp;lt;w:DontVertAlignCellWithSp /&amp;gt;
   &amp;lt;w:DontBreakConstrainedForcedTables /&amp;gt;
   &amp;lt;w:DontVertAlignInTxbx /&amp;gt;
   &amp;lt;w:Word11KerningPairs /&amp;gt;
   &amp;lt;w:CachedColBalance /&amp;gt;
   &amp;lt;w:UseFELayout /&amp;gt;
  &amp;lt;/w:Compatibility&amp;gt;
  &amp;lt;w:BrowserLevel&amp;gt;MicrosoftInternetExplorer4&amp;lt;/w:BrowserLevel&amp;gt;
  &amp;lt;m:mathPr&amp;gt;
   &amp;lt;m:mathFont m:val=&quot;Cambria Math&quot; /&amp;gt;
   &amp;lt;m:brkBin m:val=&quot;before&quot; /&amp;gt;
   &amp;lt;m:brkBinSub m:val=&quot;&amp;#45;-&quot; /&amp;gt;
   &amp;lt;m:smallFrac m:val=&quot;off&quot; /&amp;gt;
   &amp;lt;m:dispDef /&amp;gt;
   &amp;lt;m:lMargin m:val=&quot;0&quot; /&amp;gt;
   &amp;lt;m:rMargin m:val=&quot;0&quot; /&amp;gt;
   &amp;lt;m:defJc m:val=&quot;centerGroup&quot; /&amp;gt;
   &amp;lt;m:wrapIndent m:val=&quot;1440&quot; /&amp;gt;
   &amp;lt;m:intLim m:val=&quot;subSup&quot; /&amp;gt;
   &amp;lt;m:naryLim m:val=&quot;undOvr&quot; /&amp;gt;
  &amp;lt;/m:mathPr&amp;gt;&amp;lt;/w:WordDocument&amp;gt;
&amp;lt;/xml&amp;gt;&amp;lt;![endif]--&gt;&lt;!-- [if gte mso 9]&amp;gt;&amp;lt;xml&amp;gt;
 &amp;lt;w:LatentStyles DefLockedState=&quot;false&quot; DefUnhideWhenUsed=&quot;true&quot;
  DefSemiHidden=&quot;true&quot; DefQFormat=&quot;false&quot; DefPriority=&quot;99&quot;
  LatentStyleCount=&quot;267&quot;&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;0&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Normal&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;heading 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 7&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 8&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 9&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 7&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 8&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 9&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;35&quot; QFormat=&quot;true&quot; Name=&quot;caption&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;10&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Title&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;1&quot; Name=&quot;Default Paragraph Font&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;11&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Subtitle&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;22&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Strong&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;20&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Emphasis&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;59&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Table Grid&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; UnhideWhenUsed=&quot;false&quot; Name=&quot;Placeholder Text&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;1&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;No Spacing&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; UnhideWhenUsed=&quot;false&quot; Name=&quot;Revision&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;34&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;List Paragraph&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;29&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Quote&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;30&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Intense Quote&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;19&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Subtle Emphasis&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;21&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Intense Emphasis&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;31&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Subtle Reference&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;32&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Intense Reference&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;33&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Book Title&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;37&quot; Name=&quot;Bibliography&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; QFormat=&quot;true&quot; Name=&quot;TOC Heading&quot; /&amp;gt;
 &amp;lt;/w:LatentStyles&amp;gt;
&amp;lt;/xml&amp;gt;&amp;lt;![endif]--&gt;&lt;!-- 
 /* Font Definitions */
 @font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;
	mso-font-alt:SimSun;
	mso-font-charset:134;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:3 135135232 16 0 262145 0;}
@font-face
	{font-family:&quot;Cambria Math&quot;;
	panose-1:2 4 5 3 5 4 6 3 2 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:-1610611985 1107304683 0 0 159 0;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:-1610611985 1073750139 0 0 159 0;}
@font-face
	{font-family:&quot;/@宋体&quot;;
	panose-1:2 1 6 0 3 1 1 1 1 1;
	mso-font-charset:134;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:3 135135232 16 0 262145 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-unhide:no;
	mso-style-qformat:yes;
	mso-style-parent:&quot;&quot;;
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	mso-pagination:none;
	font-size:10.5pt;
	mso-bidi-font-size:11.0pt;
	font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;
	mso-fareast-font-family:宋体;
	mso-bidi-font-family:&quot;Times New Roman&quot;;
	mso-font-kerning:1.0pt;}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{mso-style-priority:34;
	mso-style-unhide:no;
	mso-style-qformat:yes;
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:21.0pt;
	mso-char-indent-count:2.0;
	mso-pagination:none;
	font-size:10.5pt;
	mso-bidi-font-size:11.0pt;
	font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;
	mso-fareast-font-family:宋体;
	mso-bidi-font-family:&quot;Times New Roman&quot;;
	mso-font-kerning:1.0pt;}
.MsoChpDefault
	{mso-style-type:export-only;
	mso-default-props:yes;
	font-size:10.0pt;
	mso-ansi-font-size:10.0pt;
	mso-bidi-font-size:10.0pt;
	mso-ascii-font-family:Calibri;
	mso-fareast-font-family:宋体;
	mso-hansi-font-family:Calibri;
	mso-font-kerning:0pt;}
 /* Page Definitions */
 @page
	{mso-page-border-surround-header:no;
	mso-page-border-surround-footer:no;}
@page Section1
	{size:612.0pt 792.0pt;
	margin:72.0pt 90.0pt 72.0pt 90.0pt;
	mso-header-margin:36.0pt;
	mso-footer-margin:36.0pt;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
--&gt;&lt;!-- [if gte mso 10]&amp;gt;
&amp;lt;mce:style&amp;gt;&amp;lt;!--
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:普通表格;
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-priority:99;
	mso-style-qformat:yes;
	mso-style-parent:&quot;&quot;;
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}
--&gt;
&lt;!-- [endif]--&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;该程序的输出结果为：&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 22.5pt; text-indent: 0cm;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;&lt;pre class=&quot;brush: java&quot;&gt;5177344
4935344
2221696
2221696
5033840
&lt;/pre&gt;
&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 22.5pt; text-indent: 0cm;&quot;&gt;&lt;!-- [if gte mso 9]&amp;gt;&amp;lt;xml&amp;gt;
 &amp;lt;w:WordDocument&amp;gt;
  &amp;lt;w:View&amp;gt;Normal&amp;lt;/w:View&amp;gt;
  &amp;lt;w:Zoom&amp;gt;0&amp;lt;/w:Zoom&amp;gt;
  &amp;lt;w:TrackMoves /&amp;gt;
  &amp;lt;w:TrackFormatting /&amp;gt;
  &amp;lt;w:PunctuationKerning /&amp;gt;
  &amp;lt;w:DrawingGridVerticalSpacing&amp;gt;7.8 磅&amp;lt;/w:DrawingGridVerticalSpacing&amp;gt;
  &amp;lt;w:DisplayHorizontalDrawingGridEvery&amp;gt;0&amp;lt;/w:DisplayHorizontalDrawingGridEvery&amp;gt;
  &amp;lt;w:DisplayVerticalDrawingGridEvery&amp;gt;2&amp;lt;/w:DisplayVerticalDrawingGridEvery&amp;gt;
  &amp;lt;w:ValidateAgainstSchemas /&amp;gt;
  &amp;lt;w:SaveIfXMLInvalid&amp;gt;false&amp;lt;/w:SaveIfXMLInvalid&amp;gt;
  &amp;lt;w:IgnoreMixedContent&amp;gt;false&amp;lt;/w:IgnoreMixedContent&amp;gt;
  &amp;lt;w:AlwaysShowPlaceholderText&amp;gt;false&amp;lt;/w:AlwaysShowPlaceholderText&amp;gt;
  &amp;lt;w:DoNotPromoteQF /&amp;gt;
  &amp;lt;w:LidThemeOther&amp;gt;EN-US&amp;lt;/w:LidThemeOther&amp;gt;
  &amp;lt;w:LidThemeAsian&amp;gt;ZH-CN&amp;lt;/w:LidThemeAsian&amp;gt;
  &amp;lt;w:LidThemeComplexScript&amp;gt;X-NONE&amp;lt;/w:LidThemeComplexScript&amp;gt;
  &amp;lt;w:Compatibility&amp;gt;
   &amp;lt;w:SpaceForUL /&amp;gt;
   &amp;lt;w:BalanceSingleByteDoubleByteWidth /&amp;gt;
   &amp;lt;w:DoNotLeaveBackslashAlone /&amp;gt;
   &amp;lt;w:ULTrailSpace /&amp;gt;
   &amp;lt;w:DoNotExpandShiftReturn /&amp;gt;
   &amp;lt;w:AdjustLineHeightInTable /&amp;gt;
   &amp;lt;w:BreakWrappedTables /&amp;gt;
   &amp;lt;w:SnapToGridInCell /&amp;gt;
   &amp;lt;w:WrapTextWithPunct /&amp;gt;
   &amp;lt;w:UseAsianBreakRules /&amp;gt;
   &amp;lt;w:DontGrowAutofit /&amp;gt;
   &amp;lt;w:SplitPgBreakAndParaMark /&amp;gt;
   &amp;lt;w:DontVertAlignCellWithSp /&amp;gt;
   &amp;lt;w:DontBreakConstrainedForcedTables /&amp;gt;
   &amp;lt;w:DontVertAlignInTxbx /&amp;gt;
   &amp;lt;w:Word11KerningPairs /&amp;gt;
   &amp;lt;w:CachedColBalance /&amp;gt;
   &amp;lt;w:UseFELayout /&amp;gt;
  &amp;lt;/w:Compatibility&amp;gt;
  &amp;lt;w:BrowserLevel&amp;gt;MicrosoftInternetExplorer4&amp;lt;/w:BrowserLevel&amp;gt;
  &amp;lt;m:mathPr&amp;gt;
   &amp;lt;m:mathFont m:val=&quot;Cambria Math&quot; /&amp;gt;
   &amp;lt;m:brkBin m:val=&quot;before&quot; /&amp;gt;
   &amp;lt;m:brkBinSub m:val=&quot;&amp;#45;-&quot; /&amp;gt;
   &amp;lt;m:smallFrac m:val=&quot;off&quot; /&amp;gt;
   &amp;lt;m:dispDef /&amp;gt;
   &amp;lt;m:lMargin m:val=&quot;0&quot; /&amp;gt;
   &amp;lt;m:rMargin m:val=&quot;0&quot; /&amp;gt;
   &amp;lt;m:defJc m:val=&quot;centerGroup&quot; /&amp;gt;
   &amp;lt;m:wrapIndent m:val=&quot;1440&quot; /&amp;gt;
   &amp;lt;m:intLim m:val=&quot;subSup&quot; /&amp;gt;
   &amp;lt;m:naryLim m:val=&quot;undOvr&quot; /&amp;gt;
  &amp;lt;/m:mathPr&amp;gt;&amp;lt;/w:WordDocument&amp;gt;
&amp;lt;/xml&amp;gt;&amp;lt;![endif]--&gt;&lt;!-- [if gte mso 9]&amp;gt;&amp;lt;xml&amp;gt;
 &amp;lt;w:LatentStyles DefLockedState=&quot;false&quot; DefUnhideWhenUsed=&quot;true&quot;
  DefSemiHidden=&quot;true&quot; DefQFormat=&quot;false&quot; DefPriority=&quot;99&quot;
  LatentStyleCount=&quot;267&quot;&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;0&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Normal&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;heading 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 7&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 8&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;9&quot; QFormat=&quot;true&quot; Name=&quot;heading 9&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 7&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 8&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; Name=&quot;toc 9&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;35&quot; QFormat=&quot;true&quot; Name=&quot;caption&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;10&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Title&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;1&quot; Name=&quot;Default Paragraph Font&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;11&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Subtitle&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;22&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Strong&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;20&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Emphasis&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;59&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Table Grid&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; UnhideWhenUsed=&quot;false&quot; Name=&quot;Placeholder Text&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;1&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;No Spacing&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; UnhideWhenUsed=&quot;false&quot; Name=&quot;Revision&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;34&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;List Paragraph&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;29&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Quote&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;30&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Intense Quote&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 1&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 2&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 3&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 4&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 5&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;60&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Shading Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;61&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light List Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;62&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Light Grid Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;63&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 1 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;64&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Shading 2 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;65&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 1 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;66&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium List 2 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;67&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 1 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;68&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 2 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;69&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Medium Grid 3 Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;70&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Dark List Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;71&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Shading Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;72&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful List Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;73&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; Name=&quot;Colorful Grid Accent 6&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;19&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Subtle Emphasis&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;21&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Intense Emphasis&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;31&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Subtle Reference&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;32&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Intense Reference&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;33&quot; SemiHidden=&quot;false&quot;
   UnhideWhenUsed=&quot;false&quot; QFormat=&quot;true&quot; Name=&quot;Book Title&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;37&quot; Name=&quot;Bibliography&quot; /&amp;gt;
  &amp;lt;w:LsdException Locked=&quot;false&quot; Priority=&quot;39&quot; QFormat=&quot;true&quot; Name=&quot;TOC Heading&quot; /&amp;gt;
 &amp;lt;/w:LatentStyles&amp;gt;
&amp;lt;/xml&amp;gt;&amp;lt;![endif]--&gt;&lt;!-- 
 /* Font Definitions */
 @font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;
	mso-font-alt:SimSun;
	mso-font-charset:134;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:3 135135232 16 0 262145 0;}
@font-face
	{font-family:&quot;Cambria Math&quot;;
	panose-1:2 4 5 3 5 4 6 3 2 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:-1610611985 1107304683 0 0 159 0;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:-1610611985 1073750139 0 0 159 0;}
@font-face
	{font-family:&quot;/@宋体&quot;;
	panose-1:2 1 6 0 3 1 1 1 1 1;
	mso-font-charset:134;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:3 135135232 16 0 262145 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-unhide:no;
	mso-style-qformat:yes;
	mso-style-parent:&quot;&quot;;
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	mso-pagination:none;
	font-size:10.5pt;
	mso-bidi-font-size:11.0pt;
	font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;
	mso-fareast-font-family:宋体;
	mso-bidi-font-family:&quot;Times New Roman&quot;;
	mso-font-kerning:1.0pt;}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{mso-style-priority:34;
	mso-style-unhide:no;
	mso-style-qformat:yes;
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:21.0pt;
	mso-char-indent-count:2.0;
	mso-pagination:none;
	font-size:10.5pt;
	mso-bidi-font-size:11.0pt;
	font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;
	mso-fareast-font-family:宋体;
	mso-bidi-font-family:&quot;Times New Roman&quot;;
	mso-font-kerning:1.0pt;}
.MsoChpDefault
	{mso-style-type:export-only;
	mso-default-props:yes;
	font-size:10.0pt;
	mso-ansi-font-size:10.0pt;
	mso-bidi-font-size:10.0pt;
	mso-ascii-font-family:Calibri;
	mso-fareast-font-family:宋体;
	mso-hansi-font-family:Calibri;
	mso-font-kerning:0pt;}
 /* Page Definitions */
 @page
	{mso-page-border-surround-header:no;
	mso-page-border-surround-footer:no;}
@page Section1
	{size:595.3pt 841.9pt;
	margin:72.0pt 90.0pt 72.0pt 90.0pt;
	mso-header-margin:42.55pt;
	mso-footer-margin:49.6pt;
	mso-paper-source:0;
	layout-grid:15.6pt;}
div.Section1
	{page:Section1;}
--&gt;&lt;!-- [if gte mso 10]&amp;gt;
&amp;lt;mce:style&amp;gt;&amp;lt;!--
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:普通表格;
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-priority:99;
	mso-style-qformat:yes;
	mso-style-parent:&quot;&quot;;
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}
--&gt;
&lt;!-- [endif]--&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 22.5pt; text-indent: 0cm;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;尽管这里显示的是&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;JVM&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;确实响应了请求，但是，再次强调，这是没有保证的。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 22.5pt; text-indent: 0cm;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;nbsp;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; style=&quot;margin-left: 22.5pt; text-indent: 0cm;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;OK&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，就这些，继续努力&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;~&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>设计模式学习笔记（2）——装饰模式(Decorator Pattern)</title>
   <link href="http://jiang-bo.github.com/blog/2009/09/20/decorator-pattern"/>
   <updated>2009-09-20T16:48:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/09/20/decorator-pattern</id>
   <content type="html">&lt;h3&gt;一．目的&lt;/h3&gt;

&lt;p&gt;装饰模式的目的是动态的为对象添加一些额外职责。就增加功能来说， Decorator 模式比继承产生的子类给为灵活。 ——GoF《Design Pattern》。&lt;/p&gt;

&lt;h3&gt;二．描述&lt;/h3&gt;

&lt;p&gt;举HeadFirst中Starbucks的例子，星巴克中有很多种饮料，每种饮料需要有单独的计算价格cost()的功能，以及能够获得该饮料的具体描述的getDescription()功能。如果通过设置一个Beverage超类，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/o_clip_image002_2.gif&quot; alt=&quot;Beverage&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所有其它的具体饮料都继承该超类，就会产生类爆炸现象（可以考虑有4大类饮料，HouseBlend，DarkRotast，Decaf，Espresso，4种配料milk，soy，mocha，whip，配料可以自由组合，自己算算一共有多少种具体的饮料类型吧），显然这是不行的（考虑一下某种配料的价格改变了，那么需要改变的类的数目！！）。&lt;/p&gt;

&lt;p&gt;一种改进方法是将配料价格的计算放在超类Beverage中，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/o_clip_image004_2.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样就不用担心某种配料价格的改变了（可以通过超类来设置配料价格），但是这种设置方式还是有缺陷的，可以想象一下如果创造出一种新的配料（毕竟创新时代嘛），那么就不得不改变超类Beverage，在其中添加新配料的方法，改变现有的代码是OO里极其避讳的事情，因此需要更好的方法来处理类似的问题，于是，就有了Decorator Pattern。&lt;/p&gt;

&lt;p&gt;Decorator Pattern的目的就是要动态的想对象中添加功能，针对此例来说，我们可以将配料当作额外的功能，饮料大类当作目标对象，用配料来装饰目标对象，例如，想要一个加鲜奶（whip）摩卡（mocha）的DarkRoast，那么，首先选择目标对象，DarkRoast，然后用添加mocha，（用mocha装饰），形成一个加mocha的DarkRoast，然后添加whip（用whip装饰），产生最终的饮料，但是在这里有一点很重要，如何计算价钱，毕竟人家要赚钱么~设计中很容易，因为所有的目标对象类，以及配料类都是继承自超类Beverage，（不过注意这里，继承并不是为了获取父类功能，只是为了类型的统一），均有一个cost()方法，调用最后包装好的目标对象的cost()方法得到的就是全部的价钱。好像有点乱哈，先看看类图吧：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/o_clip_image006_2.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个目标对象类（Espresso等）都继承自超类Beverage，实现超类提供一个抽象方法cost()，配料装饰类继承自一个抽象类CondimentDecorator类，该抽相类同样继承自超类Beverage，并且覆盖了超类中的getDescription()方法，使其成为抽象方法，强制具体的配料类必须实现该方法。并且每个具体的配料类中都拥有一个Beverage实例对象，作为其要包装的目标对象。&lt;/p&gt;

&lt;h3&gt;三．代码实现：&lt;/h3&gt;

&lt;p&gt;Beverage 类 ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public abstract class Beverage {  
    String description=&quot;Unknown Beverage&quot;;  
    public abstract double cost();  
    public String getDescription() {  
        return description;  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体目标对象类：&lt;/p&gt;

&lt;p&gt;DarkRoast类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class DarkRoast extends Beverage {  
    public DarkRoast(){  
        super.description = &quot;DarkRoast&quot;;  
    }  
    public double cost() {  
        return 0.89;//事实上应该提供一个price属性，然后提供该属性的setter，getter方法  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个代码实例是按照HeadFirst上实现的，事实上，个人觉得在实际应用中应该提供一个price属性，并为该属性提供setter和getter方法，用于设置该饮料的价格，而不是直接将价格硬编码到类中。&lt;/p&gt;

&lt;p&gt;这个累的实现很简单，就是在构造时设置description为对应的饮料描述。其余的目标类与这个类的实现类似，只不过对应的描述，价格不同而已。&lt;/p&gt;

&lt;p&gt;抽象配料装饰类：&lt;/p&gt;

&lt;p&gt;CondimentDecorator类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public abstract class CondimentDecorator extends Beverage {  
    public abstract String getDescription();  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该抽象类强制具体实现的配料类要提供getDescription方法，这也是HeadFirst中的实现，但是我个人觉得，应该把子类中的beverage也放到该类中，毕竟是共性的东西。&lt;/p&gt;

&lt;p&gt;具体配料类的实现：&lt;/p&gt;

&lt;p&gt;Mocha类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Mocha extends CondimentDecorator {  
    private Beverage beverage;  

    public Mocha(Beverage beverage) {  
        this.beverage = beverage;  
    }  
    public double cost() {  
        return beverage.cost()+0.25;  
    }  
    @Override  
    public String getDescription() {  
        // TODO Auto-generated method stub  
        return beverage.getDescription()+&quot;, Mocha&quot;;  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体配料类的构造方法中有一个参数，也就是目标对象，通过构造方法为属性赋值，计算价格时调用目标对象的cost()方法，然后加上配料的价格，实现抽象配料类中的getDescription()方法，调用目标对象的getDescription()，并添加相应的配料描述。同样在这里，我觉得应该为配料提供一个价格属性，price，而不是直接将价格硬编码到类中。其余的配料实现类与该类的实现类似。&lt;/p&gt;

&lt;p&gt;测试类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class StarbuzzTest {  
    public static void main(String[] args){  
        Beverage beverage = new Espresso();  
        System.out.println(beverage.getDescription()+&quot; $&quot;+beverage.cost());  

        Beverage beverage2 = new DarkRoast();  
        beverage2 = new Mocha(beverage2);  
        beverage2 = new Whip(beverage2);  
        System.out.println(beverage2.getDescription()+&quot; $&quot;+beverage2.cost());  

        Beverage beverage3 = new HouseBlend();  
        beverage3 = new Soy(beverage3);  
        beverage3 = new Mocha(beverage3);  
        beverage3 = new Mocha(beverage3);  
        System.out.println(beverage3.getDescription()+&quot; $&quot;+beverage3.cost());  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试类中用于产生目标饮料类型对象的语句，可以采用工厂方法，或者抽象工厂等模式来实现，这里只是为了简化，尊重HeadFirst原书实现。&lt;/p&gt;

&lt;p&gt;测试结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Espresso $1.05  
DarkRoast, Mocha, Whip $1.39  
HouseBlend, Soy, Mocha, Mocha $2.69  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;四．总结&lt;/h3&gt;

&lt;p&gt;装饰模式的作用就是为目标对象动态添加职责。它提供了一种比继承更加自由的扩展功能的实现。&lt;/p&gt;

&lt;p&gt;当然，装饰模式中也用到了继承，但是这里的继承只是为了实现类型的统一，因为需要要使目标对象与装饰对象具有相同的超类。而不是想通常所用继承为了扩展超类的功能。&lt;/p&gt;

&lt;p&gt;该模式的参与者包括：&lt;/p&gt;

&lt;p&gt;Component：定义一个对象接口，可以给这些对象动态添加职责。&lt;/p&gt;

&lt;p&gt;ConcreteComponent：定义一个对象，可以个这个对象添加职责。&lt;/p&gt;

&lt;p&gt;Decorator：拥有一个目标对象Component的引用，并且该Decorator实现了目标Component接口。&lt;/p&gt;

&lt;p&gt;ConcreteDecorator：负责向目标对象添加职责的具体Decorator实现。&lt;/p&gt;

&lt;p&gt;通用的装饰模式类图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/o_clip_image008_2.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;装饰模式的优点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;比静态集成更灵活。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;避免在层次结构高层的类有太多的特征。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;——GoF 《Design Pattern 》&lt;/p&gt;

&lt;p&gt;适用性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在不影响其他对象的情况下，以动态的，透明的方式给单个对象添加职责。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;处理可撤销的职责。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合，将产生大量子类（例如上面的类爆炸），使得子类呈现爆炸式增长。另一种就是类定义被隐藏，也就是说不允许生成子类（java中的final类）。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>设计模式学习笔记(1)——单例模式</title>
   <link href="http://jiang-bo.github.com/blog/2009/08/28/singleton-desgin-pattern"/>
   <updated>2009-08-28T16:48:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/08/28/singleton-desgin-pattern</id>
   <content type="html">&lt;h4&gt;目的：&lt;/h4&gt;

&lt;p&gt;保证一个类仅有一个实例，并为该实例提供也个安全的全局访问点&lt;/p&gt;

&lt;h4&gt;用途：&lt;/h4&gt;

&lt;p&gt;在很多时候，系统中需要某个类只有一个实例，例如连接数据库时的驱动程序注册，加载属性文件等。&lt;/p&gt;

&lt;p&gt;实现的核心是要有一个私有的构造方法，静态实例变量，以及返回该静态变量的公有静态方法作为全局访问接口。&lt;/p&gt;

&lt;p&gt;一个最基本的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Singleton { 
    private static Singleton instance = null; // 静态实例变量

    private Singleton() { // 私有的构造方法 
    }

    public static Singleton getInstance() { // 公有的全局访问接口 
       if (instance == null) { // 检查是否已经实例化，以保证只有一个实例 
            instance = new Singleton(); 
        } 
        return instance; 
    } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种实现在单线程环境下是没有什么问题的，但是在多线程环境下就会出现问题，例如现在有两个线程A，B，当A执行完红色的判断语句后切换到线程B，假设此时instance尚未实例化，B执行判断，条件为真，进行实例化instance，返回，当再次切换到线程A时，继续上一次的执行，实例化instance，这是系统中就存在了两个实例。&lt;/p&gt;

&lt;p&gt;最简单的改进方法就是在对getInstance方法进行同步限制，也就是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static synchronized Singleton getInstance() {…}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这样synchronized的效率很差，存在更好的改进方法&lt;/p&gt;

&lt;h4&gt;1.直接加载&lt;/h4&gt;

&lt;p&gt;通常使用的都是晚加载（Lazy mode），需要时在实例化，但是，有时能够确定系统中肯定要存在一个该类的实例，直接加载是一种简单的实现方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class SingletonEagerInstantiation { 
    private static SingletonEagerInstantiation instance = new SingletonEagerInstantiation(); //直接静态实例化

    private SingletonEagerInstantiation() { 
    }

    public static SingletonEagerInstantiation getInstance() { 
        return instance;//直接返回 
    } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2.双重检查&lt;/h4&gt;

&lt;p&gt;刚才使用synchronized关键字时，出现了效率差的现象，是因为无论instance是否已经实例化了都要进行同步，synchronized效率很差，而使用双重检查，先判断instance是否已经实例化，如果为空在进行同步，这样就提高了效率，而且这种实现方式也提供了晚加载的能力，但是注意volatile关键字限制了该种实现方式只能用于jdk1.5以上版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class SingletonDoubleCheck { 
    private static volatile SingletonDoubleCheck instance = null; 
    private SingletonDoubleCheck() { 
    } 
    public static SingletonDoubleCheck getInstance() { 
        if (instance == null) {//先判断 
            synchronized (SingletonDoubleCheck.class) {//如果没有实例化，同步 
                if (instance == null) {//再次判断 
                    instance = new SingletonDoubleCheck();//实例化 
                } 
            } 
        } 
        return instance; 
    } 
}
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title> 设计模式学习笔记（3）——适配器模式(Adapter Pattern)</title>
   <link href="http://jiang-bo.github.com/blog/2009/08/28/adapter-pattern"/>
   <updated>2009-08-28T16:48:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/08/28/adapter-pattern</id>
   <content type="html">&lt;p&gt;一、 目的：&lt;/p&gt;

&lt;p&gt;将一个类的接口转换成客户希望的另一个接口。Adapter 模式使原本由于接口不兼容而不能一起工作的那些类可以一起工作。&lt;/p&gt;

&lt;p&gt;——GoF 《Design Pattern 》&lt;/p&gt;

&lt;p&gt;二、 描述：&lt;/p&gt;

&lt;p&gt;其实个人觉得Adapter模式在所有的模式当中算是比较简单的那种，也比较容易理解，就像我们日常生活中经常会使用USB转换器，将某种非USB接口的外设转换我们本本上提供的USB接口一样，在面向对象设计中，有时候我们不得不将将某个类的接口转换成另外一种我们需要的类型，最通常的情况可能是因为我们要想为现有的系统添加额外的一个现有的子系统，而两个系统提供的接口不同，因此，我们不得不讲其中一个转换成另一个，或者进行双向转换。&lt;/p&gt;

&lt;p&gt;说起来好像很容易理解，那么到底应该如何应用Adapter模式呢，还是举HeadFirst中的例子吧：&lt;/p&gt;

&lt;p&gt;假设现在我们有一个现有系统SimuDuck，提供一个鸭子的接口Duck，要求系统中的所有的类必须实现该Duck接口&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/_clip_image002.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（注：staruml中设置接口图形格式：右键图标-&gt;Format-&gt;seterotype-&gt;None,不过怎么把方法显示出来还么研究好）&lt;/p&gt;

&lt;p&gt;该接口提供两个方法，fly(),飞， quack(),叫。&lt;/p&gt;

&lt;p&gt;现在要向这个系统中天加一个由一些火鸡组成的子系统，火鸡实现的是火鸡接口Turkey：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/o_clip_image004_2_633891499875937500.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;该接口提供的方法功能包括,fly()飞，gobble()叫。&lt;/p&gt;

&lt;p&gt;现在要想将实现Turkey的具体火鸡类在现有的使用Duck接口的系统中使用，就必须将Turkey转换成Duck，实现起来很简单，类图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/o_adapter_duck_turkey_4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;设计一个TurkeyAdapter，该适配器实现了Duck接口，并使用一个Turkey作为构造参数，在TurkeyAdapter中实现Duck接口的方法时，实际调用的是Turkey的方法，下面时代码实现：&lt;/p&gt;

&lt;p&gt;Duck接口：&lt;/p&gt;

&lt;p&gt;[java] view plaincopy
public interface Duck {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public abstract void quack();  
public abstract void fly();  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br/&gt;
MallardDuck具体鸭子类：&lt;/p&gt;

&lt;p&gt;[java] view plaincopy
public class MallardDuck implements Duck {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void quack(){  
    System.out.println(&quot;MallardDuck quack&quot;);  
}  
public void fly(){  
    System.out.println(&quot;MallardDuck fly&quot;);  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br/&gt;
注意，这里的实现quack()和fly()方法时使用简单的直接实现，实际中应该采用Strategey（策略）模式，以后再说该模式。&lt;/p&gt;

&lt;p&gt;Turkey接口：&lt;/p&gt;

&lt;p&gt;[java] view plaincopy
public interface Turkey {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void fly();  
public void gobble();  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br/&gt;
实现Turkey的具体WildTurkey：&lt;/p&gt;

&lt;p&gt;[c-sharp] view plaincopy
public class WildTurkey implements Turkey {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void fly(){  
    System.out.println(&quot;WildTurkey fly&quot;);  
}  
public void gobble(){  
    System.out.println(&quot;WildTurkey gobble&quot;);  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br/&gt;
最关键的TurkeyAdapter：&lt;/p&gt;

&lt;p&gt;[java] view plaincopy
public class TurkeyAdapter implements Duck {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Turkey turkey;  
public TurkeyAdapter(Turkey turkey){  
    this.turkey = turkey;  
}  
public void quack(){  
    turkey.gobble();  
}  
public void fly(){  
    turkey.fly();  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br/&gt;
该类拥有一个Turkey的实例变量，一个以Turkey作为参数构造方法，也就是说在构造时将要转换的Turkey对象作为构造参数传递给该适配器，当调用适配器的Duck接口的方法时，实际调用的是turkey对象的方法。&lt;/p&gt;

&lt;p&gt;在这里，由于示例比较简单，没有什么问题，在实践中，可能会出现被转换的类不具备目标对象的某种功能，例如，如果Duck中有一个swim()方法，很明显，Turkey不能游泳，也就没有可以调用的方法，通常的做法是抛出一个异常CanNotFindMethodException。&lt;/p&gt;

&lt;p&gt;最后是测试程序：&lt;/p&gt;

&lt;p&gt;[java] view plaincopy
public class Client {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args){  
    MallardDuck duck = new MallardDuck();  

    WildTurkey wildTurkey = new WildTurkey();  
    Duck turkeyAdapter = new TurkeyAdapter(wildTurkey);  

    System.out.println(&quot;Duck...&quot;);  
    testDuck(duck);  

    System.out.println(&quot;TurkeyAdapter...&quot;);  
    testDuck(turkeyAdapter);  
}  
static void testDuck(Duck duck){  
    duck.fly();  
    duck.quack();  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br/&gt;
该测试程序的输出结果为：&lt;/p&gt;

&lt;p&gt;[java] view plaincopy
Duck...&lt;br/&gt;
MallardDuck fly&lt;br/&gt;
MallardDuck quack&lt;br/&gt;
TurkeyAdapter...&lt;br/&gt;
WildTurkey fly&lt;br/&gt;
WildTurkey gobble&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Eclipse中修改Tomcat端口</title>
   <link href="http://jiang-bo.github.com/blog/2009/08/26/post"/>
   <updated>2009-08-26T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/08/26/post</id>
   <content type="html">在Linux中新安装了Oracle，占用了原来Tomcat的8080端口，修改了tomcat中conf目录下的server.xml文件：&lt;br /&gt;&lt;connector port=&quot;&amp;lt;font color=&quot;&gt;&lt;font color=&quot;#ff0000&quot;&gt;8080&lt;/font&gt;&quot; protocol=&quot;HTTP/1.1&quot; &lt;br /&gt;               connectionTimeout=&quot;20000&quot; &lt;br /&gt;               redirectPort=&quot;8443&quot; /&amp;gt;&lt;br /&gt;将上面的8080改为未被占用的1024以上的端口，我改的是9000，保存后运行startup.sh脚本启动Tomcat，但是在Eclipse中，原来设置的Tomcat服务器启动时仍然报错，说8080被占用，tomcat无法启动，解决方法如下：&lt;br /&gt;在server面板中（如果没有，通过windows-&amp;gt;show view-&amp;gt;Other-&amp;gt;servers打开）删除原来设置的tomcat服务器，重启Eclipse，重新设置一个服务器，启动，一切正常了～&lt;br /&gt;～Good Luck~&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;zemanta-pixie&quot;&gt;&lt;img class=&quot;zemanta-pixie-img&quot; alt=&quot;&quot; src=&quot;http://img.zemanta.com/pixy.gif?x-id=d55ce718-3dc4-86e1-abe6-bc4529e04031&quot; /&gt;&lt;/div&gt;
&lt;/connector&gt;</content>
 </entry>
 
 <entry>
   <title>Ubuntu9.04安装Oracle XE</title>
   <link href="http://jiang-bo.github.com/blog/2009/08/24/post"/>
   <updated>2009-08-24T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/08/24/post</id>
   <content type="html">&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;一直听说Ubuntu上安装Oracle相当麻烦，今天体验了一把，可能比较幸运，没出什么问题，简单记录一下，先声明，我装的是Oracle XE版，也就是官网上所说的快捷版，企业版的安装要麻烦的多，而且好想也不支持Ubuntu。&lt;/p&gt;
&lt;p&gt;简单来说步骤如下：&lt;/p&gt;
&lt;p&gt;1.将http://oss.oracle.com/debian unstable non-free添加到软件源中&lt;/p&gt;
&lt;p&gt;2.添加密钥 sudo apt-key add RPM-GPG-KEY-oracle（不过我安装时提示密钥无效，但最后也装上了，不了解）&lt;/p&gt;
&lt;p&gt;3.sudo apt-get update更新（不过我添加后立即更新没能什么都没有，没什么反应，过了几个小时自动更新里提示安装）&lt;/p&gt;
&lt;p&gt;4.正常的话会自动安装&lt;/p&gt;
&lt;p&gt;5.配置数据库 sudo /etc/init.d/oracle-xe configure，这里包括监听端口号，http端口，以及帐户密码等选项，默认安装就可以了，当然，密码要自己设。&lt;/p&gt;
&lt;p&gt;6.安装完成后，网上很多人提示说是要配置环境变量，但是我发现安装过程自己配置了，可以通过echo $ORACLE_HOME等方法查看一下，没设自己设一下把&lt;/p&gt;
&lt;p&gt;6.正常在GNOME环境中会在应用程序栏中添加Oracle菜单栏，选择转至数据库主页，正常的话就能够打开数据库主页，地址为：http://127.0.0.1:8080/apex，(8080是你在配置时设置的端口号，我的默认就是8080),然后输入用户名密码登录就OK了&lt;/p&gt;
&lt;p&gt;～～～看似简单，哈～希望大家也想我一样顺利哈～继续学习中～&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>安装MySQL时无法启动服务（could not start the service MYSQL .Error:0）</title>
   <link href="http://jiang-bo.github.com/blog/2009/08/22/post"/>
   <updated>2009-08-22T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/08/22/post</id>
   <content type="html">&lt;p&gt;今天写程序时发现连接不上MySQL，检查了一下发现MySQL服务未启动，手动开启也不行，于是重新安装了一下，结果在安装过程中，执行execute时，出现了could not start the service MYSQL .Error:0的错误。网上搜了一下，一般在重装MySQL时会出现这个错误，我的解决的方法是将所有的与MySQL相关的文件全部删除，然后再重装一下，就行了，当然，这个方法很烂很暴力，好像修改一下my.ini文件就行，不太清楚，反正已经好了，懒得管了~呵呵~&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Android文档（二）-应用基础（1）应用组件（Application Components）</title>
   <link href="http://jiang-bo.github.com/blog/2009/08/20/post"/>
   <updated>2009-08-20T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/08/20/post</id>
   <content type="html">&lt;h4&gt;应用基础&lt;/h4&gt; &lt;p&gt;Android应用程序由Java语言编写。Java字节码以及应用所需的所有数据资源文件都通过aapt工具打包成Android package，一种被标记问.apk的归档文件。这类文件是在移动设备上发布和安装应用程序的基础；用户下载这种文件到他们的设备上。一个.apk文件中所有的代码被认为是一个应用。&lt;/p&gt; &lt;p&gt;在很多情况下，每个Android应用程序处于自己的生存空间内：&lt;/p&gt; &lt;p&gt;1.默认情况下，每个应用运行在它自己的独立的linux进程环境中。当任何应用的代码需要被执行的时候，Android启动这个进程，当不再需要这个进程并且有其他的应用请求他的系统资源时，关闭该进程。&lt;/p&gt; &lt;p&gt;2.每个进程有他自己的Java VM，因此应用之间的执行代码是相互隔离的。&lt;/p&gt; &lt;p&gt;3.默认情况下，每个应用被赋给唯一的用户ID。通过权限设置使得这个应用的文件只对相应用户及应用本身可见。当然，也可以通过某种方式将这些文件导出给其它应用。&lt;/p&gt; &lt;p&gt;可以通过两个应用共享同一个用户ID，使他们可以共享彼此的文件。为了节约系统资源，相同用户ID的应用可以运行在同一个Linux进程中，共享同一个VM。&lt;/p&gt; &lt;h5&gt;应用组件（Application Components）&lt;/h5&gt; &lt;p&gt;Android的一个核心特性就是一个应用可以利用其他应用的元素（得到这些应用的允许）。例如，你的应用需要显示一个滚动的图像列表，而另外一个应用已经开发了一个可用的滚动条，并且是其他应用可以应用这个滚动条，你可以调用这个滚动条，而不用自己开发一个。你的应用并不和其他应用的代码混合或连接，而是简单的启动其他应用所需的一部分。&lt;/p&gt; &lt;p&gt;为了实现这种机制，当任何应用的某一部分被请求时，系统必须能够启动该应用的一个进程，并且为该进程实例化一个Java对象。这与大部分其他系统上的应用不同。Android应用不需要为每个应用设立入口点（无main()函数)。相对而言，只是一些核心组件，系统能够实例化这些组件，并且在需要时运行。&lt;/p&gt; &lt;p&gt;共有4类组件：&lt;/p&gt; &lt;p&gt;&lt;b&gt;活动（Activities&lt;/b&gt;&lt;b&gt;）&lt;/b&gt;&lt;/p&gt; &lt;p&gt;一个活动表示为一个与用户交互用户图形界面。例如，一个活动可以表示为一个菜单项组成的列表，用户能够从中选择，或者表示为一个可以显示带有标题的照片。一个文本消息应用可能拥有一个显示联系人的列表，另一个活动负责像这个被选中的联系人写消息，还有另外的一个活动负责查看已有的消息或者更改设置。尽管他们一起形成一个完整的用户界面，但是每个活动还是相互独立的。每一个都是基类Activity的子类。&lt;/p&gt; &lt;p&gt;一个应用可能有一个或多个活动。这些活动是什么以及数量有多少取决于不同应用的设计。典型的，当应用启动时活动中的被标记为第一的应该第一个展现给用户。活动间的传递是通过当前活动启动下一活动来实现的。&lt;/p&gt; &lt;p&gt;每个活动都被会旨在一个给定的窗口（window）上。典型的，一个窗口一改填充满整个屏幕（screen），但是，有时也可能小于屏幕或者漂浮（float）在其他窗口上。一个活动能够利用额外的窗口-例如，一个弹出窗口或者一个当用户在屏幕上选择了特定项是，用于显示重要信息的窗口。&lt;/p&gt; &lt;p&gt;窗口的可视内容都是通过继承视图基类View实现的。每个视图控制着窗口内一个特定的矩形区域。父视图负责承接子视图并组织子视图的布局。叶视图（继承树中最低层的）绘制在矩形区域内负责直接控制和响应用户在该区域内的活动。也就是说，视图是活动与用户发生交互的地方。例如，一个试图可能显示一个小图片并且当用户查看该图片时初始化一个动作。Android有一些内置的视图共开发者使用-包括按钮（buttons），文本框（text field），滚动条（scroll bar)，菜单栏（menu items），选择框（check box），等等。&lt;/p&gt; &lt;p&gt;视图通过活动窗口的Activity.setContentView()方法设置一个视图。content view是位于继承树根的View对象。&lt;/p&gt; &lt;p&gt;&lt;b&gt;服务（Services&lt;/b&gt;&lt;b&gt;）&lt;/b&gt;&lt;/p&gt; &lt;p&gt;一个服务（service)没有可视用户界面，而是在一个不确定的时期内运行于后台。例如，在用户试图处理其他事物时，一个服务可能用于在后台播放音乐，或者从网络中接收数据或者计算一些事情并将结果发送给需要的活动。每个服务都是扩展于基类Service。&lt;/p&gt; &lt;p&gt;一个初级的例子就是媒体播放器按照播放列表播放音乐。播放器应用可能拥有一个或多个活动，例如允许哦那个湖选择曲目并且开始播放等活动。然而，在后台播放的音乐并不由活动来处理，因为用户会希望在他们离开播放器，或者处理其他事务时，音乐能够持续播放。为了保持音乐播放，播放器活动必须能够开启一个服务用语在后台运行。当活动开启服务后并离开屏幕后，系统会保持循环播放的服务。&lt;/p&gt; &lt;p&gt;可以连接一个正在运行的服务（如果服务没有开启，箱开启服务）。在连接时，你可以通过服务导出的接口与服务进行通信。对于音乐服务，这个接口可能允许用户暂停，倒退，停止，或者重启虚幻播放。&lt;/p&gt; &lt;p&gt;类似于活动和其他组件，服务可以运行在应用进程的主线程中。因此他们不会影响其他组件或者用户接口。他们通常产生另外的线程用于耗时任务（例如音乐播放）。&lt;/p&gt; &lt;p&gt;&lt;b&gt;广播接收者（Broadcast receivers)&lt;/b&gt;&lt;/p&gt; &lt;p&gt;一个广播接收者是一个仅用来接收和反射广播布告的组件。许多广播起源于系统代码-例如，通知说，时区已发生了变化，电池电量低，该图片已经采取，或用户改变了语言偏好。一个应用可以有任意数量的广播接收机，以应付任何它认为重要的通知。所有接收器扩展BroadcastReceiver基类。广播接收机不显示用户界面。然而，他们可能会启动一项活动去响应收到的信息，或者他们可以使用NotificationManager提醒用户。通知可以以各种方式引起用户的注意-闪动的背光，振动设备，播放声音，等等。它们通常在状态栏放置一个图标，用户可以打开它获得的信息。&lt;/p&gt; &lt;p&gt;&lt;b&gt;内容提供者&lt;/b&gt;&lt;b&gt;(&lt;/b&gt;&lt;b&gt;Content providers)&lt;/b&gt;&lt;/p&gt; &lt;p&gt;内容提供商将一系列具体的应用程序数据提供给其他应用程序。这些数据可以存储在文件系统或 SQLite数据库中，或以任何其他有意义的方式存储 。内容提供商扩展于ContentProvider基类，实现了一组标准方法，使其他应用程序来检索和存储它所控制的数据类型。然而，应用程序不直接调用这些方法。相反，他们使用ContentResolver对象，并调用其方法。一个ContentResolver可以与任何内容提供商交互，它与供应商共同管理任何进程间通信。&lt;/p&gt; &lt;p&gt;每当有一个请求需要被某一特定组件处理时，Android确保该组件的应用进程的正在运行，否则启动一个新进程，并确保该组件的一个适当实例可用，否则创建一个新的实例。&lt;/p&gt; &lt;p&gt;&lt;b&gt;活动组件：意图&lt;/b&gt;&lt;b&gt;(Intents)&lt;/b&gt;&lt;/p&gt; &lt;p&gt;内容供应商在一个ContentResolver向其发出请求时被激活 。其他三个组成部分-活动，服务和广播接收机-被称为意图的异步消息激活 。一个意图是一种持有的内容信息的Intent对象。对于活动和服务，它意味着一个被请求的动作和指定位于其他事物中的所要使用的数据的URI。例如，它可能转达活动提出的请求去想用户展示一幅图片或使用户可以编辑一些文字。对于广播接收机，Intent对象意味着一个被宣布的活动。例如，它可能会向有关各方宣布相机按钮已被按下。&lt;/p&gt; &lt;p&gt;有不同的方法激活各种类型的组件：&lt;/p&gt; &lt;p&gt;Ÿ 可以通过向Context.startActivity()或Activity.startActivityForResult()传递一个Intent对象 激活一个活动。作出答复的活动可以通过调用getIntent()方法查询导致其激活的最初的意图，Android通过调用活动的onNewIntent()方法，传递intents。一项活动往往启动下一活动。如果期望从启动的活动返回结果，它必须调用startActivityForResult()而不是startActivity() 。例如，如果启动了一个可以让用户选择一个照片的活动，它可能会希望返回所选择的照片。&lt;/p&gt; &lt;p&gt;Ÿ 启动一个服务（或新的指示被发送给正在进行的服务）是通过传递一个Intent对象给Context.startService() 。Android调用该服务的onStart()方法并且向其传递Intent对象。同样，一个intent可以被传递给Context.bindService()用于在请求组件和目标服务之间建立一个持续连接。服务通过onBind()调用获得这个intent对象。 （如果该服务尚未运行， bindService()可以有选择地启动它。 ）举例来说，一项活动可能与前面提到的音乐播放服务建立连接，以便它可以为用户提供的手段（用户界面）来控制播放。这项活动将调用bindService()建立连接，然后调用服务所定义的方法影响到播放。在后面的部分中， 远程过程调用（ Remote procedure calls ），有更多细关于绑定到服务的细节。&lt;/p&gt; &lt;p&gt;Ÿ 一个应用程序就可以通过向Context.sendBroadcast() ， Context.sendOrderedBroadcast() ，和Context.sendStickyBroadcast()方法传递Intent对象初始化一个广播。Android是通过调用onReceive()方法，向所有有兴趣的广播接收机传递intent对象。&lt;/p&gt; &lt;p&gt;&lt;b&gt;关闭组件&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;内容提供商只有在回应ContentResolver发出的请求时才被激活 。广播接收器只有在回应一个广播讯息时被激活。因此，没有必要显式地关闭这些组件。&lt;/p&gt; &lt;p&gt;另一方面，活动提供了用户界面。他们处于长时间运行的用户会话中，并可能保持活跃，甚至在闲置，只要谈话继续进行。同样，服务也可能持续运行了很长一段时间。因此，Android需要适当方法来有条不紊地关闭活动和服务：&lt;/p&gt; &lt;p&gt;Ÿ 一项活动可以通过调用finish()方法关闭。一项活动可以通过调用finishActivity() 关闭其他活动（一个通过startActivityForResult()启动的活动 ）。&lt;/p&gt; &lt;p&gt;Ÿ 服务可以通过调用stopSelf()或Context.stopService()方法停止 。&lt;/p&gt; &lt;p&gt;当组件不再被使用，或当Android必须收回内存去激活其他组件时，也可能被系统关闭。在后面的部分中， 组件生命周期（Component Lifecycles） ，讨论这种可能性及其影响的更多细节。&lt;/p&gt; &lt;p&gt;&lt;b&gt;manifest&lt;/b&gt;&lt;b&gt;文件&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;在Android启动应用组件之前，它必须知道该组件的存在。因此，应用在一个捆绑在Android包中的清单文件中声明其组件， .apk文件还拥有应用程序的代码，文件和资源。&lt;/p&gt; &lt;p&gt;该清单文件是一个XML文件和对所有的应用命名总是AndroidManifest.xml。除了声明该应用程序的组件，该文件还处理其他事情，如命名任何应用需要链接的库（除了默认的Android库） ，并确保应用的任何权限设置按预期执行。&lt;/p&gt; &lt;p&gt;但其主要任务是主要是要通知Android的应用程序的组件。例如，一项活动可能会声明如下：&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;manifest&gt;&lt;/manifest&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;application&gt;&lt;/application&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;activity android:name=&quot;com.example.project.FreneticActivity&quot;&gt;&lt;/activity&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;android:icon=&quot;@drawable/small_pic.png&quot;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;android:label=&quot;@string/freneticLabel&quot; &lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;. . . &amp;gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;. . .&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;activity&gt;元素的name属性声明了实现活动的Activity的子类。icon和label属性指向包含一个图标和标签的资源文件，可显示给用户的展示活动。其它组件以同样的方式被生命- &lt;service&gt;元素表示服务， &lt;receiver&gt;元素表示广播接收机，&lt;provider&gt;元素表示内容提供商。没有在manifest中声明的活动，服务和内容提供商是对系统不可见，因此无法运行。&lt;/provider&gt;&lt;/receiver&gt;&lt;/service&gt;&lt;/activity&gt;&lt;/p&gt; &lt;p&gt;然而，广播接收机既可以被声明在manifest中，或者他们可以在代码中动态创建（如BroadcastReceiver对象）和通过系统调用Context.registerReceiver()注册 。&lt;/p&gt; &lt;p&gt;&lt;b&gt;Intent&lt;/b&gt;&lt;b&gt;过滤器&lt;/b&gt;&lt;/p&gt; &lt;p&gt;一个Intent对象可以显式的声明一个目标组件。这样一来，Android将查找这个组建（根据manifest文件中的声明） ，并激活它。但是，如果目标没有显式命名，Android必须找到最好的组件对该Intent作出反应。这是通过比较Intent对象和Intent过滤器中的潜在目标来实现的。一个组成部分的Intent过滤器通知Android组建能够处理的各种intent。像其他关于组件的基本信息一样，他们宣布在manifest文件。&lt;/p&gt; &lt;p&gt;以下是扩展前面的例子，向活动中增加了两个Intent过滤器：&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;manifest&gt;&lt;/manifest&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;application&gt;&lt;/application&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;activity android:name=&quot;com.example.project.FreneticActivity&quot;&gt;&lt;/activity&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;android:icon=&quot;@drawable/small_pic.png&quot;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;android:label=&quot;@string/freneticLabel&quot; &lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;. . . &amp;gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;intent-filter&gt;&lt;/intent-filter&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;action android:name=&quot;android.intent.action.MAIN&quot;&gt;&lt;/action&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;&gt;&lt;/category&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;intent-filter&gt;&lt;/intent-filter&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;action android:name=&quot;com.example.project.BOUNCE&quot;&gt;&lt;/action&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;data android:mimetype=&quot;image/jpeg&quot;&gt;&lt;/data&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;&gt;&lt;/category&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;. . .&lt;/i&gt;&lt;/p&gt; &lt;p&gt;&lt;i&gt;&lt;/i&gt;&lt;/p&gt; &lt;p&gt;事例中第一个过滤器——活动的结合“ android.intent.action.MAIN ”和类别“android.intent.category.LAUNCHER ” -是一种常见的过滤器。它标志着活动应在应用启动器上展示，屏幕列表应用的用户可以在设备上启动。换句话说，该活动是应用的切入点，当用户在应用启动器上选择是他们将能够看到一个初始的活动。&lt;/p&gt; &lt;p&gt;第二个过滤器声明了一项，该活动可以在某一特定类型的数据上执行的动作。&lt;/p&gt; &lt;p&gt;组件可以有任意数量的Intent过滤器，每一个宣布了一声明了不同的功能。如果它没有任何过滤器，它只能通过Intent显式的声明目标组建的方式激活。&lt;/p&gt; &lt;p&gt;对于像广播接收器，在代码中创建和注册，Intent过滤器直接实例化一个IntentFilter对象。所有其他的过滤器的设置在manifest中。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>[转]Alexandru Popescu谈InfoQ.com网站架构</title>
   <link href="http://jiang-bo.github.com/blog/2009/08/19/post"/>
   <updated>2009-08-19T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/08/19/post</id>
   <content type="html">&lt;p&gt;大家好，我是Ryan Slobojan，坐在我旁边的是InfoQ.com的首席架构师Alexandru Popescu。Alexandru，能否告诉我们InfoQ网站的一些架构信息&amp;mdash;它是什么样子的？又是如何构建的？ &lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-collapse.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你可以从两种不同角度审视InfoQ的架构：从我们读者的角度看，InfoQ就像是一个普通的网站；但是对于我们的编辑和在后台工作的人员来说，它则是一个地地道道的CMS（内容管理系统）。因此，你所看到的InfoQ建立在一个自制的CMS的基础之上，它把内容与用户账号、跟踪系统、广告机制等等集成。我们可以从一个更易于理解的角度来描述 InfoQ网站&amp;mdash;它是一个Web应用，即使是CMS，你也可以看作是一个Web应用，它有通常的分层结构：表现层、服务层和持久化层。   &lt;br /&gt;两年半之前，当我启动这个项目的时候，面临着很多有趣的选择。例如，持久化方面不但基于关系型数据库，而且使用JCR API存储内容。同时，我们不得不在基于组件的Web框架和基于动作的框架中二者选其一，并最终选择了后者。我们认为它更贴近我们解决方案的设计，即使我们可能需要一些基于portlet的东西&amp;hellip;&amp;hellip;我想说那时侯portlet规范非常差，希望以后我不会让大家太失望。你可以想象作为一个三层结构是多么的简单，你应该能够猜到：一点Spring、一点WebWork、一点Hibernate和JCR API。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn2.infoq.com/styles/cn/i/icon-right.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; 能否给我们描述一下，当你作为一个用户和一个作者发出请求时，内部会发生什么变化？ &lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-collapse.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当然，希望我没有记错一些细节。让我们从浏览器开始。通常有两种方式访问我们的应用，要么是通过浏览器正常访问，要么是通过AJAX请求，如 XMLHTTPRequest，然后请求进入WebWork或者DWR。如果是普通请求，则它会经过WebWork处理。如果是AJAX请求，则进入 DWR，然后分派到服务层，这层的全部家当只不过是Spring和一些采用AspectJ的AOP，目的是增强我们的模型。然后，请求会进入持久化层，我刚才已经提到这层被分割为Hibernate和JCR。   &lt;br /&gt;因此，最后我们拥有两种不同的存储。此时你可能会问为什么我们选择了两种解决方案来存储信息，这些信息本可以采用同一种存储方式。问题是，当我们设计 InfoQ的时候，我们并不确定模型会是什么样子的，也不确定我们的内容随着时间会如何变化。同时，在关系型模式下处理这些变化非常困难，在不同版本之间迁移和维护数据等等是非常复杂的。而JCR API明确支持非结构的内容和很多其他特性，比如版本化、全文索引，我们充分利用了这些功能。    &lt;br /&gt;同时，对于编辑工具，它与你看到的InfoQ.com几乎完全一样，除了不太花哨。因为我们设计的是同一个应用，所以使用相同的栈、几乎相同的API，在构建时我们把API分为两部分，对外开放的部分使用只读API，而对于编辑工具，我们使用可读/写存取API，不过本质上它们都是基于同一份源代码。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn4.infoq.com/styles/cn/i/icon-right.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; 你刚才提到使用WebWork和DWR处理前端。请问它们能够无缝集成吗，或者存在哪些挑战吗？ &lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-collapse.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;起初我们像往常一样启动了这个工程。我是说我们过去有一个处理DWR和WebWork应用的模型。但是最终我意识到，如果存在一个通用的方式访问和判断我们是应该通过DWR还是WebWork处理请求的话，对我和开发人员都省力。于是，我建立一个模型把这两个框架集成在一起。同时，通过这种方式我也对 DWR贡献了代码，所以现在大家都可以使用它，它非常通用，你可以立刻把它应用到Struts 2或类似的技术。如今，我们在编写代码处理HTTP时，终于能够延迟决定如何处理请求：是通过普通的请求/响应周期还是通过AJAX方式。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-right.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; 如果你有机会从头重新设计InfoQ.com，你会保留哪些，改变哪些？ &lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-collapse.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很多人提过这个问题，这可能是对我最具挑战性的问题。你能够想象，在同一个项目上工作两年半之后，你会有很多不同的想法来改变和提高一些东西。现在，我可能会说我不打算改变任何事情。我可能会尝试不同的方法来看一看它们的效果，但是到目前为止，我们在项目开始时选择的解决方案都工作的非常好。   &lt;br /&gt;我可能会研究一下如何标准化访问存储的API，在Hibernate和JCR之上创建一个通用的API，这样开发人员不再费心思考真正的数据到底存储到何处。这可能会涉及到内部API，不会变化很大。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-right.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; 能否提供一些关键的数据，比如InfoQ每天处理多少用户请求？其可扩展性呢？&lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-collapse.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前我能够对外公布的数据就是每月的独立访问用户量。你可以通过网站的左上角看到这个信息。目前我们每月的独立访问用户数大约是25万。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn4.infoq.com/styles/cn/i/icon-right.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; Hibernate真的可以扩展吗？这种扩展性有用吗？它是一个适合扩展的框架吗还是&amp;hellip;&amp;hellip;还有一个问题是你对数据库分区吗？ &lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-collapse.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们一个问题一个问题的看。到目前为止，我还没有在Hinernate的层面上发现任何问题。我是说我们甚至都没有优化查询。我们使用的就是 Hibernate自动生成的东西，性能也非常非常好。其次，由于性能不错目前我们还没有对数据分区，即使我们需要在后台处理海量的数据。我们一直在关注网站的性能，但是现在还不需要做些什么。另外一件关于架构的趣事是，唯一可能的瓶颈是我们使用的关系型数据库，因为其他存储内容的数据库位于外部服务器上，所以在内容存储方面可以线性扩展。如果我们遇到与关系型数据库相关的性能问题，我们可以很容易的创建一个MySQL数据库集群。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn3.infoq.com/styles/cn/i/icon-right.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; 你们在使用MySQL是吗？ &lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-collapse.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;是的，我们创建了几个只读访问的实例和一个可写的实例。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-right.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; 当数据量变得太大，你遇到过拷贝问题吗？比如从master拷贝到slaves？ &lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-collapse.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前我还没有注意到。是会有一点延迟，但不明显。通常我们采用逻辑划分数据。而不是物理划分。这样我们不需要针对每一个请求都访问数据库。我们能够在真正需要处理一个请求的时候缓存大量信息。访问数据库的通常都是跟踪信息或者处理广告。即使在集群上发布数据的时候存在一些延迟，也影响不到前端的性能。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn4.infoq.com/styles/cn/i/icon-right.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; 你们使用了多少缓存？在何处缓存数据，只有一个吗？使用分布式缓存吗？ &lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-collapse.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们使用本地缓存，单节点，对象缓存。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-right.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; 那么是在Hibernate之上还是之下？ &lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-collapse.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在Hibernate之上。事实上，如果你说我们存在两个缓存也是正确的，因为我们使用了Hibernate缓存，但是我们把Hibernate对象混合到了我们的对象中，因为它们太复杂了。我们采用合理的缓存并通过自己的API访问这些定制的对象。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn4.infoq.com/styles/cn/i/icon-right.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; 最近视频流系统重新做了设计。你能详细介绍一下吗，比如新的架构是什么样子的？ &lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-collapse.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最初我们使用了基于流的解决方案并由第三方实现。不幸的是，在方案设计完并开始动工之后不久，我们就发现第三方提供的服务要求我们和客户开放特定端口来访问Flash流。这对我们的大客户来说是一个很大的问题，例如像IBM这样的大公司，完全处在防火墙后面，他们绝不会为你打开特定的端口，而只是为了收看 InfoQ上的视频，哪怕这些视频很有价值。因此，我们开始考虑替代方案。   &lt;br /&gt;那时，我们注意到YouTube和其他视频服务提供商正在迁移到基于下载的视频方案上。与此同时，Amazon启动了目前很有名的服务，如S3和EC2。我们考虑使用这些开放服务（希望它们真的可靠）建立一个解决方案，新的架构就是基于Amazon S3和EC2服务。部署非常简单&amp;mdash;你只需要一个web服务器让你能够访问被索引的视频，和一些存储，仅此而已。如果你开始考虑这样一个解决方案，你可能几天之内就能创建。现在就是这么简单。确信Amazon服务可靠对我们非常重要，它们为S3服务提供的SLA让我们决定采用S3。现在我们正在等待EC2的相同服务。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn2.infoq.com/styles/cn/i/icon-right.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; 当你获得视频的时候：InfoQ不做其他工作吗，所有的视频都是适合Flash播放的编码格式吗？有时你是否需要使用第三方或者内部、外部的编码转换机制？ &lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-collapse.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单地说，这个视频处理是一个工作流。首先是获取原始视频，交给视频编辑专家来索引和创建元数据，然后我们拥有&amp;mdash;个或者说我们正试图拥有一个更加自动化的管理工作流的方法。所以，就你的问题而言，所有的一切都是在公司内部完成的。目前不是全自动化的，我们会在几个月之后争取实现，以方便编辑的工作，这些小步骤现在都是手工的，但它是一个内部流程。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-right.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; 你提到你把视频存储到Amazon服务上。你得到的是一个放了一些数据的容器，不管它多大、是什么，你只是把数据放进去，他们负责传递。有没有一个URL可以提供给客户或者用户，在他的浏览器上使用？从内部键值到URL的映射关系存在何处？你如何知道你把视频存在哪里了？ &lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-collapse.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们有S3存储还有EC2服务器。为了能够提供视频服务，我们需要从S3上获取视频。因此，我们在S3容器和本地存储之间建立了一个同步机制，然后一切都通过此处访问。现在，解释一下如何获取资源。我们的内容数据库会提供资源的名字，因此所有我们存储在JCR中的元数据和与内容相关的信息都存在该数据库中。然后，我们提供一个ID，数据库里给出获取该视频的映射关系。即使是S3或者VitalStream第三方支持，都是一样的。说到底，就是基于ID的资源查找。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-right.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; 你刚才说把Hibernate对象映射到其它对象上，为什么要这样做？ &lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-collapse.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;抱歉让你误会了。我刚才想说的是，我们的模型要比只从Hibernate得到的更丰富。因此我们把不同的对象组合到一起建立一个代表一个页面或者类似事物的对象。这是一个聚合过程，而不是从模型到DTO的迁移。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn3.infoq.com/styles/cn/i/icon-right.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; 你是否使用了Hibernate提供的关联机制？例如，我创建了一个用户。一个用户可以有多种角色（你可以配置Hibernate来获取用户和全部角色）。Hibernate提供了这种功能。你说在更高一层作了聚合，这是否意味着你只能在更高的层次上获取单实体或者实体集合？ &lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-collapse.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我提到过我们采用了不同的存储。我需要从所有存储中获取数据并组合成一个页面。我们使用了Hibernate的全部特性，比如延迟取、快速取、联合取等一切特性。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn2.infoq.com/styles/cn/i/icon-right.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; 所以聚合意味着你不得不组合来自不同存储的数据。 &lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-collapse.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;完全正确。如果你看一看网页，你会努力把它描述成一个模型，页面有内容组成、广告元素、图片和其他类似数据&amp;mdash;所有这些代表了我们模型的一部分。为了表示整个页面，我们需要聚合所有这些小部件，比如广告元素、内容，聚合的方式很有趣，因为首先使用内容，然后在与内容相关的元数据的基础上，我们努力推断出适合发布何种广告。简单的说，我们有一个核心模型、带有元数据的内容，然后利用其他的数据来修饰这个核心模型。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn2.infoq.com/styles/cn/i/icon-right.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; InfoQ未来有什么规划吗？如何进行开发的？是围绕一个需求清单吗？ &lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-collapse.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;考虑到我们公司非常虚拟化，我是说全球的工作人员，分布在不同的地点和时区，我们围绕着需求清单建立了一个定制过程，清单上按照优先级列举了未来几年内我们需要实现的事情，然后推动几个迭代过程，我们会讨论细节。针对你的问题，我的需求清单有七页之长。这些新功能迟早都会实现。我们还有一些新的想法没有写在清单上，但是我想给大家一个惊喜，我们现在有很多竞争者，所以我们将保守秘密。上一次，视频系统的重新实现，我们做了初稿并邀请用户浏览和评论，给我们反馈，以后主要的功能我们都会采用相同的流程。如果你在InfoQ上注册，就有机会帮助我们在未来实现新特性。欢迎注册。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-right.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; 你如何实现网站搜索？采用了哪些技术？ &lt;a href=&quot;http://www.infoq.com/&quot;&gt;&lt;img src=&quot;http://cdn1.infoq.com/styles/cn/i/icon-collapse.gif&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我在采访开始的时候曾提到过JCR API提供了全文索引。因此，我们具备这项功能。但是目前我们使用Google搜索，因为我们发现这样性能会稍微好一点，运行的也非常好。我们正在考虑将来把这两项技术结合在一起提供高级搜索，能够使用特定的查询语言来搜索网站，你知道，我们对内容加了标签等，正好可以支持这种搜索。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Android文档（一）——什么是Android?</title>
   <link href="http://jiang-bo.github.com/blog/2009/07/16/post"/>
   <updated>2009-07-16T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/07/16/post</id>
   <content type="html">&lt;p&gt;&lt;!--  [if !mso]&amp;gt;
&amp;lt;mce:style&amp;gt;&amp;lt;!--
v/:* {behavior:url(#default#VML);}
o/:* {behavior:url(#default#VML);}
w/:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
--&gt;
&lt;!-- [endif]--&gt;&lt;!--  [if gte mso 9]&amp;gt;&amp;lt;xml&amp;gt;
 &amp;lt;w:WordDocument&amp;gt;
  &amp;lt;w:View&amp;gt;Normal&amp;lt;/w:View&amp;gt;
  &amp;lt;w:Zoom&amp;gt;0&amp;lt;/w:Zoom&amp;gt;
  &amp;lt;w:PunctuationKerning /&amp;gt;
  &amp;lt;w:DrawingGridVerticalSpacing&amp;gt;7.8 磅&amp;lt;/w:DrawingGridVerticalSpacing&amp;gt;
  &amp;lt;w:DisplayHorizontalDrawingGridEvery&amp;gt;0&amp;lt;/w:DisplayHorizontalDrawingGridEvery&amp;gt;
  &amp;lt;w:DisplayVerticalDrawingGridEvery&amp;gt;2&amp;lt;/w:DisplayVerticalDrawingGridEvery&amp;gt;
  &amp;lt;w:ValidateAgainstSchemas /&amp;gt;
  &amp;lt;w:SaveIfXMLInvalid&amp;gt;false&amp;lt;/w:SaveIfXMLInvalid&amp;gt;
  &amp;lt;w:IgnoreMixedContent&amp;gt;false&amp;lt;/w:IgnoreMixedContent&amp;gt;
  &amp;lt;w:AlwaysShowPlaceholderText&amp;gt;false&amp;lt;/w:AlwaysShowPlaceholderText&amp;gt;
  &amp;lt;w:Compatibility&amp;gt;
   &amp;lt;w:SpaceForUL /&amp;gt;
   &amp;lt;w:BalanceSingleByteDoubleByteWidth /&amp;gt;
   &amp;lt;w:DoNotLeaveBackslashAlone /&amp;gt;
   &amp;lt;w:ULTrailSpace /&amp;gt;
   &amp;lt;w:DoNotExpandShiftReturn /&amp;gt;
   &amp;lt;w:AdjustLineHeightInTable /&amp;gt;
   &amp;lt;w:BreakWrappedTables /&amp;gt;
   &amp;lt;w:SnapToGridInCell /&amp;gt;
   &amp;lt;w:WrapTextWithPunct /&amp;gt;
   &amp;lt;w:UseAsianBreakRules /&amp;gt;
   &amp;lt;w:DontGrowAutofit /&amp;gt;
   &amp;lt;w:UseFELayout /&amp;gt;
  &amp;lt;/w:Compatibility&amp;gt;
  &amp;lt;w:BrowserLevel&amp;gt;MicrosoftInternetExplorer4&amp;lt;/w:BrowserLevel&amp;gt;
 &amp;lt;/w:WordDocument&amp;gt;
&amp;lt;/xml&amp;gt;&amp;lt;![endif]--&gt;&lt;!--  [if gte mso 9]&amp;gt;&amp;lt;xml&amp;gt;
 &amp;lt;w:LatentStyles DefLockedState=&quot;false&quot; LatentStyleCount=&quot;156&quot;&amp;gt;
 &amp;lt;/w:LatentStyles&amp;gt;
&amp;lt;/xml&amp;gt;&amp;lt;![endif]--&gt;&lt;!--  [if !mso]&amp;gt;
&amp;lt;object
 classid=&quot;clsid:38481807-CA0E-42D2-BF39-B33AF135CC4D&quot; id=ieooui&amp;gt;
&amp;lt;/object&amp;gt;
&amp;lt;mce:style&amp;gt;&amp;lt;!--
st1/:*{behavior:url(#ieooui) }
--&gt;
&lt;!-- [endif]--&gt;
&lt;!--  [if gte mso 10]&amp;gt;
&amp;lt;mce:style&amp;gt;&amp;lt;!--
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:普通表格;
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:&quot;&quot;;
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:&quot;Times New Roman&quot;;
	mso-fareast-font-family:&quot;Times New Roman&quot;;
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
--&gt;
&lt;!-- [endif]--&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Android&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;是一个为移动设备设计的软件栈，包括操作系统，中间件和关键应用。&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Android SDK&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;提供了使用&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;在&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Andorid&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;平台上开发应用所需的工具和&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;API&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;。&lt;/span&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;span style=&quot;font-size: 15pt; line-height: 173%; font-family: 宋体;&quot;&gt;特性&lt;/span&gt;
&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21.1pt;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;应用框架&lt;/span&gt;
&lt;/strong&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;：&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;提供了组件的复用和置换&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21.1pt;&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;Dalvik&lt;/span&gt;
&lt;/strong&gt;
&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;虚拟机&lt;/span&gt;
&lt;/strong&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;：&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;针对移动设备进行了优化&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21.1pt;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;内置浏览器&lt;/span&gt;
&lt;/strong&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;：&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;基于开源的&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;WebKit&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;（&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;webkit.org&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;）引擎&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21.1pt;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;优化图形支持&lt;/span&gt;
&lt;/strong&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;：&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;包括自定义的&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;2D&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;图形库；&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;3D&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;图形基于&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;OpenGL ES1.0&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;标准&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21.1pt;&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;SQLite&lt;/span&gt;
&lt;/strong&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;：&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;用于结构话的数据存储&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21.1pt;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;多媒体支持&lt;/span&gt;
&lt;/strong&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;：支持常用的音频视频和图像格式（&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;MPEG4&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt; H264&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;MP3&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;AAC&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;AMR&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;JPG&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;PNG&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;GIF&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;）&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21.1pt;&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;GSM&lt;/span&gt;
&lt;/strong&gt;
&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;技术&lt;/span&gt;
&lt;/strong&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;：依赖于具体硬件实现&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21.1pt;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;蓝牙，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;EDGE&lt;/span&gt;
&lt;/strong&gt;
&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;3G&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;,WiFi:&lt;/span&gt;
&lt;/strong&gt;
&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;依赖于具体硬件&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21.1pt;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;摄像，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;GPS&lt;/span&gt;
&lt;/strong&gt;
&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;，加速：&lt;/span&gt;
&lt;/strong&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;依赖于硬件&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21.1pt;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;丰富的开发环境&lt;/span&gt;
&lt;/strong&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;：包括设备模拟器，调试工具，内存和性能分析，以及&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Eclipse IDE&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;插件&lt;/span&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;span style=&quot;font-size: 15pt; line-height: 173%;&quot; lang=&quot;EN-US&quot;&gt;Android&lt;/span&gt;
&lt;span style=&quot;font-size: 15pt; line-height: 173%; font-family: 宋体;&quot;&gt;架构&lt;/span&gt;
&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;下图显示了&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Android OS&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;的主要组件。下面每段对各个模块进行了详细描述&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3&gt;&lt;span style=&quot;font-size: 15pt; line-height: 173%; font-family: 宋体;&quot;&gt;&lt;img src=&quot;http://p.blog.csdn.net/images/p_blog_csdn_net/JiangBo_HIT/EntryImages/20090716/system-architecture.jpg&quot; alt=&quot;&quot; width=&quot;713&quot; height=&quot;512&quot; /&gt;
&lt;/span&gt;
&lt;/h3&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;!--  [if !mso]&amp;gt;
&amp;lt;mce:style&amp;gt;&amp;lt;!--
v/:* {behavior:url(#default#VML);}
o/:* {behavior:url(#default#VML);}
w/:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
--&gt;
&lt;!-- [endif]--&gt;&lt;!--  [if gte mso 9]&amp;gt;&amp;lt;xml&amp;gt;
 &amp;lt;w:WordDocument&amp;gt;
  &amp;lt;w:View&amp;gt;Normal&amp;lt;/w:View&amp;gt;
  &amp;lt;w:Zoom&amp;gt;0&amp;lt;/w:Zoom&amp;gt;
  &amp;lt;w:PunctuationKerning /&amp;gt;
  &amp;lt;w:DrawingGridVerticalSpacing&amp;gt;7.8 磅&amp;lt;/w:DrawingGridVerticalSpacing&amp;gt;
  &amp;lt;w:DisplayHorizontalDrawingGridEvery&amp;gt;0&amp;lt;/w:DisplayHorizontalDrawingGridEvery&amp;gt;
  &amp;lt;w:DisplayVerticalDrawingGridEvery&amp;gt;2&amp;lt;/w:DisplayVerticalDrawingGridEvery&amp;gt;
  &amp;lt;w:ValidateAgainstSchemas /&amp;gt;
  &amp;lt;w:SaveIfXMLInvalid&amp;gt;false&amp;lt;/w:SaveIfXMLInvalid&amp;gt;
  &amp;lt;w:IgnoreMixedContent&amp;gt;false&amp;lt;/w:IgnoreMixedContent&amp;gt;
  &amp;lt;w:AlwaysShowPlaceholderText&amp;gt;false&amp;lt;/w:AlwaysShowPlaceholderText&amp;gt;
  &amp;lt;w:Compatibility&amp;gt;
   &amp;lt;w:SpaceForUL /&amp;gt;
   &amp;lt;w:BalanceSingleByteDoubleByteWidth /&amp;gt;
   &amp;lt;w:DoNotLeaveBackslashAlone /&amp;gt;
   &amp;lt;w:ULTrailSpace /&amp;gt;
   &amp;lt;w:DoNotExpandShiftReturn /&amp;gt;
   &amp;lt;w:AdjustLineHeightInTable /&amp;gt;
   &amp;lt;w:BreakWrappedTables /&amp;gt;
   &amp;lt;w:SnapToGridInCell /&amp;gt;
   &amp;lt;w:WrapTextWithPunct /&amp;gt;
   &amp;lt;w:UseAsianBreakRules /&amp;gt;
   &amp;lt;w:DontGrowAutofit /&amp;gt;
   &amp;lt;w:UseFELayout /&amp;gt;
  &amp;lt;/w:Compatibility&amp;gt;
  &amp;lt;w:BrowserLevel&amp;gt;MicrosoftInternetExplorer4&amp;lt;/w:BrowserLevel&amp;gt;
 &amp;lt;/w:WordDocument&amp;gt;
&amp;lt;/xml&amp;gt;&amp;lt;![endif]--&gt;&lt;!--  [if gte mso 9]&amp;gt;&amp;lt;xml&amp;gt;
 &amp;lt;w:LatentStyles DefLockedState=&quot;false&quot; LatentStyleCount=&quot;156&quot;&amp;gt;
 &amp;lt;/w:LatentStyles&amp;gt;
&amp;lt;/xml&amp;gt;&amp;lt;![endif]--&gt;
&lt;!--  [if gte mso 10]&amp;gt;
&amp;lt;mce:style&amp;gt;&amp;lt;!--
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:普通表格;
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:&quot;&quot;;
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:&quot;Times New Roman&quot;;
	mso-fareast-font-family:&quot;Times New Roman&quot;;
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
--&gt;
&lt;!-- [endif]--&gt;&lt;span style='font-size: 10.5pt; font-family: &quot;Times New Roman&quot;;' lang=&quot;EN-US&quot;&gt;&lt;!--  [if gte vml 1]&amp;gt;&amp;lt;v:shapetype id=&quot;_x0000_t75&quot; coordsize=&quot;21600,21600&quot;
 o:spt=&quot;75&quot; o:preferrelative=&quot;t&quot; path=&quot;m@4@5l@4@11@9@11@9@5xe&quot; filled=&quot;f&quot;
 stroked=&quot;f&quot;&amp;gt;
 &amp;lt;v:stroke joinstyle=&quot;miter&quot; /&amp;gt;
 &amp;lt;v:formulas&amp;gt;
  &amp;lt;v:f eqn=&quot;if lineDrawn pixelLineWidth 0&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;sum @0 1 0&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;sum 0 0 @1&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;prod @2 1 2&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;prod @3 21600 pixelWidth&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;prod @3 21600 pixelHeight&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;sum @0 0 1&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;prod @6 1 2&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;prod @7 21600 pixelWidth&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;sum @8 21600 0&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;prod @7 21600 pixelHeight&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;sum @10 21600 0&quot; /&amp;gt;
 &amp;lt;/v:formulas&amp;gt;
 &amp;lt;v:path o:extrusionok=&quot;f&quot; gradientshapeok=&quot;t&quot; o:connecttype=&quot;rect&quot; /&amp;gt;
 &amp;lt;o:lock v:ext=&quot;edit&quot; aspectratio=&quot;t&quot; /&amp;gt;
&amp;lt;/v:shapetype&amp;gt;&amp;lt;v:shape id=&quot;_x0000_i1025&quot; type=&quot;#_x0000_t75&quot; style='width:414.75pt;
 height:278.25pt'&amp;gt;
 &amp;lt;v:imagedata src=&quot;file:///C:/DOCUME~1/jiangbo/LOCALS~1/Temp/msohtml1/01/clip_image001.png&quot; mce_src=&quot;file:///C:/DOCUME~1/jiangbo/LOCALS~1/Temp/msohtml1/01/clip_image001.png&quot;
  o:title=&quot;&quot; /&amp;gt;
&amp;lt;/v:shape&amp;gt;&amp;lt;![endif]--&gt;&lt;!--  [if !vml]--&gt;&lt;!--  [endif]--&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-align: center;&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;!--  [if gte vml 1]&amp;gt;&amp;lt;v:shapetype
 id=&quot;_x0000_t75&quot; coordsize=&quot;21600,21600&quot; o:spt=&quot;75&quot; o:preferrelative=&quot;t&quot;
 path=&quot;m@4@5l@4@11@9@11@9@5xe&quot; filled=&quot;f&quot; stroked=&quot;f&quot;&amp;gt;
 &amp;lt;v:stroke joinstyle=&quot;miter&quot; /&amp;gt;
 &amp;lt;v:formulas&amp;gt;
  &amp;lt;v:f eqn=&quot;if lineDrawn pixelLineWidth 0&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;sum @0 1 0&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;sum 0 0 @1&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;prod @2 1 2&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;prod @3 21600 pixelWidth&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;prod @3 21600 pixelHeight&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;sum @0 0 1&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;prod @6 1 2&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;prod @7 21600 pixelWidth&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;sum @8 21600 0&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;prod @7 21600 pixelHeight&quot; /&amp;gt;
  &amp;lt;v:f eqn=&quot;sum @10 21600 0&quot; /&amp;gt;
 &amp;lt;/v:formulas&amp;gt;
 &amp;lt;v:path o:extrusionok=&quot;f&quot; gradientshapeok=&quot;t&quot; o:connecttype=&quot;rect&quot; /&amp;gt;
 &amp;lt;o:lock v:ext=&quot;edit&quot; aspectratio=&quot;t&quot; /&amp;gt;
&amp;lt;/v:shapetype&amp;gt;&amp;lt;v:shape id=&quot;_x0000_i1025&quot; type=&quot;#_x0000_t75&quot; style='width:414.75pt;
 height:278.25pt'&amp;gt;
 &amp;lt;v:imagedata src=&quot;file:///C:/DOCUME~1/jiangbo/LOCALS~1/Temp/msohtml1/01/clip_image001.png&quot; mce_src=&quot;file:///C:/DOCUME~1/jiangbo/LOCALS~1/Temp/msohtml1/01/clip_image001.png&quot;
  o:title=&quot;&quot; /&amp;gt;
&amp;lt;/v:shape&amp;gt;&amp;lt;![endif]--&gt;&lt;!--  [if !vml]--&gt;&lt;!--  [endif]--&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;span style=&quot;font-size: 15pt; line-height: 173%; font-family: 宋体;&quot;&gt;应用&lt;/span&gt;
&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Android&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;封装了一组核心应用，包括&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Email&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;客户端，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;SMS&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;应用，日历，地图，浏览器，联系人和其他应用。所有的应用都是有&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;编写。&lt;/span&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;span style=&quot;font-size: 15pt; line-height: 173%; font-family: 宋体;&quot;&gt;应用框架&lt;/span&gt;
&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;开发者能够访问所有核心应用所使用的框架&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;API&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;。应用架构被设计成简洁的组建复用；任何应用发布本身的兼容性，任何其他的应用都可一利用这些兼容性（遵循框架的安全原则）。这种机制使得组建可以被其它用户置换。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;应用之下是一系列服务和系统，包括：&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.&lt;/span&gt;
&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;丰富的可扩展的视图（&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;View&lt;/span&gt;
&lt;/strong&gt;
&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;）&lt;/span&gt;
&lt;/strong&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;集合可以被用来构建应用，包括&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;lists, grids, text
boxes,buttons,&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;以及嵌入式浏览器&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.&lt;/span&gt;
&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;内容提供者&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;(Content Providers)&lt;/span&gt;
&lt;/strong&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;能够是应用访问来自其他应用的数据，例如联系人（&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Contacts&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;）&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;或者与其他应用共享数据&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3&lt;strong&gt;.&lt;/strong&gt;
&lt;/span&gt;
&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;资源管理器（&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Resource Manager)&lt;/span&gt;
&lt;/strong&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;，支持访问非代码资源，例如本地字符，图像，布局文件&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;4.&lt;/span&gt;
&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;消息管理器（&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Notification Manager&lt;/span&gt;
&lt;/strong&gt;
&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;）&lt;/span&gt;
&lt;/strong&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;使得应用能够在状态栏中显示自定义的警告&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;5&lt;strong&gt;.&lt;/strong&gt;
&lt;/span&gt;
&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;活动管理器（&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Activity Manager)&lt;/span&gt;
&lt;/strong&gt;
&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;管理应用的生命周期，提供通用的导航返回栈。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;nbsp;&lt;/span&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;span style=&quot;font-size: 15pt; line-height: 173%; font-family: 宋体;&quot;&gt;库&lt;/span&gt;
&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Android&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;包括了一组被各个组件使用&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;C/C++&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;库。这些兼容性通过&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Android&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;应用框架暴露给开发者。下面列出一些核心库：&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.&lt;/span&gt;
&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;系统&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;C&lt;/span&gt;
&lt;/strong&gt;
&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;库（&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;System C
library&lt;/span&gt;
&lt;/strong&gt;
&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;）&lt;/span&gt;
&lt;/strong&gt;
&lt;span lang=&quot;EN-US&quot;&gt;-&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;一个基于&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;BSD&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;实现的标准&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;C&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;系统库（&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;libc&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;），支持嵌入式&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;linux&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;的所有设备。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&lt;strong&gt;.&lt;/strong&gt;
&lt;/span&gt;
&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;多媒体库（&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Media Libraries&lt;/span&gt;
&lt;/strong&gt;
&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;）&lt;/span&gt;
&lt;/strong&gt;
&lt;span lang=&quot;EN-US&quot;&gt;-&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;基于&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;PacketVideo&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;的&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;OpenCORE&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;；这个库支持播放和录制多种流行视频和音频格式，包括静态图像格式。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21.1pt;&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.&lt;/span&gt;
&lt;/strong&gt;
&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;表面管理器（&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Surface Manager&lt;/span&gt;
&lt;/strong&gt;
&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;）&lt;/span&gt;
&lt;/strong&gt;
&lt;span lang=&quot;EN-US&quot;&gt;-&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;管理访问显示子系统与多种应用的&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;2D&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;和&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;3D&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;图形层无缝连接。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21.1pt;&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.LibWebCore-&lt;/span&gt;
&lt;/strong&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;一个现代的&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;web&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;浏览器引擎，支持&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Android&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;浏览器和嵌入式&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Web&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;视图。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;4&lt;strong&gt;.SGL-&lt;/strong&gt;
&lt;/span&gt;
&lt;strong&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;底层的&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;2D&lt;/span&gt;
&lt;/strong&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;图形引擎。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21.1pt;&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;5.3DLibraries&lt;/span&gt;
&lt;/strong&gt;
&lt;span lang=&quot;EN-US&quot;&gt;-&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;基于&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;OpenGL ES1.0&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;实现的&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;API&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;；该库使用&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;3D&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;硬件加速（如果硬件支持）或这高度优化的软件渲染。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21.1pt;&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;6.FreeType&lt;/span&gt;
&lt;/strong&gt;
&lt;span lang=&quot;EN-US&quot;&gt;-&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;位图和向量字体渲染。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21.1pt;&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;7.SQLite&lt;/span&gt;
&lt;/strong&gt;
&lt;span lang=&quot;EN-US&quot;&gt;-&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;一个强大的轻量级关系数据库引擎，可以被所有应用使用&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;nbsp;&lt;/span&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;span style=&quot;font-size: 15pt; line-height: 173%;&quot; lang=&quot;EN-US&quot;&gt;Android&lt;/span&gt;
&lt;span style=&quot;font-size: 15pt; line-height: 173%; font-family: 宋体;&quot;&gt;运行时环境&lt;/span&gt;
&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Anroid&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;包括一系列的核心库，这些库提供了绝大多数&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;核心库所需的功能。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;每个&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Android&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;应用是一个独立运行的进程，在&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Dalvik&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;虚拟机中有独立的例程。&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Dalvik&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;被实现用于在一个设备上有效的运行多个虚拟机。&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Dalvik&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;虚拟机的可执行文件&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Dalvik Executeable(.dex)&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;被优化的占用最小的内存空间。虚拟机以注册为基础，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;类编译的字节码被&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;dx&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;工具优化为&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;.dex&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;文件。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Dalvik VM&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;底层依赖于&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Linux&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;内核，&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;linux&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;内核为其提供线程和低级内存管理。&lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;nbsp;&lt;/span&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;span style=&quot;font-size: 15pt; line-height: 173%;&quot; lang=&quot;EN-US&quot;&gt;Linux&lt;/span&gt;
&lt;span style=&quot;font-size: 15pt; line-height: 173%; font-family: 宋体;&quot;&gt;内核&lt;/span&gt;
&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot; style=&quot;text-indent: 21pt;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Android&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;基于&lt;/span&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Linux2.6&lt;/span&gt;
&lt;span style=&quot;font-family: 宋体;&quot;&gt;内核所提供的服务，包括安全，内存管理，进程管理，网络堆栈，以及驱动模型。内核同时扮演了一个介于硬件和其余软件栈之间的一个抽象层。&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>［转载］20年嵌入式领域开发经验精华</title>
   <link href="http://jiang-bo.github.com/blog/2009/06/29/post"/>
   <updated>2009-06-29T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/06/29/post</id>
   <content type="html">&lt;p&gt;来源：www.armjishu.com  &lt;br /&gt;
 作者：jesse  &lt;br /&gt;
 转载请注明出处  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp;&lt;span style=&quot;color: #000000;&quot;&gt; 首先，如果你有幸看到这篇文章，千万不要试图在2个小时内阅读完，就算你2个小时阅读完，我相信你也不会
理解里面讲解的精华之处，我相信，你应该将此文章，慢慢品尝，这绝对是一篇需要品尝2~3天，再结合自己过往的经验，加上自己的思考，我相信会对你不仅仅
是技术能力，甚至包括整体的思维方式都会有一个非常大的提高。&lt;br /&gt;
&lt;br /&gt;
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp;我写这篇文章的目的，是用本人20年的嵌入式经验呈现给大家一副完整的产品，项目开发蓝图，用本人多年经的历总结了一些教训无私的分享给各位，希望各位
今后能站在本人的肩膀之上，少走弯路，多为公司，为个人多做贡献，那我的愿望就达到了，也同时希望能看到大家反馈和回复，留个脚印，留下你的见解和智慧，
为后人乘凉打点基础，先在这谢谢各位了。&lt;br /&gt;
&lt;br /&gt;
那么由此开始我们充满知识的旅程吧，最重要的一点，就是在一个产品或项目的开发过程中，如果没有明确的目标，那么成功将无从谈起，做任何事的第一步必须明确目标。&lt;br /&gt;
&lt;br /&gt;
&amp;nbsp; &amp;nbsp; 与日常生活中的大多数事务一样，设计一个嵌入式产品的过程也必须从确定目标开始，对生产的产品进行明确定义。对产品进行定义主要是对产品是什么和能有什么功能进行描述，其次是在我们的整个开发过程中，应该要撰写一些开发文档，大概的框架的如下：&lt;/span&gt;
&lt;br /&gt;
&lt;br /&gt;
 1）产品需求文档：描述产品的特性  &lt;br /&gt;
 2）功能需求文档：描述产品必须具备的功能  &lt;br /&gt;
 3）工程说明文档：描述系统实现的方法和满足需求的手段  &lt;br /&gt;
 4）硬件说明文档：对有关硬件进行描述  &lt;br /&gt;
 5）软件或固件说明文档：描述特定处理器下设计微程序以及固件的方法  &lt;br /&gt;
 6）测试说明文档：描述必须测试的项目和验证系统正常运行的方法  &lt;br /&gt;
&lt;br /&gt;
 1.需求定义  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; 需求定义用来描述产品的基本功能，对于公司来说，需求一般由该公司的市场销售部门或该公司的主要客户来制定；而对小公司或爱好者(就像armjishu.com里的爱好者一样)，技术人员可以自己负责定义需求，并撰写成文档。  &lt;br /&gt;
&lt;br /&gt;
 通常需求定义是围绕以下几个因素而来：  &lt;br /&gt;
&lt;br /&gt;
 1）系统的用途（定义需要系统实现的各种功能）  &lt;br /&gt;
&lt;br /&gt;
 2）实际输入输出是何种方式实现的（为元器件的选型做参考）  &lt;br /&gt;
&lt;br /&gt;
 3）系统是否需要操作界面（涉及软件层操作系统的选型）  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; 其实对小型的嵌入式产品来说，定义需求是非常关键的，因为需求清楚了，就可以避免后续开发过程中出现的诸如随机存储器（RAM）容量不足或所选的CPU速度不能满足处理的需要等一系列问题。  &lt;br /&gt;
&lt;br /&gt;
 ----------------------------------------------------------------------------------------------------------  &lt;br /&gt;
 下面举个简单的实际例子，供大家来参考：  &lt;br /&gt;
&lt;br /&gt;
 系统描述：用于从化温泉的水泵换水系统  &lt;br /&gt;
 电源输入：使用来自于变压器的9V~12V直流电  &lt;br /&gt;
 水泵功率：375W  &lt;br /&gt;
 1）使用单相交流电机，由机械电气进行控制  &lt;br /&gt;
 2）如果温泉池处于低水位，则输入开关闭合信号，以禁止水泵继续运行  &lt;br /&gt;
 3）用户可以自由设置水泵运行或关闭的时间长度  &lt;br /&gt;
 4）除了自动设置控制外，还需要提供一种人工装置来允许维护人员灵活控制水泵进行维修  &lt;br /&gt;
 5）水泵开启/关闭/人工干预的时间可以30分钟为单位，在30分钟到23小时的范围内进行调节  &lt;br /&gt;
 6）显示设备可以指示水泵的开关状态，剩余时间，以及水泵是否处于人工干预模式  &lt;br /&gt;
 7）具备监视低水位的功能，并显示在屏幕上  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; 如果需要商用，那么除了上面给出的功能要求外，其设计文档中还要包括电磁干扰（EMI）和电磁兼容性（EMC）认证、安全认证以及使用环境（包括环境温度、湿度、盐雾腐蚀等）等方面的需求。  &lt;br /&gt;
&lt;br /&gt;
 实际上，以上的需求确定之后，接下来就是要考虑选择一款合适的CPU来满足和实现系统的功能，那么我们就要将上述7点用户能够理解的需求转化成我们专业领域的需求，转化如下，大家可以参考一下：  &lt;br /&gt;
&lt;br /&gt;
 a.处理或更新输入输出信号的速率究竟需要多快？  &lt;br /&gt;
解释：目前嵌入式处理器的主频一般都在几十兆到几百兆不等，单片机的主频一般是几十兆，ARM处理器可以到几百兆；我们主要看这个产品是否需要对大量数据
进行处理，或是否需要对缓冲区进行频繁操作，是否有类似的占用CPU资料的工作要做，这就决定我们要选择一款合适的处理器来让该产品得到最佳的性能。 &lt;br /&gt;
&lt;br /&gt;
 b.是否可使用单片集成电路（专用IC）或FPGA来完成数据处理？  &lt;br /&gt;
 解释：如果可以的话，就不一定要选择处理器来做，用这些专业芯片就能替代  &lt;br /&gt;
&lt;br /&gt;
 c.系统是否有大量的用户输入输出操作（如对开关和显示设备进行频繁操作）？  &lt;br /&gt;
 解释：如果有的话，要在处理器选型的时候考虑这些因素，选择一款能够满足以上要求的CPU  &lt;br /&gt;
&lt;br /&gt;
 d.系统与其他外部设备之间需要使用何种接口？  &lt;br /&gt;
 解释：这也是需要评估处理器的一个关键问题，选择具备这些接口功能的处理器会方便于我们的电路设计以及软件编程  &lt;br /&gt;
&lt;br /&gt;
 e.设计完成后是否有可能需要进行改动，或在设计过程中系统需求是否可能出现变化？我们的设计是否能适应系统需求的变化？  &lt;br /&gt;
解释:要避免选择的处理器刚好满足当前要求，这样当以后事务要求逐渐提高，处理器性能如果还有一定空间的话，那么就可以重用目前的产品；第二个就是要选择
不会即将停产的芯片，很多处理器用得很广乏，可以借鉴的资料也很多，但是很可能这款芯片已经在市场上流行很长时间了，芯片厂商已经推出更新换代的替代品
了，如果你选择了这款芯片，很可能1，2年后就买不到这款处理器芯片了，导致不得不重新选择新的处理器，重新设计产品，这样的既耗费时间，金钱，更消耗人
力，延误市场的战机。 &lt;br /&gt;
 ----------------------------------------------------------------------------------------------------------  &lt;br /&gt;
&lt;br /&gt;
 2.处理器的选择  &lt;br /&gt;
&lt;br /&gt;
 1.1.需要使用的I/O管脚数量  &lt;br /&gt;
&lt;br /&gt;
&amp;nbsp;
多数处理器都是使用内存和外部管脚来控制输入输出设备的，通常处理器都会有内置ROM和RAM的，如果内置的内存就已经满足需要，那么处理器就可以节省产
生引用外部存储器信号的引脚，这样处理器可为输入输出提供较多的设备管脚（某些处理器支持外部RAM或ROM的使用，但对外部存储器进行访问时，处理器一
般需要占用8条到10条I/O管脚）。 &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 还有，有些处理器带有专用的内部定时时钟，这类时钟也需要使用一个端口管脚来实现某些定时功能；某些处理器中还具有漏极输出和高电流输出能力，可以方便的直接驱动继电器或电磁铁线圈，而不再需要额外驱动硬件的支持。  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 当对处理器I/O管脚进行计数时，我们一定要把使用处理器内部功能（如串行接口和定时器等）时限制使用的某些管脚考虑在内。  &lt;br /&gt;
&lt;br /&gt;
 1.2.需要使用的接口数量  &lt;br /&gt;
 &amp;nbsp;  &lt;br /&gt;
 &amp;nbsp; 嵌入式处理器的主要功能是与应用环境中的硬件进行交互操作，这不仅需要外部硬件对接口具有实时处理能力，而且还要求处理器必须以足够快的速度对接口数据进行有效处理。  &lt;br /&gt;
&lt;br /&gt;
&amp;nbsp;
举例来说，AT91RM9200是ATMEL公司出品的一款工业级ARM9微处理器，它基于ARM920T核心，处理速度可达200MIPS，同时处理器
内部配置了USB、Ethernet
、支持RS485的红外串口、IIC、SPI、SSC等输出接口，其目的是更方便的利用这些接口开发出嵌入式产品。 &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp;
需要注意的是，由于许多处理器具有的局限性没有在处理器技术资料中给予足够的说明，因此一定要仔细阅读处理器的指标说明。例如，在阅读资料的过程中发现，
该资料可能会说明其串行接口可以在最高波特率下工作，但仔细研究该处理器的指标数据时，可能会发现并非该串口接口的所有操作模式都可以在最大波特率下运
行。 &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 深入了解并明确接口要求的方法：可以自己动手编写一些程序来对接口进行实际测试，以确认某种处理器是否可以满足应用的要求；因为，确认某个处理器是否可以满足接口要求并非是一件简单的任务。  &lt;br /&gt;
&lt;br /&gt;
 1.3.需要使用的内存容量  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 决定内存容量的大小是嵌入式产品设计过程中的一个基本步骤，如果对所需内存容量估计过高，那么我们就有可能会选择成本较高的解决方案；反之，如果低估了所需内存容量，就有可能因系统需要重新设计而导致项目不能按时完工。  &lt;br /&gt;
&lt;br /&gt;
&amp;nbsp;
a.RAM和ROM的区别：存储器分为随机存储器（RAM）和只读存储器（ROM）两种。其中ROM通常用来固化存储一些生产厂家写入的程序或数据，用于
启动电脑和控制电脑的工作方式。而RAM则用来存取各种动态的输入输出数据、中间计算结果以及与外部存储器交换的数据和暂存数据。设备断电后，RAM中存
储的数据就会丢失。 &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; b.随即存储器（RAM）的选择：RAM容量的预测是比较直观的，我们只需把所有变量数目与所有内部缓冲区的容量以及先入先出（FIFO）队列长度和堆栈长度直接相加，就能得到所需RAM容量的总数。  &lt;br /&gt;
 &amp;nbsp; &amp;nbsp; 如果所需内存容量超出这类处理器的寻址范围，那么只能通过增加外部RAM来满足需求；然而，增加外部RAM的同时将会占用一定数量的I/O管脚来对扩展内存进行寻址，这种扩展往往会影响到处理器来实现应用的初衷。  &lt;br /&gt;
 &amp;nbsp; &amp;nbsp; 需要注意的一个问题是，某些微处理器限制RAM的使用，这种限制的目的是为了借用部分内存存储器作为内部寄存器组使用。除了以上因素外，所使用的开发语言也对所需RAM容量有一定的影响，某些效率较低的编译程序可能会占用大量宝贵的RAM空间。  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; c.只读存储器（ROM）的选择：系统所需ROM的大小应该是系统程序代码与所有基于ROM的数据表容量之和。预测所需ROM空间容量比较困难的部分是预测程序代码的长度，解决这类问题的方法只能是随着经验的逐步积累来提高预测精度。  &lt;br /&gt;
 &amp;nbsp; &amp;nbsp; 然而，最重要的并不是精确计算程序的代码长度，而是要清楚地估算代码长度的上限。根据经验，如果80%的ROM空间被代码占用的话，那么就太拥挤了，除非能确保系统需求不会有任何变化，否则至少要为可能发生的变化保留足够的备用ROM空间。  &lt;br /&gt;
 &amp;nbsp; &amp;nbsp; 在多数情况下，我们可以试着在ROM中写入一部分程序代码，以便观察代码占用空间的情况，对于带有内部ROM的微处理器系统来说，系统程序都只能占用有限的程序存储器空间。  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; d.经验之谈：ROM与RAM使用情况相类似，程序代码长度与所选用的开发语言有关。举例来说，使用汇编语言编制的程序要比使用C语言编制的程序占用少得多的空间。  &lt;br /&gt;
 &amp;nbsp; &amp;nbsp; 对于追求低成本的小型系统来说，一般不提倡使用高级程序设计语言；这是因为虽然高级语言在使用、调试以及维护方面来的比较容易，但同时这类语言需要占用更多的内存空间和大量的处理器时钟周期。  &lt;br /&gt;
 &amp;nbsp; &amp;nbsp; 如果开发语言选择不当，其后果可能是把一个简单、低成本的单片机系统变为一个需要使用配置若干兆字节RAM空间的64位嵌入式处理器系统。  &lt;br /&gt;
&lt;br /&gt;
 1.4.需要使用的中断数量  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 中断的主要用途是向中央处理器通报当前发生的某类特殊事件，这类事件包括诸如定时器超时事件、硬件引发的事件等。  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 需要强调的是，多数系统设计师经常过多地使用中断功能，实际上，中断的主要作用只是中断现行程序的执行，中断最适用于必须要求中央处理器立即提供服务的事件。  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 在需要设计和使用中断的情况下，一定要首先确认实际需要的中断数量，然后必须考虑到系统内部占用的中断资源，如果需要使用的中断资源超出了处理器可以接收的中断数量，我们就应借助于某些特殊手段来减少所需中断信号的数量。  &lt;br /&gt;
&lt;br /&gt;
 1.5.实时处理方面的考虑  &lt;br /&gt;
 &amp;nbsp;  &lt;br /&gt;
 &amp;nbsp; 实时处理是一个涉及范围很广的题目，其主要内容与系统的处理速度有密切联系，实时事件是嵌入式微处理器需要关注的主要任务。  &lt;br /&gt;
&lt;br /&gt;
&amp;nbsp;
例如：处理器跟串口进行通信时，通常通过上层软件（为了保证实时性，进行任务切换的时间足够短），然后再占用处理器去执行从串口拿数据的任务，并且要保证
处理器的速率比串口速率快，那么处理器可以以最快的速度反应并处理串口的相关的任务，这样就可以达到最大的实时性； &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 另一方面，如果处理器本身就内置了串口控制器、或DMA、或LCD的控制器等，那么它就可以保证直接使用这些处理器内置的接口去控制串口、液晶屏等对象，以达到最大的实时性能。  &lt;br /&gt;
&lt;br /&gt;
 1.6.该厂商是否提供好的开发工具和环境  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; 选择一款新的处理器，很可能就要使用一个新的开发工具和开发环境，包括软件的编译环境等；对于开发日程安排比较紧张的项目来说，开发人员往往无法抽出专门的时间来研究，熟悉新的开发工具，从而也无法全面掌握开发工具的使用技巧。  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 并且，有的开发工具价格也比较昂贵，而且很可能只能从制造商那里购买，还有仿真工具也是需要付费的，这些对我们在选择一款处理器的时候，是都应该考虑进去的成本因素。  &lt;br /&gt;
&lt;br /&gt;
 1.7.处理器速度方面的考虑  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 主要考虑几个细节问题：  &lt;br /&gt;
 &amp;nbsp; 1）处理器速度与处理器时钟之间的关系  &lt;br /&gt;
&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp;
例：单片机8031为例，由该处理器可以适应12MHz频率的输入时钟，因此就可以认为它是一个速度为12MHz的处理器了吗？不是，实际上，由于该处理
器内部逻辑电路执行每条指令需要多种不同频率的时钟脉冲，因此该处理器内部时钟电路要对输入的12MHz时钟12分频处理；最终为处理器提供的只是
1MHz主频。 &lt;br /&gt;
 &amp;nbsp; &amp;nbsp;  &lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; 有的时候，80MHz主频的处理器（80MHz输入时钟，80MHz执行速度）要比200MHz主频的处理器（200MHz输入时钟，50MHz执行速度）执行速度要快得多。  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 2）处理器指令系统  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; 如果不需要执行复杂数学运算的应用，那么RISC指令集的处理器要快；如果执行比较复杂的操作，则CISC指令集的处理器速度要更快。  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 3）芯片结构体系  &lt;br /&gt;
&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp;
现在有的芯片是将多个不同功能的核封装到一个芯片IC中，定制某种特定的功能，比如DSP，其中包括用于实现数字解码、乘法运算的硬件乘法器和移相器等；
然而，这类处理器也由其自身局限，往往在执行某些普通操作之前必须要使用额外的指令来把RAM中的数据放入内部寄存器，相比之下，一般处理器只允许对
RAM中的数据进行直接访问。 &lt;br /&gt;
&lt;br /&gt;
 1.8.只读存储器（ROM）的选择  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp;
多数工程项目在其开发阶段一般使用可擦写可编程只读存储器（EPROM）或快速存储器（Flash
Memory）；这类可擦写可重复写入存储器的主要优点是可多次使用。一旦产品研制完毕，就可以用一次写入设备（OTP）来取代EPROM存储器，一次性
写入器件的外观与封装几乎与EPROM完全一样，惟一不同之处就是其表面没有擦出窗口，并且价格要比EPROM低很多。 &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 但是，另外一种情况，如果该产品今后需要升级固件，或在线编程，那么我们还是应该选择可擦写可编程的存储器。  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 还有一种是非易失的存储器，例如制造一台电视机，就有可能需要该设备具有记忆上次观看最后一个频道的功能，即使在切断电源后，该频道信息也不会丢失。  &lt;br /&gt;
&lt;br /&gt;
 总结：所以，根据不同的产品选择不同的存储器也是一门很讲究的学问。  &lt;br /&gt;
&lt;br /&gt;
 1.9.电源的要求  &lt;br /&gt;
 &amp;nbsp;  &lt;br /&gt;
 &amp;nbsp; 在某些设计中方案中，电源根本不存在问题，对电源唯一的要求就是可以为电路正常供电；实际上，选择电源主要要考虑三个方面的问题：  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 1）要注意设计方案中是否对电源的供电方式有所限制，例如,是否像大多数家用电器那样需要使用屋内墙上的电源插座供电，或是是使用USB接口供电  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 2）看系统是否需要使用电池供电方式，如果这样，我们就要考虑选择那种对驱动电流要求不高的处理器，然后再为其选择合适的电池。  &lt;br /&gt;
&lt;br /&gt;
&amp;nbsp;
3）休眠电流：许多微处理器都支持低功率运行模式，在这种模式下，系统的CPU处理器将处于休眠状态，同时所有外部设备的电源供电都被暂时切断，以便减少
系统的电能消耗；某些微处理器在这种方式下需要的维持电流极小，但也有一些微处理器在这种方式下并不能节省多少功率；不管怎样，我们都要对系统在节点模式
下的工作时间有一个估测，以便对具体情况选择使用的电池。 &lt;br /&gt;
&lt;br /&gt;
 总之，无论哪种情况，我们都要对系统需要的供电总功率做到心中有数。  &lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
 1.10.设备工作环境的要求  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 环境要求主要内容是考虑温度，湿度等；如果系统必须在温度范围较大的环境下运行，诸如用于军事设备或汽车的控制系统，那么处理器可选择的范围就要小得多；  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 并且由于大范围温度变化的设备通常比较昂贵，因此在设计过程中就不能再根据一般工业级器件的价格来制定预算。  &lt;br /&gt;
&lt;br /&gt;
 1.11.使用周期成本  &lt;br /&gt;
 &amp;nbsp;  &lt;br /&gt;
 &amp;nbsp; 如果我们的产品是mp3，在一般情况下，可以不必考虑在用户现场对mp3程序进行修改的问题，也不用为是否可以得到设备备件而着急，这是因为mp3是一种消费产品；  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 换句话说，如果我们的产品是价值几万块的工业设备并且需要常年不断地运行，那么我们在产品设计过程中就必须从长计议了：  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; a.首先，我们需要选择一种处理器或存储体系结构都可以升级的器件  &lt;br /&gt;
 &amp;nbsp; b.考虑到程序升级的可能，我们还要选择较大容量的内存  &lt;br /&gt;
 &amp;nbsp; c.最后要注意的则是所选处理器是否可以长期供货，这一点的重要性远远大于处理器的价格  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 除了上面的考虑之外，使用周期成本也是在设计之初要考虑的因素。总的来说，生产的部件越多，则可以接受的前期开发成本也就越大。如果产品是mp3，我们可能会选择一个低价微处理器，同时投入一大笔钱来开发控制mp3的软件。  &lt;br /&gt;
&lt;br /&gt;
&amp;nbsp;
但如果我们的产品是价格昂贵的工业用设备，那么在产品的使用期内，该设备的销售量将只有几百台，毫无疑问，开发这种产品最重要的就是降低开发成本（降低开
发成本而不是硬件成本！！！）；除此之外，工业产品的成本也不像家用电器或消费电子产品那么敏感。综上所述，开发工业产品当然要选择一种便于进行开发并且
有助于缩短开发过程的处理器。 &lt;br /&gt;
&lt;br /&gt;
 1.12.处理器相关资料是否丰富  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; 如果该款处理器在市场上已经用得很广了，那么我们可以获取更多的相关资料，观察人家的产品是如何使用处理器的，也能在网络上找到不少的相关的设计资料以及相关技术主题，这样就进一步降低了技术门槛，确保了使用该处理器做产品可行性，减低了风险；  &lt;br /&gt;
 &amp;nbsp;  &lt;br /&gt;
 &amp;nbsp; &amp;nbsp; 反之，如果是厂商全新推出的处理器，因为市场上还没有可以借鉴的产品，我们就只能从全英文的芯片手册开始阅读，了解这款芯片，这样开发周期不仅变长，而且不可预知的风险也很大。  &lt;br /&gt;
&lt;br /&gt;
 3.开发成本的预测和估计  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 大多数项目或产品都有专人负责预测整个过程的开发成本，对于任何项目来说，其开发成本主要包括人力和材料开销。  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 预测开发成本在很大程度上需要根据经验，这也是为什么大型公司一般指定有经验的高级工程师来完成这一任务的原因，除了人力和材料的开销之外，总结下来，还有以下的开销：  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 1）人力成本（开发人员、管理人员、销售人员、其他行政等辅助人员）的开销  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 2）材料（硬件物料和损耗，有时候需要投几次PCB版才把产品稳定下来）的开销  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 3）开发系统和开发工具软件的开销  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 4）硬件工具的开销（例如示波器、仿真器等）  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 对于整个项目来说，上述的开销将直接可能导致产品成本增加，其中人力成本最为关键，尤其是在中国，呵呵&lt;/p&gt;
&lt;p&gt;4.产品开发设计文档（需要包括硬件和软件两个方面）  &lt;br /&gt;
&lt;br /&gt;
 4.1 硬件文档撰写思路  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; 1）首先是需求定义或产品规格：  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; 如果这些是产品最终目标的话，那么产品对硬件和软件的要求就是技术方案的最终目标；对硬件和软件的要求是从定义用户界面和系统功能开始的。  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; 2）其次，根据需求，系统整体定义文档中给出硬件接口的具体定义：  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; 定义硬件最有效的方法是从需求开始描述，由于硬件必须支持系统定义的所有功能，因此硬件定义是与系统说明不可分割的；  &lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp;
例如,我们设计一个定时器（事先需求说明定时器不能与个人电脑连接，故无法使用CRT显示时间），我们只有两种选择：一种是使用发光二极管（LED），另
一种是使用液晶显示器件（LCD）；尽管LCD的显示效果比较好，但考虑到定时器要常年位于户外，并且早期LCD显示器不能在低温下工作，最终还是选择
LED设备（这整个过程描述了我们硬件选型时的一个思路，这个是密切跟需求挂钩的） &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; 3）一旦完成了系统整体说明文档，就开始进行系统设计：  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; 首先要对硬件说明的内容进行细化，包括添加能让工程师理解的设计意图，以及软件工程师围绕硬件进行程序设计时需要使用的硬件信息等。  &lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; 完成硬件电路板说明文档后，我们还要在该文档中增加一个用来描述系统的原始要求的前言部分，包括说明方案的设计思路和方法，除此之外，还要附上软件工程师用来对硬件进行控制所需的各类信息，这类信息主要包括如下内容（软件工程所需信息）：  &lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; -----内存和I/O端口地址（如果需要，还可以提供内存映射图）  &lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; -----可用内存容量  &lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; -----状态寄存器每一位的定义  &lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; -----每个端口管脚的用途  &lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; -----外部设备的驱动方法（例如，说明输入定时器电路的时钟频率等）  &lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; -----其他有管软件人员设计程序需要了解的信息  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; 对于比较复杂的系统来说，硬件文档中经常使用两个独立的部分来进行说明；其第一部分用来描述硬件指标和工作原理，第二部分则主要为软件人员提供程序设计需要的信息。  &lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
 4.2 软件文档撰写思路  &lt;br /&gt;
&lt;br /&gt;
&amp;nbsp; &amp;nbsp; &amp;nbsp; 1)
软件文档与硬件文档的组织方法类似，软件要求文档的主要内容则是定义软件要实现的功能；一种是在简单项目设计过程中，软件定义也可以只对一种电路板使用的
软件给予描述；对较复杂的项目来说，由于参与这种项目的软件人员分别负责设计驱动不同硬件部分的代码（同一电路板），因此每个软件人员可能会为自己的设计
代码指定不同的定义,这类软件说明需要提供下列的内容： &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; -----论述包括需求定义、工程指标、硬件参数等实施项目需要的内容  &lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; -----说明软件之间、处理器之间或处理器与其内部器件之间使用的通信协议：其内容应包括对缓冲区接口机制、命令/应答协议、信号控制等协议的具体说明。  &lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; -----借助流程图、伪代码或者其他可能的方法来描述软件的实现方法和过程  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; 2) 软件与硬件所考虑的不同之处（此经验方便技术总监或其他相关管理者参考，因为无论是多高深的技术管理者，要么是硬件出身，要么是软件出身，要么就是非技术出身）  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; a. 软件的灵活性远远大于硬件，要让软件人员搞清楚某个软件的内部格式是非常困难的任务，解决的办法：详细定义其他程序员需要了解的编程接口具体内容，以及其他工程人员在实施开发项目过程中需要使用的技术细节信息。  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; b. 软件工程师只有在收到硬件说明文档后，才有可能知道如何对系统硬件进行操作；而硬件人员一般不需要了解软件程序的技术细节。  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; c. 由于软件易于更改，因此程序内容经常会按销售人员提供的要求发生变更，在某些情况下，软件文档的内容无法及时反映程序的最新变化。  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; d. 软件经常是工程项目最后完成的部分，因此其文档也经常因时间不够而欠缺完整。实际上，软件文档是否详细、完整，在某种程度上是与公司或客户的要求有关的。例如，军事或国家工程一般要求开发商就其所有软件实现的功能提供全面详细的文档  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; e. 有个潜规则，对软件的要求越复杂，则需求的正确可能性就越小，这个是经验之谈了，我们需要把准需求这个准绳来做文章，而不是陷入个人主义以及对软件要求而凭空发挥自己不切实际的想象。  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; f. 我们可以先硬件设计，接着围绕该硬件编制软件。虽然实际系统的实现过程可能是软硬件并行开发，但软件人员基本上也是围绕着已经实现的硬件来进行程序设计的；对于更为复杂的系统来说，开发过程可能会出现重复。  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; 例如，某个项目的硬件工程师和软件工程师可能会坐下来开会，共同决定使用哪种硬件来实现某种功能；软件人员可能提出需要为数据缓冲区口冲内存容量，也可能要求提供某种外部设备接口，以便充分利用现成接口程序提供的各种驱动代码。  &lt;br /&gt;
&lt;br /&gt;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; 总的来说，必须在提高软件开发效率与硬件系统的复杂性与成本之间进行权衡.  &lt;br /&gt;
&lt;br /&gt;
 转载：http://www.armjishu.com/bbs/viewtopic.php?id=1312
&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>关于Ubuntu9.04中wubi.exe无法运行</title>
   <link href="http://jiang-bo.github.com/blog/2009/06/21/post"/>
   <updated>2009-06-21T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/06/21/post</id>
   <content type="html">&lt;p&gt;用虚拟光驱加载Ubuntu9.04镜像，双击wubi.exe的时候没有任何反应，在网上查了查，说是因为9.04对中文的支持有问题，安装时盘符终不能有中文，可是我检查了一下，所有的盘符都是英文啊，最后发现，光驱中插了一张名为&quot;我的光盘&quot;的光盘，退出来之后再运行wubi.exe就没什么问题了&amp;hellip;&amp;hellip;狂汗&amp;amp;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>ubuntu在机房上网</title>
   <link href="http://jiang-bo.github.com/blog/2009/06/19/post"/>
   <updated>2009-06-19T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/06/19/post</id>
   <content type="html">&lt;p&gt;最近资金紧张，没钱交网费，只好到机房上网了，不过又怀念自己的linux，因此在机房的机器上装了个Ubuntu。下面简要记录下如何配置上网。&lt;/p&gt;
&lt;p&gt;Ubuntu默认安装的是DHCP&lt;br /&gt;
# The primary network interface
&lt;br /&gt;
auto eth0
&lt;br /&gt;
iface eth0 inet dhcp
&lt;br /&gt;
&amp;nbsp;&lt;br /&gt;
先要取消DHCP&lt;br /&gt;
编辑/etc/network/interfaces
&lt;br /&gt;
$sudo vim /etc/network/interfaces&lt;br /&gt;
# The primary network interface
&lt;br /&gt;
auto eth0
&lt;br /&gt;
#iface eth0 inet dhcp
&lt;br /&gt;
&amp;nbsp;&lt;br /&gt;
设置IP地址和网关地址&lt;br /&gt;
# The primary network interface
&lt;br /&gt;
iface eth0 inet static
&lt;br /&gt;
address 192.168.4.148
&lt;br /&gt;
netmask 255.255.255.0
&lt;br /&gt;
gateway 192.168.4.254&lt;/p&gt;
&lt;p&gt;设置DNS服务器地址,编辑文件/etc/resolv.conf&lt;br /&gt;
$sudo vim /etc/resolv.conf
&lt;br /&gt;
nameserver 202.118.224.101
&lt;br /&gt;
nameserver 202.106.0.20
&lt;br /&gt;
&amp;nbsp;&lt;br /&gt;
重启eth0&lt;br /&gt;
$sudo ifdown eth0
&lt;br /&gt;
$sudo ifup eth0&lt;/p&gt;
&lt;p&gt;机房有时会限制MAC地址，修改MAC地址命令如下&lt;br /&gt;
$sudo ifconfig eth0 up
&lt;br /&gt;
$sudo ifconfig eth0 hw ether 00:10:5C:E1:63:E1
&lt;br /&gt;
$sudo ifconfig eth0 down&lt;/p&gt;
&lt;p&gt;
不过每次重启后都会失效&lt;br /&gt;
&amp;nbsp;自己写了一个脚本&lt;/p&gt;
&lt;p&gt;#!/bin/sh&lt;br /&gt;
echo &amp;quot; **************************************************************&amp;quot;&lt;br /&gt;
echo &amp;quot; *&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Configure IP&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; *&amp;quot;&lt;br /&gt;
echo &amp;quot; * Copyright by Jiang Bo &amp;lt;jiang_eis@hotmail.com&amp;gt; 2009.6.10&amp;nbsp;&amp;nbsp;&amp;nbsp; *&amp;quot;&lt;br /&gt;
echo &amp;quot; **************************************************************&amp;quot;&lt;br /&gt;
&lt;br /&gt;
echo &amp;quot; shut down eth0...&amp;quot;&lt;br /&gt;
ifconfig eth0 down&lt;br /&gt;
&lt;br /&gt;
echo &amp;quot; configure MAC...&amp;quot;&lt;br /&gt;
ifconfig eth0 hw ether 00:10:5C:E1:63:E1&lt;br /&gt;
&lt;br /&gt;
echo &amp;quot; configure ip address...&amp;quot;&lt;br /&gt;
ifconfig eth0 192.168.4.148 netmask 255.255.255.0&lt;br /&gt;
&lt;br /&gt;
echo &amp;quot; configure gateway address...&amp;quot;&lt;br /&gt;
route add default gw 192.168.4.254&lt;br /&gt;
&lt;br /&gt;
echo &amp;quot; set up eth0...&amp;quot;&lt;br /&gt;
ifconfig eth0 up&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;每次重启后直接执行这个脚本就行了^^&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>关于进程间通信</title>
   <link href="http://jiang-bo.github.com/blog/2009/06/15/post"/>
   <updated>2009-06-15T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/06/15/post</id>
   <content type="html">&lt;p&gt;简要记录一下今天遇到的问题和解决方法&lt;br /&gt;
主函数需要创建一个监听网络端口的守护进程，并将监听到的数据传递给主函数，用于显示。其中，主函数有Qt实现，因此需要采用多线程来维护显示界面，即用一个线程维护显示界面，另一个线程负责向界面上添加数据。（坦白说，我觉得肯定有很简单的方法就能够实现显示数据，不过，由于图形界面不是我负责，自己又不会Qt，没办法了～～研究中）&lt;br /&gt;
现在的问题是，守护进程如何将监听到的数据传递给父进程中负责显示的线程？很显然，不能采用函数返回值，守护进程要是能返回，也就不叫守护进程了，也不能用全局变量，因为父子进程不共享全局变量。翻了半天书，发现可以用IPC，尝试了最简单的管道，找到一种很笨的方法。&lt;br /&gt;
下面是一个简单的例子&lt;br /&gt;
#include &amp;lt;unistd.h&amp;gt;&lt;br /&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;br /&gt;
#include &amp;lt;pthread.h&amp;gt;&lt;br /&gt;
#define MAXLINE&amp;nbsp;&amp;nbsp;&amp;nbsp; 1024&lt;br /&gt;
int fd[2];&lt;br /&gt;
pthread_t pthid;&lt;br /&gt;
void* getMsg(void* arg)//父进程中负责显示的线程函数&lt;br /&gt;
{&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; char buff[MAXLINE];&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; int n;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; close(fd[1]); //关闭写管道&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; while(1)&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; n=read(fd[0],buff,MAXLINE);//从管道中读取数据&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; buff[n]='/0';&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; printf(&amp;quot;%s/n&amp;quot;,buff);//实际应用中要用Qt实现~&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br /&gt;
&lt;br /&gt;
}&lt;br /&gt;
int main(void)&lt;br /&gt;
{&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; int&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp; n;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; int&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp; err;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; pid_t&amp;nbsp;&amp;nbsp;&amp;nbsp; pid;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; char&amp;nbsp;&amp;nbsp;&amp;nbsp; line[MAXLINE];&lt;br /&gt;
&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; if(pipe(fd)&amp;lt;0)&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; fprintf(stderr, &amp;quot;pipe error/n&amp;quot;);&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; return -1;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; if((pid=fork())&amp;lt;0)&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; fprintf(stderr,&amp;quot;fork error/n&amp;quot;);&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; return -1;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; else if(pid＝0)//子进程&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; while(1)&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp; close(fd[0]);//关闭读管道&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp; write(fd[1],&amp;quot;hello/n&amp;quot;,sizeof(&amp;quot;hello/n&amp;quot;));//向管道中写数据&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp; sleep(1);&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; else&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; err=pthread_create(&amp;amp;pthid,NULL,getMsg,NULL);//创建线程&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; if(err!=0)&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp; fprintf(stderr,&amp;quot;can't create thread/n&amp;quot;);&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp; exit(1);&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; while(1)&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp; printf(&amp;quot;this is main thread/n&amp;quot;);&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp; sleep(1);&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&lt;br /&gt;
}&lt;br /&gt;
&lt;br /&gt;
感觉这个办法非常笨？但又找不到更好的～发愁中&amp;hellip;&amp;hellip;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>关于ARM的内存重映射</title>
   <link href="http://jiang-bo.github.com/blog/2009/05/25/post"/>
   <updated>2009-05-25T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/05/25/post</id>
   <content type="html">&lt;p&gt;先说说存储器映射：&lt;br /&gt;所谓存储器映射，是指将开发板上不同的存储器映射到开发人员可见的4GB地址空间上，例如，假设开发板上有一个32KB的片内FLASH，16KB的片内SRAM（纯属虚构，如有雷同，纯属巧合），那么，将32KBFLASH映射到地址空间的0x00000000~0x0x00008FFF上，将16KB的SRAM映射到x40000000~0x40004fff上，这样开发者在读写0x00000000~0x00008fff内的地址时，访问的就是片内FLASH，不同开发板的映射规则是开发板厂商事先设定好的。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;下面说说什么是重映射：&lt;br /&gt;重映射分为中断向量的重映射和boot的重映射&lt;br /&gt;首先说说中断向量重映射&lt;br /&gt;ARM中中断向量的地址位于0x00000000~0x0000003c(每个向量占4字节，但是为了能够实现4GB范围内的任意跳转，通常在中断向量表后附加一个跳转地址空间，跳转空间占4字节，因此，总的中断向量表大小为64B,不熟悉的自己查查ARM的中断向量吧，不多说了)。注意，这里所说的0x0000000~0x0000003C指的是用户可见的4GB地址空间（也就是上面所说的存储器映射后的地址空间），真正的中断向量位于哪块存贮器的哪个地址上可不一定(不过通常都是为与片内FLASH的底部)，因此，需要将不同存储器的中断向量表映射到0x00000000~0x0000003c的地址上。另外，还有一次中断向量的映射，在用户RAM的映射模式（稍后说映射模式）下，需要将中断向量映射到静态RAM的底部(很明显，这样能够提高访问速度)。&lt;br /&gt;下面是boot的重映射&lt;br /&gt;这里所说的boot不是bootloader，而是厂商实现内嵌到板子中的一段代码，用于执行对FLASH的读写，擦除等任务，通常位于片内存储器上，但是不同的板子上存储器的大小不同，为了程序的兼容，通常需要将boottblock重映射到存储空间的顶端。&lt;/p&gt;
&lt;p&gt;最后说一下映射模式：&lt;br /&gt;ARM中支持4中映射模式，由存储器控制寄存器控制&lt;br /&gt;四种模式为：&lt;br /&gt;1.boot装载程序模式：在任何复位操作后都会执行Boot装载程序。Bootblock中中断向量映射到存储器的底端以允许处理异常，并在Boot装载过程中使用中断。&lt;br /&gt;2.用户FLASH模式：当在存储器中识别了一个有效的用户程序标识并且Boot装载操作未被执行时，由Boot装载程序启动。中断向量没有重新映射，位于Flash的存储器底部&lt;br /&gt;3.用户Flash：中断向量被映射到静态RAM的底部&lt;br /&gt;4.用户外部模式：中断向量有外部存储器映射到存储空间底部。&lt;/p&gt;
&lt;p&gt;大概就这些，该上课去了，全是个人揣摩，有错请轻拍:)&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>s3c2410开发日志——关于yaffs无法解压</title>
   <link href="http://jiang-bo.github.com/blog/2009/05/12/post"/>
   <updated>2009-05-12T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/05/12/post</id>
   <content type="html">&lt;p&gt;今天终于把yaffs挂载上去了~不容易啊~~记录一下。&lt;br /&gt;原来出现的问题：&lt;br /&gt;mount: Mounting /dev/mtdblock/1 on /mnt/yaffs failed: No such file or directory&lt;br /&gt;然后能够进入根文件系统cramfs中，终端输出如下：&lt;br /&gt;BusyBox v1.00 (2005.01.20-11:59+0000) Built-in shell (ash)&lt;br /&gt;Enter 'help' for a list of built-in commands.&lt;/p&gt;
&lt;p&gt;runing /etc/profile ok&lt;br /&gt;[/mnt/yaffs]&lt;br /&gt;然后按照指导书上的方法将yaffs.tar.bz2通过ftp上传到目标板中，解压，出现错误如下：&lt;br /&gt;[~/tmp]tar -jvxf yaffs.tar.bz2 -C /mnt/yaffs&lt;br /&gt;./ad&lt;br /&gt;./ad/s3c2410-adc.o&lt;br /&gt;tar: Cannot create directory `./ad': Operation not permitted&lt;br /&gt;tar: ./ad/s3c2410-adc.o: No such file or directory&lt;br /&gt;无法在/mnt/yaffs目录下进行任何操作。&lt;/p&gt;
&lt;p&gt;原因分析：&lt;br /&gt;vivi中有两种分区格式，bon和mtd，&lt;br /&gt;bon分区用bon part命令来分区，内核在启动的是后在bon分区里查找内核，和根文件系统，但是如果想挂载&lt;/p&gt;
&lt;p&gt;yaffs系统，就必须在bon分区中指定一个mtd分区，方法是在该分区后加一个:m，例如&lt;br /&gt;bon part 0 128K 192K 1216K 6336K:m&lt;br /&gt;这个命令就是将最后一个分区指定为mtd分区。&lt;br /&gt;还有一点就是，part分区的时候为每个分区指定了名字，使用vivi下载的时候需要这个名字，因此，part分区中&lt;/p&gt;
&lt;p&gt;kernel，root，的起止地址要相同，否则会出现根文件系统无法下载。&lt;/p&gt;
&lt;p&gt;关于bon分区和mtd分区的具体区别还不清楚，目前只知道这样可以解决困扰了三天的问题。&lt;br /&gt;2.6内核还是移植不上来，分区也已经改了，但是还是不行，网上的一个人说可能是内核的问题，下了一个&lt;/p&gt;
&lt;p&gt;2.6.22，还没来的及试。&lt;br /&gt;基本上就这样吧&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Ubuntu 9.04安装arm-linux-gcc交叉编译工具</title>
   <link href="http://jiang-bo.github.com/blog/2009/05/06/post"/>
   <updated>2009-05-06T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/05/06/post</id>
   <content type="html">&lt;p&gt;最近要开发嵌入式linux，但是手头上大多文档中介绍交叉编译环境的都是基于RedHat9的，这个版本虽说很经典，但是毕竟实在是太古老了，自己机器上本身装的是Ubuntu，因此小小的研究了一下，在ubuntu中安装交叉编译环境 arm-linux-gcc&lt;br /&gt;下面所有yourname替换为你自己的位于/home目录下的用户名&lt;br /&gt;&lt;strong&gt;首先是准本工作&lt;/strong&gt;：&lt;br /&gt;需要的安装包：&lt;br /&gt;crosstool-0.43.tar.gz 可以在http://kegel.com/crosstool/crosstool-0.43.tar.gz获得&lt;br /&gt;创建一个文件夹&lt;br /&gt;mkdir /home/yourname/downloads也可以用mkdir ~/downloads&lt;br /&gt;将crosstool-0.43.tar.gz复制到downloads目录下（下载完成后默认应该实在桌面上）&lt;br /&gt;&lt;br /&gt;另外，还有一些安装包：&lt;br /&gt;binutils-2.16.1.tar.bz2&amp;nbsp; &lt;br /&gt;glibc-2.3.2.tar.bz2&lt;br /&gt;glibc-linuxthreads-2.3.2.tar.bz2&lt;br /&gt;gcc-3.3.6.tar.bz2&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br /&gt;linux-2.6.15.4.tar.bz2&lt;br /&gt;gcc-4.1.0.tar.bz2&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br /&gt;linux-libc-headers-2.6.12.0.tar.bz2&lt;br /&gt;gdb-6.5.tar.bz2&lt;br /&gt;这些在安装过程中会自动下载，也可以自己提前下载好，放在/home/yourname/downloads下面，不过我建议提前下好，因为一会需要修改一下glibc里的一个文件。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br /&gt;&lt;strong&gt;&lt;br /&gt;下面是一些安装是可能遇到的问题，提前些出来，省得大家忙活半天编译到一半发现错了还得重新编译，如果你想见识一下这些问题，可以直接跳转到下面的安装过程&lt;/strong&gt;。&lt;br /&gt;1.安装过程中会提示缺少下面两个包&lt;br /&gt;bison&lt;br /&gt;flex&lt;br /&gt;如果以前没有装过，下载安装一下（具体包名我忘记了，可以直接输入bison查看，如果没装过，会提示你可以下载哪些包安装，flex类似）&lt;br /&gt;sudo apt-get install bison&lt;br /&gt;sudo apt-get install flex&lt;br /&gt;另外网上说还需要一个mm4，不过我装的时候没有提示，好象是安装flex时，解决依赖性时自动装上了。&lt;br /&gt;&lt;br /&gt;2.还有一个莫名其妙的错误，提示说gcc版本太旧或者未安装，但是你用sudo apt-get install gcc 的时后会发现gcc已经是最新版本了，事实上这个错误是因为gcc版本太新了。解决方法如下：&lt;br /&gt;sudo apt-get install gcc-3.4&lt;br /&gt;cd /usr/bin&lt;br /&gt;sudo rm gcc&lt;br /&gt;ln -s gcc-3.4 gcc&lt;br /&gt;&lt;br /&gt;3.安装是还出现了如下错误：&lt;br /&gt;/home/xxs/crosstool-0.43/build/arm-arm9tdmi-linux-gnu/gcc-4.1.1-glibc-2.3.2/build-glibc/csu/version-info.h:1:1:&amp;nbsp; missing terminating &quot; character&lt;br /&gt;系统在编译生成version.o时候发现version-info.h文件有错误&lt;br /&gt;&lt;br /&gt;解决方法是需要修改一个文件&lt;br /&gt;解压glibc-2.3.2.tar.bz2&lt;br /&gt;找到glibc-2.3.2/csu目录下的Makefile按如下修改&lt;br /&gt;文件末尾有2处echo&lt;br /&gt;echo&lt;br /&gt;&quot;/&quot;Compiled on a $$os $$version system&quot; /&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &quot;on&lt;br /&gt;`date +%Y-%m-%d`.//n/&quot;&quot; ;; /&lt;br /&gt;改为：&lt;br /&gt;echo&lt;br /&gt;&quot;/&quot;Compiled on a $$os $$version system&quot; /&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &quot;on&lt;br /&gt;`date +%Y-%m-%d`.////n/&quot;&quot; ;; /&lt;br /&gt;echo&lt;br /&gt;&quot;/&quot;Available extensions://n/&quot;&quot;;&lt;br /&gt;改为：&lt;br /&gt;echo&lt;br /&gt;&quot;/&quot;Available extensions:////n/&quot;&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp; /&lt;br /&gt;保存并重新压缩为glibc-2.3.2.tar.bz2 覆盖原来downloads目录下的glibc-2.3.2.tar.bz2&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;解决好上面的一些小问题就可以开始安装了&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;1.创建一个安装目录&lt;br /&gt;sudo mkdir /opt/crosstool&lt;br /&gt;这是因为安装文件默认是安装到这个目录里的&lt;br /&gt;&lt;br /&gt;2.为你自己添加权限&lt;br /&gt;sudo chown yourname /opt/crosstool&lt;br /&gt;&lt;br /&gt;3.解压crosstools-0.43.tar.gz(此时安装包应该位于/home/yourname/downloads/目录下，不是的话自己改一下)&lt;br /&gt;tar -zvxf crosstools-0.43.tar.gz&lt;br /&gt;进入cross目录&lt;br /&gt;cd cross-0.43&lt;br /&gt;可以ls一下看看里面的文件，里面有一些脚本文件，具体功能可以到http://kegel.com/crosstool上查看FAQ&lt;br /&gt;&lt;br /&gt;4.运行./demo-arm.sh进行安装&lt;br /&gt;这步要注意，网上有人说需要修改脚本文件里的一些设置，我没改也装上了，不知道为什么。&lt;br /&gt;&lt;br /&gt;5.剩下的就等着编译安装吧，很漫长～～&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;修改环境变量&lt;/strong&gt;&lt;br /&gt;安装完成后，默认的那装目录就是开始创建的那个/opt/crosstools/&lt;br /&gt;1.添加环境变量&lt;br /&gt;gedit ~/.bashrc&lt;br /&gt;在最后添加如下&lt;br /&gt;if [ -d /opt/crosstool/gcc-4.1.0-glibc-2.3.2/arm-unknow-linux-gnu ]; then&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; PATH=/opt/crosstool/gcc-4.1.0-glibc-2.3.2/arm-unknow-linux-gnu/bin:$PATH&lt;br /&gt;fi&lt;br /&gt;就是把安装的工具bin目录添加到PATH变量中。&lt;br /&gt;保存&lt;br /&gt;2.source ~/.bashrc&lt;br /&gt;3.重启终端。&lt;br /&gt;然后可以测试一下&lt;br /&gt;arm-unknow-linux-gnu-gcc&lt;br /&gt;正常的话就会出现&lt;br /&gt;arm-unknow-linux-gnu-gcc: no input files&lt;br /&gt;说明程序能用了。&lt;br /&gt;&lt;br /&gt;剩下的就是继续探索～&lt;br /&gt;革命尚未成功，同志还需努力&lt;br /&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Android SDK1.5开发体验</title>
   <link href="http://jiang-bo.github.com/blog/2009/05/05/post"/>
   <updated>2009-05-05T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2009/05/05/post</id>
   <content type="html">&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;今天在机房尝试了一下&lt;a onclick=&quot;tagshow(event, 'Android');&quot; href=&quot;javascript:;&quot; target=&quot;_self&quot;&gt;&lt;span style=&quot;text-decoration: underline;&quot;&gt;&lt;strong&gt;Android&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt; SDK1.5，下载，安装，修改PATH，和以前一样，不熟悉的话还是去&lt;a href=&quot;http://developer.android.com/sdk/1.5_r1/index.html&quot;&gt;http://developer.android.com/sdk/1.5_r1/index.html&lt;/a&gt;上自己看吧。&lt;/p&gt;
&lt;p&gt;下面说个小问题，之前版本的SDK，你写个HelloWorld，按照&lt;a onclick=&quot;tagshow(event, 'google');&quot; href=&quot;javascript:;&quot; target=&quot;_self&quot;&gt;&lt;span style=&quot;text-decoration: underline;&quot;&gt;&lt;strong&gt;google&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;网站上说的，run的时候，会出现&lt;/p&gt;
&lt;p&gt;[2009-05-05 16:18:13 - HelloWorld] ------------------------------&lt;br /&gt;[2009-05-05 16:18:13 - HelloWorld] Android Launch!&lt;br /&gt;[2009-05-05 16:18:13 - HelloWorld] adb is running normally.&lt;br /&gt;[2009-05-05 16:18:13 - HelloWorld] Performing com.jiang.android.HelloWorld activity launch&lt;br /&gt;[2009-05-05 16:18:13 - HelloWorld] Failed to find an &lt;a onclick=&quot;tagshow(event, 'AVD');&quot; href=&quot;javascript:;&quot; target=&quot;_self&quot;&gt;&lt;span style=&quot;text-decoration: underline;&quot;&gt;&lt;strong&gt;AVD&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt; compatible with target 'Android 1.1'. Launch aborted.&lt;/p&gt;
&lt;p&gt;针对这个问题官方的解释在&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://developer.android.com/guide/developing/eclipse-adt.html#Running&quot;&gt;http://developer.android.com/guide/developing/eclipse-adt.html#Running&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看懂了之后其实很容易，就是在运行模拟器之前必须要自己创建一个AVD（Android Virtual Device，Android虚拟设备），相当于配置你要模拟的目标平台一样，方法如下：&lt;/p&gt;
&lt;p&gt;1.打开CMD，输入命令android list targets，查看所有可用的目标平台（如果出现android命令无法找到，是因为你的PATH变量没配置，这就不用我多说了），显示结果为&lt;/p&gt;
&lt;p&gt;Available Android targets:&lt;/p&gt;
&lt;p&gt;id: 1&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;Name: Android 1.1&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;Type: Platform&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;API level: 2&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;Skins: HVGA (default), HVGA-L, HVGA-P, QVGA-L, QVGA-P&lt;/p&gt;
&lt;p&gt;id: 2&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;Name: Android 1.5&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;Type: Platform&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;API level: 3&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;Skins: HVGA (default), HVGA-L, HVGA-P, QVGA-L, QVGA-P&lt;/p&gt;
&lt;p&gt;id: 3&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;Name: Google APIs&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;Type: Add-On&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;Vendor: Google Inc.&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;Description: Android + Google APIs&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;Based on Android 1.5 (API level 3)&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;Libraries:&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;* com.google.android.maps (maps.jar)&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;API for Google Maps&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;Skins: QVGA-P, HVGA-L, HVGA (default), QVGA-L, HVGA-P&lt;/p&gt;
&lt;p&gt;2.创建一个你想要的AVD，使用如下&lt;a onclick=&quot;tagshow(event, '%C3%FC%C1%EE');&quot; href=&quot;javascript:;&quot; target=&quot;_self&quot;&gt;&lt;span style=&quot;text-decoration: underline;&quot;&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;android create avd --name&lt;em&gt;&amp;lt;your_avd_name&amp;gt;&lt;/em&gt;--target&lt;em&gt;&amp;lt;targetID&amp;gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;例如：andorid create avd --name adt15 --target 2命令，创建了一个名为adt15的2号（Android1.5）平台的AVD。&lt;/p&gt;
&lt;p&gt;3.然后会询问是否配置硬件设备，我没有硬件，就没配置，默认是NO，如果你想配置的话，输入yes就行。&lt;/p&gt;
&lt;p&gt;4.回到Eclipse里，继续RUN，这是就能搞定了。&lt;/p&gt;
&lt;p&gt;PS一下：模拟器编译装载实在是太慢了，一个HelloWorld要用7分钟，才能运行，不过好歹是能运行了，一下是Eclipse里的输出：&lt;/p&gt;
&lt;p&gt;[2009-05-05 16:35:26 - HelloWorld] ------------------------------&lt;br /&gt;[2009-05-05 16:35:26 - HelloWorld] Android Launch!&lt;br /&gt;[2009-05-05 16:35:26 - HelloWorld] adb is running normally.&lt;br /&gt;[2009-05-05 16:35:26 - HelloWorld] Performing com.jiang.android.HelloWorld activity launch&lt;br /&gt;[2009-05-05 16:35:26 - HelloWorld] Automatic Target Mode: launching new emulator with compatible AVD 'android15r1'&lt;br /&gt;[2009-05-05 16:35:26 - HelloWorld] Launching a new emulator with Virtual Device 'android15r1'&lt;br /&gt;[2009-05-05 16:35:30 - HelloWorld] New emulator found: emulator-5554&lt;br /&gt;[2009-05-05 16:35:30 - HelloWorld] Waiting for HOME ('android.process.acore') to be launched...&lt;br /&gt;[2009-05-05 16:40:28 - HelloWorld] HOME is up on device 'emulator-5554'&lt;br /&gt;[2009-05-05 16:40:28 - HelloWorld] Uploading HelloWorld.apk onto device 'emulator-5554'&lt;br /&gt;[2009-05-05 16:40:29 - HelloWorld] Installing HelloWorld.apk...&lt;br /&gt;[2009-05-05 16:42:11 - HelloWorld] Success!&lt;br /&gt;[2009-05-05 16:42:11 - HelloWorld] Starting activity com.jiang.android.HelloWorld on device&lt;br /&gt;[2009-05-05 16:42:51 - HelloWorld] ActivityManager: Starting: Intent { comp={com.jiang.android/com.jiang.android.HelloWorld} }&lt;/p&gt;
&lt;p&gt;这时你在模拟器里就能看到Helloworld了，注意，一定要耐心等待。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Eclipse 中中文乱码的问题</title>
   <link href="http://jiang-bo.github.com/blog/2008/07/12/post"/>
   <updated>2008-07-12T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2008/07/12/post</id>
   <content type="html">&lt;p&gt;很久没有写Java程序了，最近课程设计，要做个搜索引擎，用Eclipse开发java，结果抓来的网页数据在Eclipse 中全是乱码，另外，程序中如果有中文，编译不能通过，提示cp1252编码错误，晕，头一次听说这个编码，在网上搜了搜，得到了简单的解决方案：（其实是基本常识，哈哈~）&lt;/p&gt;&lt;p&gt;1. 点击Run，选择Open run Dialog&lt;/p&gt;&lt;p&gt;2. 选择common面板&lt;/p&gt;&lt;p&gt;3. 修改编码方式，默认为那个所谓的cp1252,修改为UTF-8就OK啦&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>cygwin 和 ns-2的安装</title>
   <link href="http://jiang-bo.github.com/blog/2008/06/23/post"/>
   <updated>2008-06-23T00:00:00+08:00</updated>
   <id>http://jiang-bo.github.com/blog/2008/06/23/post</id>
   <content type="html">&lt;p&gt;由于这段时间要和老师一起做一个无限传感器网络的研究课题，所以要用到开源的网络模拟软件ns-2,这个东东虽好，可是安装起来继承了linux/unix软件的安装的特点，超级麻烦~ &lt;/p&gt;
&lt;p&gt;由于课题的大部分开发还是要在windows下开发，所以不得不选择使用cygwin（如果不知道这个是什么，那就不用学了~）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装cygwin&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;1.连到cygwin的网站上，http://www.cygwin.com，点击Install or Update now这个按钮，会下载一个网络安装的程序。 &lt;/p&gt;
&lt;p&gt;2.点击安装程序，按照步骤一步一步往下做，主要是在遇到Select Package这一个步骤的时候，要安装ns2需要的组件。（还有一点，就是选择下载的源，我用的是http://mirrors.kernel.org,感觉速度还可以,如果网速太慢，可以联系我，我这又全部所需的）点击View这个按钮使得Category变成full，可以看到所有的软件包，包括安装的和没安装的，点击下列软&amp;nbsp;&amp;nbsp; 件的New这一栏的Skip状态，使之变成日期（即最新版本）。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; XFree86-base、XFree86-bin、XFree86-prog、XFree86-lib、XFree86-etc、make、patch、perl、gcc、gcc-&amp;nbsp;&amp;nbsp;&amp;nbsp;g++、gawk、gnuplot、tar和gzip，还有X-startup-scripts、xorg-x11-base、xorg-x11-bin、xorg-x11-devel、xorg-x11-bin-dlls、xorg-x11-bin-lndir、xorg-x11-etc、xorg-x11-fenc、xorg-x11-fnts、xorg-x11-libs-data、xorg-x11-xwin，最好把vi 也安装上，会有用的。然后一路next就行了下面是关键的 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装ns-2&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;1.到http://nsnam.isi.edu/nsnam/index.php/Main_Page&amp;nbsp; 下载ns-2.31 &lt;/p&gt;
&lt;p&gt;2.将ns-allinone-2.31.tar.gz解压到C:/cygwin/home下，如果没有就自己建一个 &lt;/p&gt;
&lt;p&gt;3.在cygwin中运行如下命令： &amp;nbsp;&amp;nbsp; cd /home/ns-allinone-2.31 &amp;nbsp;&amp;nbsp; /.install &amp;nbsp;&amp;nbsp; 然后就等着安装完成就行了（要安装很长时间，我装了一个多小时） &lt;/p&gt;
&lt;p&gt;4.看到install sucessfully的时候，恭喜了，你顺利地装完了，不过别高兴，关键的配置PATH才刚开始 &amp;nbsp;&amp;nbsp; 如果你能在 /home/你的用户名 的文件夹下找到后缀名为.bashrc的文件（反正我是没找到，以下都是老师教的，我没试过），注意，不是.bashrc.bak,用UltraEdit把它打开，（最好用UltraEdit，不要用记事本，应为该文件是unix文件，用记事本会出现意想不到的错误，当然如果你会用vi，肯定也没什么问题），在文件后加上 &lt;/p&gt;
&lt;p&gt;export NS_HOME=/home/&lt;strong&gt;Benson/&lt;/strong&gt;ns-allinone-&lt;strong&gt;2.31&lt;/strong&gt; 　&lt;/p&gt;
&lt;p&gt;export PATH=$NS_HOME/t&lt;strong&gt;cl8.4.14/&lt;/strong&gt;unix:$NS_HOME&lt;strong&gt;/tk8.4.14&lt;/strong&gt;/unix:$NS_HOME/bin:$PATH &lt;/p&gt;
&lt;p&gt;export LD_LIBRARY_PATH=$NS_HOME/&lt;strong&gt;tcl8.4.14&lt;/strong&gt;/unix:$NS_HOME/&lt;strong&gt;tcl8.4.14/&lt;/strong&gt;unix:$NS_HOME/otcl-&lt;strong&gt;1.13&lt;/strong&gt;:$NS_HOME/lib:$LD_LIBRARY_PATH &lt;/p&gt;
&lt;p&gt;export TCL_LIBRARY=$NS_HOME/&lt;strong&gt;tcl8.4.14&lt;/strong&gt;/librar&lt;/p&gt;
&lt;p&gt;注意修改你的相应的路径名和版本号（黑体的部分）&lt;/p&gt;
&lt;p&gt;##如果你找不到在/home/你的用户名 的目录下找不到那个文件，那么就去/etc 下 找到bash.bashrc文件，用UltraEdit打开，按上面的方式添加到文件末尾，点击保存，不过这时候，修改还是没有生效，必须在cygwin下运行&lt;/p&gt;
&lt;p&gt;cd /etc&lt;/p&gt;
&lt;p&gt;source bash.bashrc&lt;/p&gt;
&lt;p&gt;从而使修改生效&lt;/p&gt;
&lt;p&gt;至此，如果一切顺利的话你的ns-2就安装好了&lt;/p&gt;
&lt;p&gt;可以使用如下命令检测是否成功安装：&lt;/p&gt;
&lt;p&gt;startxwin.bat&lt;/p&gt;
&lt;p&gt;cd /home/ns-allinone-2.31/ns-2.31/tcl/ex(路径名可能和你安装的不一样，注意修改)&lt;/p&gt;
&lt;p&gt;ns wireless-flooding.tcl&lt;/p&gt;
&lt;p&gt;你将会看到一个ns-2的模拟事例&lt;/p&gt;</content>
 </entry>
 
 
</feed>